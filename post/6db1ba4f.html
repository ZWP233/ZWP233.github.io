<!DOCTYPE html><html lang="zh-CN" data-theme="dark"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>iOS面试题 | Peter の 博客</title><meta name="keywords" content="iOS,面试"><meta name="author" content="Peter"><meta name="copyright" content="Peter"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#0d0d0d"><meta name="description" content="iOS2023年最新面试题（持续更新中）  Excerpt OC和Swift语言基础 1、@synthesize和@dynamic分别有什么作用？ @property有两个对应的词，一个是 @synthesize，一个是 @dynam…   iOS2023年最新面试题（持续更新中）  0.7452023.02.13 22:21:35字数 14,715阅读 659 OC和Swift语言基础 1、@s">
<meta property="og:type" content="article">
<meta property="og:title" content="iOS面试题">
<meta property="og:url" content="https://www.nickxu.top/post/6db1ba4f.html">
<meta property="og:site_name" content="Peter の 博客">
<meta property="og:description" content="iOS2023年最新面试题（持续更新中）  Excerpt OC和Swift语言基础 1、@synthesize和@dynamic分别有什么作用？ @property有两个对应的词，一个是 @synthesize，一个是 @dynam…   iOS2023年最新面试题（持续更新中）  0.7452023.02.13 22:21:35字数 14,715阅读 659 OC和Swift语言基础 1、@s">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://www.nickxu.top/static/202202230023069.jpg">
<meta property="article:published_time" content="2023-06-07T00:59:38.000Z">
<meta property="article:modified_time" content="2023-06-07T01:03:13.337Z">
<meta property="article:author" content="Peter">
<meta property="article:tag" content="iOS">
<meta property="article:tag" content="面试">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://www.nickxu.top/static/202202230023069.jpg"><link rel="shortcut icon" href="/static/log3.png"><link rel="canonical" href="https://www.nickxu.top/post/6db1ba4f"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="/pluginsSrc/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="/pluginsSrc/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":500},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":5,"languages":{"author":"作者: Peter","link":"链接: ","source":"来源: Peter の 博客","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: '/pluginsSrc/flickr-justified-gallery/dist/fjGallery.min.js',
      css: '/pluginsSrc/flickr-justified-gallery/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'iOS面试题',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-06-07 09:03:13'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/static/my.css"><link rel="stylesheet" href="/css/cat.css"><div id="myscoll"></div><meta name="generator" content="Hexo 6.2.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/static/header.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">2</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">3</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-book"></i><span> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/todo/"><i class="fa-fw fas fa-list-alt"></i><span> ToDo</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-coffee"></i><span> 更多</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/contact/"><i class="fa-fw fas fa-comments"></i><span> 留言板</span></a></li><li><a class="site-page child" href="/bookmarks/"><i class="fa-fw fas fa-bookmark"></i><span> 网址收藏</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/static/202202230023069.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Peter の 博客</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-book"></i><span> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/todo/"><i class="fa-fw fas fa-list-alt"></i><span> ToDo</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-coffee"></i><span> 更多</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/contact/"><i class="fa-fw fas fa-comments"></i><span> 留言板</span></a></li><li><a class="site-page child" href="/bookmarks/"><i class="fa-fw fas fa-bookmark"></i><span> 网址收藏</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">iOS面试题</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-06-07T00:59:38.000Z" title="发表于 2023-06-07 08:59:38">2023-06-07</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-06-07T01:03:13.337Z" title="更新于 2023-06-07 09:03:13">2023-06-07</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E9%9D%A2%E8%AF%95/">面试</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">17.8k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>66分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="iOS面试题"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="iOS2023年最新面试题（持续更新中）">iOS2023年最新面试题（持续更新中）</h1>
<blockquote>
<h2 id="Excerpt">Excerpt</h2>
<p>OC和Swift语言基础 1、@synthesize和@dynamic分别有什么作用？ @property有两个对应的词，一个是 @synthesize，一个是 @dynam…</p>
</blockquote>
<hr>
<h2 id="iOS2023年最新面试题（持续更新中）-2">iOS2023年最新面试题（持续更新中）</h2>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/u/800d546a2063"><img src="https://upload.jianshu.io/users/upload_avatars/2752635/ff710ec69f98.jpg?imageMogr2/auto-orient/strip%7CimageView2/1/w/96/h/96/format/webp" alt=""></a></p>
<p>0.7452023.02.13 22:21:35字数 14,715阅读 659</p>
<h3 id="OC和Swift语言基础">OC和Swift语言基础</h3>
<h4 id="1、-synthesize和-dynamic分别有什么作用？">1、@synthesize和@dynamic分别有什么作用？</h4>
<ul>
<li>@property有两个对应的词，一个是 @synthesize，一个是 @dynamic。如果 @synthesize和 @dynamic都没写，那么默认的就是@syntheszie var = _var;</li>
<li>@synthesize 的语义是如果你没有手动实现 setter 方法和 getter 方法，那么编译器会自动为你加上这两个方法。</li>
<li>@dynamic 告诉编译器：属性的 setter 与 getter 方法由用户自己实现，不自动生成。（当然对于 readonly 的属性只需提供 getter 即可）。假如一个属性被声明为 @dynamic var，然后你没有提供 @setter方法和 @getter 方法，编译的时候没问题，但是当程序运行到 instance.var = someVar，由于缺 setter 方法会导致程序崩溃；或者当运行到 someVar = var 时，由于缺 getter 方法同样会导致崩溃。编译时没问题，运行时才执行相应的方法，这就是所谓的动态绑定。</li>
</ul>
<h4 id="2、Swift和OC的区别？">2、Swift和OC的区别？</h4>
<ul>
<li>快速、现代、安全、互动，而且明显优于 Objective-C 语言</li>
<li>可以使用现有的 Cocoa 和 Cocoa Touch 框架</li>
<li>Swift 取消了 Objective C 的指针/地址等不安全访问的使用</li>
<li>提供了类似 Java 的名字空间(namespace)、泛型 - (generic)var、运算对象重载（operator overloading</li>
<li>Swift 被简单的形容为 “没有 C 的 Objective-C”（Objective-C without the C）</li>
<li>为苹果开发工具带来了Xcode Playgrounds功能，该功能提供强大的互动效果，能让Swift 源代码在撰写过程中实时显示出其运行结果；</li>
<li>基于C和Objective-C，而却没有C的一些兼容约束；</li>
<li>采用了安全的编程模式；</li>
<li>舍弃 Objective C 早期应用 Smalltalk 的语法，保留了Smalltalk的动态特性，全面改为句点表示法</li>
<li>类型严谨 对比oc的动态绑定</li>
</ul>
<h4 id="3、Swift中struct和class的区别？">3、Swift中struct和class的区别？</h4>
<ul>
<li><strong>struct</strong><br>
值类型，深拷贝，分配在栈上<br>
没有析构函数<br>
不能继承<br>
不会发生内存泄漏，线程安全<br>
实例方法修改属性时用mutating标记</li>
<li><strong>class</strong><br>
引用类型，浅拷贝，分配在堆上<br>
有析构函数<br>
可以单继承<br>
可以有单例<br>
无需mutating标记<br>
每一个成员变量都必须初始化</li>
</ul>
<ol>
<li>class 直接对属性赋值，也就是没有通过构造器赋值的，在创建对象对属性赋值只能是如下方式:</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class ClassPerson  &#123;</span><br><span class="line">    var name: String?</span><br><span class="line">    var age: Int?</span><br><span class="line">&#125;</span><br><span class="line">struct StructPerson &#123;</span><br><span class="line">    var name: String?</span><br><span class="line">    var age: Int?</span><br><span class="line">&#125;</span><br><span class="line">let p1 = ClassPerson()</span><br><span class="line">p1.name = &quot;123&quot;</span><br><span class="line">print(p1.name)</span><br><span class="line"></span><br><span class="line">var p2 = StructPerson(name: &quot;abc&quot;, age: 20)</span><br><span class="line">p2.name = &quot;123&quot;</span><br><span class="line">print(p2.name)</span><br></pre></td></tr></table></figure>
<p>原因： class 在初始化时不能直接把 property 放在默认的 constructor 的参数里，而是<strong>需要自己创建一个带参数的constructor</strong></p>
<ol start="2">
<li>struct是值类型, class是引用类型</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class ClassPerson  &#123;</span><br><span class="line">    var name: String</span><br><span class="line">    var age: Int</span><br><span class="line">    init(name:String,age:Int) &#123;</span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">struct StructPerson &#123;</span><br><span class="line">    var name: String</span><br><span class="line">    var age: Int</span><br><span class="line">&#125;</span><br><span class="line">let p1 = ClassPerson(name: &quot;abc&quot;, age: 10)</span><br><span class="line">let secondP1 = p1</span><br><span class="line">secondP1.name = &quot;123&quot;</span><br><span class="line">print(p1.name)</span><br><span class="line"></span><br><span class="line">let p2 = StructPerson(name: &quot;abc&quot;, age: 20)</span><br><span class="line">var secondP2 = p2</span><br><span class="line">secondP2.name = &quot;123&quot;</span><br><span class="line">print(p2.name)</span><br></pre></td></tr></table></figure>
<p><img src="https://upload-images.jianshu.io/upload_images/2752635-2743acc26e5d8a63.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/438/format/webp" alt=""></p>
<p>截屏2023-02-14 下午8.52.05.png</p>
<ol start="3">
<li>在struct的成员函数中修改自己本身的值，应该在函数签名上加上mutating关键字,而class则没有此限制</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class ClassPerson  &#123;</span><br><span class="line">    var name: String</span><br><span class="line">    var age: Int</span><br><span class="line">    init(name:String,age:Int) &#123;</span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">   &#125;</span><br><span class="line">   func changeName()&#123;</span><br><span class="line">        self.name = self.name + &quot;name&quot;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">struct StructPerson &#123;</span><br><span class="line">    var name: String</span><br><span class="line">    var age: Int</span><br><span class="line">    mutating func changeName()&#123;</span><br><span class="line">        self.name = self.name + &quot;name&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let p1 = ClassPerson(name: &quot;abc&quot;, age: 10)</span><br><span class="line">print(p1.name)</span><br><span class="line">p1.changeName()</span><br><span class="line">print(p1.name)</span><br><span class="line">var p2 = StructPerson(name: &quot;abc&quot;, age: 20)</span><br><span class="line">print(p2.name)</span><br><span class="line">p2.changeName()</span><br><span class="line">print(p2.name)</span><br></pre></td></tr></table></figure>
<p><img src="https://upload-images.jianshu.io/upload_images/2752635-6f0b530099847e8b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/380/format/webp" alt=""></p>
<p>截屏2023-02-14 下午8.46.42.png</p>
<ol start="4">
<li>struct初始化为let的对象无法修改，修改会编译报错，而class没有此限制</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class ClassPerson  &#123;</span><br><span class="line">   var name: String?</span><br><span class="line">   var age: Int?</span><br><span class="line">   init(name:String,age:Int) &#123;</span><br><span class="line">     self.name = name</span><br><span class="line">     self.age = age</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">struct StructPerson &#123;</span><br><span class="line">   var name: String?</span><br><span class="line">   var age: Int?</span><br><span class="line">&#125;</span><br><span class="line">let p1 = ClassPerson(name: &quot;abc&quot;, age: 10)</span><br><span class="line">p1.name = &quot;123&quot;</span><br><span class="line">print(p1.name)</span><br><span class="line"></span><br><span class="line">let p2 = StructPerson(name: &quot;abc&quot;, age: 20)</span><br><span class="line">p2.name = &quot;123&quot;</span><br><span class="line">print(p2.name)</span><br></pre></td></tr></table></figure>
<p><img src="https://upload-images.jianshu.io/upload_images/2752635-afe879196a617de4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt=""></p>
<p>截屏2023-02-14 下午8.40.40.png</p>
<ol start="5">
<li>OC里面无法调用Swift里的struct，因为要在OC里调用Swift代码的话，对象需要继承自NSObject。</li>
<li>struct不能被序列化成NSData，不能归解档，class可以，因为归解档的类必须遵守NSCoding协议，而NSCoding只适用于继承自NSObject的类，struct不能遵守NSCoding协议。<br>
<strong>解决方案：<br>
定义一个protocol，包含两个方法：<br>
1.从结构体中得到一个NSDictionary对象<br>
2.使用一个NSDictionary对象实例化结构体<br>
NSDictionary可以使用NSKeyedArchiver进行序列化<br>
好处：所有遵守该协议的结构体都可以被序列化</strong></li>
</ol>
<h4 id="4、KVC实现原理？">4、KVC实现原理？</h4>
<p>KVC，键-值编码，使用字符串直接访问对象的属性。<br>
底层实现，当一个对象调用setValue方法时，方法内部会做以下操作：</p>
<ol>
<li>检查是否存在相应key的set方法，如果存在，就调用set方法</li>
<li>如果set方法不存在，就会查找与key相同名称并且带下划线的成员属性，如果有，则直接给成员属性赋值</li>
<li>如果没有找到_key，就会查找相同名称的属性key，如果有就直接赋值</li>
<li>如果还没找到，则调用<code>valueForUndefinedKey：</code>和<code>setValue：forUndefinedKey：</code>方法</li>
</ol>
<h4 id="5、KVO的实现原理？">5、KVO的实现原理？</h4>
<p><img src="https://upload-images.jianshu.io/upload_images/2752635-f60db70b7825c0a5.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt=""></p>
<p>kvo原理.jpg</p>
<ol>
<li>当给A类添加KVO的时候，runtime动态的生成了一个子类NSKVONotifying_A，让A类的isa指针指向NSKVONotifying_A类，重写class方法，隐藏对象真实类信息</li>
<li>重写监听属性的setter方法，在setter方法内部调用了Foundation 的 <code>_NSSetObjectValueAndNotify</code>函数</li>
<li>_NSSetObjectValueAndNotify函数内部<br>
a) 首先会调用 <code>willChangeValueForKey</code><br>
b) 然后给属性赋值<br>
c) 最后调用<code>didChangeValueForKey</code><br>
d) 最后调用 observer 的<code>observeValueForKeyPath</code>去告诉监听器属性值发生了改变 .</li>
<li>重写了dealloc做一些 KVO 内存释放</li>
</ol>
<h4 id="6、如何手动触发KVO方法？">6、如何手动触发KVO方法？</h4>
<ul>
<li>手动调用<code>willChangeValueForKey</code>和<code>didChangeValueForKey</code>方法</li>
<li>键值观察通知依赖于 NSObject 的两个方法: <code>willChangeValueForKey:</code>和 <code>didChangeValueForKey:</code>。在一个被观察属性发生改变之前， <code>willChangeValueForKey:</code>一定会被调用，这就会记录旧的值。而当改变发生后， <code>didChangeValueForKey :</code>会被调用，继而 <code>observeValueForKey:ofObject:change:context:</code>也会被调用。</li>
</ul>
<h4 id="7、为什么Block用copy关键字？">7、为什么Block用copy关键字？</h4>
<ul>
<li>Block在没有使用外部变量时，内存存在全局区，然而，当Block在使用外部变量的时候，内存是存在于栈区，当Block copy之后，是存在堆区的。存在于栈区的特点是对象随时有可能被销毁，一旦销毁在调用的时候，就会造成系统的崩溃。所以Block要用copy关键字。</li>
</ul>
<h4 id="8、-weak和assign的区别，什么场景下使用，代理为什么使用weak？">8、 weak和assign的区别，什么场景下使用，代理为什么使用weak？</h4>
<ul>
<li>weak是弱指针， 在对象被销毁的时候会把weak修饰的属性置为空，避免造成野指针，只能修饰对象类型。</li>
<li>assign对象被释放的时候不会指向nil，对象被释放了还是指向原来的地址。调用的话容易产生野指针。assign可以修对象和基本数据类型。</li>
<li>代理要使用weak，weak可以说是非持有关系，对象释放了就指向nil，什么时候释放是由外部来控制，可以用assign但是用assign的时需要对象被释放的时候，把delegate指向nil。</li>
</ul>
<h4 id="9、load和initialize的区别">9、load和initialize的区别</h4>
<ul>
<li>load方法的本质：直接执行函数指针，其实就是直接执行函数指针，不会执行消息发送objc_msgSend那一套流程。子类、分类的load方法不会覆盖父类的load方法。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">static void schedule_class_load(class_t *cls)</span><br><span class="line">&#123;</span><br><span class="line">    assert(isRealized(cls));  // _read_images should realize</span><br><span class="line">    if (cls-&gt;data-&gt;flags &amp; RW_LOADED) return;</span><br><span class="line">    //确保先将父类添加到全局列表里 （loadable_class）</span><br><span class="line">    class_t *supercls = getSuperclass(cls);</span><br><span class="line">    if (supercls) schedule_class_load(supercls);</span><br><span class="line">    //再将当前类添加到全局列表里 （loadable_class）</span><br><span class="line">    add_class_to_loadable_list((Class)cls);</span><br><span class="line">    changeInfo(cls, RW_LOADED, 0); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// Call all +loads for the detached list.</span><br><span class="line">    for (i = 0; i &lt; used; i++) &#123;</span><br><span class="line">        Class cls = classes[i].cls;</span><br><span class="line">        IMP load_method = classes[i].method;</span><br><span class="line">        if (!cls) continue; </span><br><span class="line">        if (PrintLoading) &#123;</span><br><span class="line">            _objc_inform(&quot;LOAD: +[%s load]\n&quot;, _class_getName(cls));</span><br><span class="line">        &#125;</span><br><span class="line">        (*load_method) ((id) cls, SEL_load);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>场景1 ：子类、父类、分类都实现load方法，调用情况<br>
答：SuperClass-&gt;SubClass-&gt;CategoryClass</p>
</li>
<li>
<p>场景2 ：子类、父类、分类中子类不实现load方法，调用情况<br>
答：SuperClass-&gt;CategoryClass</p>
</li>
<li>
<p>场景3 ：子类、父类、分类1、分类2都实现load方法，调用情况<br>
答：SuperClass-&gt;SubClass-&gt;Category1Class-&gt;Category2Class</p>
</li>
<li>
<p>initialize方法的本质<br>
在类、或者子类，接收到第一条消息之前被执行（如初始化）<br>
initialize方法最终通过objc_msgSend来执行<br>
initialize方法在main函数之后调用<br>
如果一直没有使用类，则initialize方法不会被调用<br>
如果子类没有实现initialize方法，则会调用父类的initialize方法。</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">__private_extern__ void _class_initialize(Class cls)</span><br><span class="line">&#123;</span><br><span class="line">    Class supercls;</span><br><span class="line">    BOOL reallyInitialize = NO;</span><br><span class="line"></span><br><span class="line">    // Get the real class from the metaclass. The superclass chain </span><br><span class="line">    // hangs off the real class only.</span><br><span class="line">    cls = _class_getNonMetaClass(cls);</span><br><span class="line"></span><br><span class="line">    // Make sure super is done initializing BEFORE beginning to initialize cls.</span><br><span class="line">    // See note about deadlock above.</span><br><span class="line">    supercls = _class_getSuperclass(cls);</span><br><span class="line">    if (supercls  &amp;&amp;  !_class_isInitialized(supercls)) &#123;</span><br><span class="line">        _class_initialize(supercls);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // Try to atomically set CLS_INITIALIZING.</span><br><span class="line">    monitor_enter(&amp;classInitLock);</span><br><span class="line">    if (!_class_isInitialized(cls) &amp;&amp; !_class_isInitializing(cls)) &#123;</span><br><span class="line">        _class_setInitializing(cls);</span><br><span class="line">        reallyInitialize = YES;</span><br><span class="line">    &#125;</span><br><span class="line">    monitor_exit(&amp;classInitLock);</span><br><span class="line">    </span><br><span class="line">    if (reallyInitialize) &#123;</span><br><span class="line">        // We successfully set the CLS_INITIALIZING bit. Initialize the class.</span><br><span class="line">        </span><br><span class="line">        // Record that we&#x27;re initializing this class so we can message it.</span><br><span class="line">        _setThisThreadIsInitializingClass(cls);</span><br><span class="line">        </span><br><span class="line">        // Send the +initialize message.</span><br><span class="line">        // Note that +initialize is sent to the superclass (again) if </span><br><span class="line">        // this class doesn&#x27;t implement +initialize. 2157218</span><br><span class="line">        if (PrintInitializing) &#123;</span><br><span class="line">            _objc_inform(&quot;INITIALIZE: calling +[%s initialize]&quot;,</span><br><span class="line">                         _class_getName(cls));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ((void(*)(Class, SEL))objc_msgSend)(cls, SEL_initialize);</span><br><span class="line"></span><br><span class="line">        if (PrintInitializing) &#123;</span><br><span class="line">            _objc_inform(&quot;INITIALIZE: finished +[%s initialize]&quot;,</span><br><span class="line">                         _class_getName(cls));</span><br><span class="line">        &#125;        </span><br><span class="line">        </span><br><span class="line">        // Done initializing. </span><br><span class="line">        ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>优先执行父类的initialize方法；通过_class_getSupercass取出父类，递归调用父类的initialize方法；initialize方法最终通过objc_msgSend来执行的。</p>
<ul>
<li>场景1 ：子类、父类都实现initialize方法，调用情况<br>
答：SuperClass-&gt;SubClass</li>
<li>场景2 ：子类、父类中子类不实现initialize方法，调用情况<br>
答：SuperClass-&gt;SuperClass（子类未实现，则会调用父类的initialize，导致父类调用多次）</li>
<li>场景3：子类、父类、子类分类都实现initialize方法，调用情况<br>
答：SuperClass-&gt;CategoryClass（category中initialize方法覆盖其本类）</li>
<li>场景4：子类、父类、父类分类1、父类分类2都实现initialize方法，调用情况<br>
答：CategoryClass-&gt;SubClass（category中initialize方法根据Compile Sources排序执行最后一个）</li>
</ul>
<p><strong>执行顺序</strong><br>
<strong>load</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/2752635-5bb81894c906ac50.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/996/format/webp" alt=""></p>
<p>load.png</p>
<p>app启动自动加载所有load方法，load方法会在程序运行前加载一次。<br>
1.先调用类的load，再调用分类的load<br>
2.先编译的类，优先调用load，调用子类的load之前，会先调用父类的load<br>
3.先编译的分类，优先调用load，顺序和Compile Sources中顺序一致</p>
<p><strong>initialize</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/2752635-dceb1a8122903d4e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/943/format/webp" alt=""></p>
<p>initialize.png</p>
<p>initialize方法会在类或者子类在 第一次使用的时候调用，当有分类的时候会调用多次，如Son *s = [[Son alloc]init];<br>
1.父类先于子类执行；（同load方法）<br>
2.子类未实现，则会调用父类的initialize方法；<br>
3.分类实现了initialize方法，则会覆盖类中的initialize方法（同category）；<br>
4.存在多个分类，依赖Compile Sources中的顺序，执行最后一个分类的initialize方法（同category）；</p>
<p><strong>使用场景</strong><br>
1.load通常用于Method Swizzle；<br>
2.initialize可以用于初始化全局变量或静态变量；initialize方法可能被其分类中的initialize方法覆盖，导致无法调用。<br>
**注意：**load和initialize方法内部使用了锁，因此他们是线程安全的。使用时避免阻塞线程，不要使用线程锁。</p>
<h4 id="10、如何理解copy-on-write？">10、如何理解copy-on-write？</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">苹果建议当复制大的值类型数据的时候，使用写时复制技术，那什么是写时复制呢？我们现在看一段代码：</span><br><span class="line"></span><br><span class="line">值类型(比如:struct),在复制时,复制对象与原对象实际上在内存中指向同一个对象,当且仅当修改复制的对象时,才会在内存中创建一个新的对象</span><br><span class="line">为了提升性能，Struct, String、Array、Dictionary、Set采取了Copy On Write的技术</span><br><span class="line"></span><br><span class="line">比如仅当有“写”操作时，才会真正执行拷贝操作</span><br><span class="line"></span><br><span class="line">对于标准库值类型的赋值操作，Swift 能确保最佳性能，所有没必要为了保证最佳性能来避免赋值</span><br><span class="line">var array1: [Int] = [0, 1, 2, 3]</span><br><span class="line">var array2 = array1</span><br><span class="line"></span><br><span class="line">print(address: array1) //0x600000078de0</span><br><span class="line">print(address: array2) //0x600000078de0</span><br><span class="line"></span><br><span class="line">array2.append(4)</span><br><span class="line"></span><br><span class="line">print(address: array2) //0x6000000aa100</span><br><span class="line"></span><br><span class="line">我们看到当array2的值没有发生变化的时候，array1和array2指向同一个地址，但是当array2的发生变化时，array2指向地址也变了，很奇怪是吧。</span><br></pre></td></tr></table></figure>
<h3 id="UI">UI</h3>
<h4 id="1、UIView和CALayer的区别和联系？">1、UIView和CALayer的区别和联系？</h4>
<ul>
<li>UIView 继承 UIResponder，而 UIResponder 是响应者对象，可以对iOS 中的事件响应及传递，CALayer 没有继承自 UIResponder，所以 CALayer 不具备响应处理事件的能力。CALayer 是 QuartzCore 中的类，是一个比较底层的用来绘制内容的类，用来绘制UI</li>
<li>UIView 对 CALayer 封装属性，对 UIView 设置 frame、center、bounds 等位置信息时，其实都是UIView 对 CALayer 进一层封装，使得我们可以很方便地设置控件的位置；例如圆角、阴影等属性， UIView 就没有进一步封装，所以我们还是需要去设置 Layer 的属性来实现功能。</li>
<li>UIView 是 CALayer 的代理，UIView 持有一个 CALayer 的属性，并且是该属性的代理，用来提供一些 CALayer 行的数据，例如动画和绘制。</li>
</ul>
<h4 id="2、谈谈对UIResponder的理解？">2、谈谈对UIResponder的理解？</h4>
<p>UIResponder类是专门用来响应用户的操作处理各种事件的，包括触摸事件(Touch Events)、运动事件(Motion Events)、远程控制事件(Remote Control Events)。我们知道UIApplication、UIView、UIViewController这几个类是直接继承自UIResponder，所以这些类都可以响应事件。当然我们自定义的继承自UIView的View以及自定义的继承自UIViewController的控制器都可以响应事件。</p>
<ul>
<li>响应过程<br>
iOS系统检测到手指触摸(Touch)操作时会将其打包成一个UIEvent对象，并放入当前活动Application的事件队列，单例的UIApplication会从事件队列中取出触摸事件并传递给单例的UIWindow来处理，UIWindow对象首先会使用<code>hitTest:withEvent:</code>方法寻找此次Touch操作初始点所在的视图(View)，即需要将触摸事件传递给其处理的视图(最合适来处理的控件)，这个过程称之为hit-test view。<br>
<strong>那么什么是最适合来处理事件的控件?</strong><br>
1.自己能响应触摸事件<br>
2.触摸点在自己身上<br>
3.从后往前递归遍历子控件, 重复上两步<br>
4.如果没有符合条件的子控件, 那么就自己最合适处理</li>
</ul>
<ol>
<li><code>hitTest:withEvent:</code>事件传递给控件的时候， 就会调用该方法，去寻找最合适的view并返回看可以响应的view</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event &#123;</span><br><span class="line">    // 1.如果控件不允许与用用户交互,那么返回nil</span><br><span class="line">    if (self.userInteractionEnabled == NO || self.alpha &lt;= 0.01 || self.hidden == YES)&#123;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    // 2\. 如果点击的点在不在当前控件中,返回nil</span><br><span class="line">    if (![self pointInside:point withEvent:event])&#123;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    // 3.从后往前遍历每一个子控件</span><br><span class="line">    for(int i = (int)self.subviews.count - 1 ; i &gt;= 0 ;i--)&#123;</span><br><span class="line">        // 3.1获取一个子控件</span><br><span class="line">        UIView *childView = self.subviews[i];</span><br><span class="line">        // 3.2当前触摸点的坐标转换为相对于子控件触摸点的坐标</span><br><span class="line">        CGPoint childP = [self convertPoint:point toView:childView];</span><br><span class="line">        // 3.3判断是否在在子控件中找到了更合适的子控件(递归循环)</span><br><span class="line">        UIView *fitView = [childView hitTest:childP withEvent:event];</span><br><span class="line">        // 3.4如果找到了就返回</span><br><span class="line">        if (fitView) &#123;</span><br><span class="line">            return fitView;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 4.没找到,表示没有比自己更合适的view,返回自己</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li><code>pointInside:withEvent:</code>该方法判断触摸点是否在控件身上，是则返回YES，否则返回NO，point参数必须是方法调用者的坐标系.</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)pointInside:(CGPoint)point withEvent:(UIEvent *)event &#123;</span><br><span class="line">    return NO;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="3、loadView的作用？">3、loadView的作用？</h4>
<p>loadView方法会在每次访问UIViewController的view(比如controller.view、self.view)而且view为nil时会被调用，此方法主要用来负责创建UIViewController的view(重写loadView方法，并且不需要调用[super loadView])<br>
[super loadView]执行流程：</p>
<ul>
<li>它会先去查找与UIViewController相关联的xib文件，通过加载xib文件来创建UIViewController的view，如果在初始化UIViewController指定了xib文件名，就会根据传入的xib文件名加载对应的xib文件，如果没有明显地传xib文件名，就会加载跟UIViewController同名的xib文件</li>
<li>如果没有找到相关联的xib文件，就会创建一个空白的UIView，然后赋值给UIViewController的view属性</li>
<li>综上，在需要自定义UIViewController的view时，可以通过重写loadView方法且不需要调用[super loadView]方法。</li>
</ul>
<h3 id="内存管理">内存管理</h3>
<h3 id="RunLoop">RunLoop</h3>
<h4 id="1、RunLoop-的本质是什么？">1、RunLoop 的本质是什么？</h4>
<p>“Run loops are part of thefundamental infrastructure associated withthreads. A run loop is an event processing loopthat you use to schedule work and coordinatethe receipt of incoming events. The purpose ofa runloop is to keep your thread busy whenthere is work to do and put your thread tosleep when there is none.”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">typedef struct CF_BRIDGED_MUTABLE_TYPE(id) __CFRunLoop * CFRunLoopRef;</span><br><span class="line"></span><br><span class="line">struct __CFRunLoop &#123;</span><br><span class="line">    CFRuntimeBase _base;</span><br><span class="line">    pthread_mutex_t _lock;          /* locked for accessing mode list */</span><br><span class="line">    //mach_port</span><br><span class="line">    __CFPort _wakeUpPort;           // used for CFRunLoopWakeUp </span><br><span class="line">    Boolean _unused;</span><br><span class="line">    volatile _per_run_data *_perRunData;              // reset for runs of the run loop</span><br><span class="line">    pthread_t _pthread;</span><br><span class="line">    uint32_t _winthread;</span><br><span class="line">    CFMutableSetRef _commonModes;</span><br><span class="line">    CFMutableSetRef _commonModeItems;</span><br><span class="line">    CFRunLoopModeRef _currentMode;</span><br><span class="line">    CFMutableSetRef _modes;</span><br><span class="line">    struct _block_item *_blocks_head;</span><br><span class="line">    struct _block_item *_blocks_tail;</span><br><span class="line">    CFAbsoluteTime _runTime;</span><br><span class="line">    CFAbsoluteTime _sleepTime;</span><br><span class="line">    CFTypeRef _counterpart;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>1.NSRunLoop只是比CFRunLoop多了一层简单的OC封装，底层还是CFRunLoop，CFRunLoop本质是一个结构体，而NSRunLoop是一个NSObject对象。NSRunLoop存在于Foundation框架中，CFRunLoop是存在于CoreFoundation框架中的。NSRunLoop不是线程安全的，CFRunLoop时候线程安全的。</p>
<p>2.RunLoop是一个与线程相关的底层机制，用来接收事件和调度任务。runloop目的是让线程在有工作的时候保持忙碌，在没有工作的时候睡眠。</p>
<p>3.RunLoop是与线程相关的，它们的关系一一对应：一个线程只能对应一个RunLoop，即在某一时刻，一个线程只能运行在某一个RunLoop上。当运行一个应用程序的时候，系统会为应用程序的主线程创建一个RunLoop用来处理主线程上的事件，例如UI刷新和触屏事件。因此，开发者不需要为主线程显式地创建和运行一个RunLoop，而子线程需要显式地运行一个RunLoop，再将辅助线程放到RunLoop中运行，否则线程不会自动开启RunLoop。</p>
<h4 id="2、Runloop和线程是什么关系？">2、Runloop和线程是什么关系？</h4>
<p>线程和 RunLoop 之间是Key-value的对应关系，是保存在一个全局的 Dictionary 里，线程是key，RunLoop是value，而且是懒加载的。</p>
<h4 id="3、Runloop的底层数据结构是什么样的？有几种运行模式（mode）？每个运行模式下面的CFRunloopMode是哪些？他们分别是什么职责？">3、Runloop的底层数据结构是什么样的？有几种运行模式（mode）？每个运行模式下面的CFRunloopMode是哪些？他们分别是什么职责？</h4>
<ul>
<li><strong>Mode</strong>，运行模式</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">struct __CFRunLoopMode &#123;</span><br><span class="line">    CFRuntimeBase _base;</span><br><span class="line">    pthread_mutex_t _lock;  /* must have the run loop locked before locking this */</span><br><span class="line">    CFStringRef _name;     // mode名称</span><br><span class="line">    Boolean _stopped;      // mode是否被终止</span><br><span class="line">    char _padding[3];</span><br><span class="line">    // 几种事件，下面这四个字段，在苹果官方文档里面称为Item</span><br><span class="line">    // RunLoop中有个commomitems字段，里面就是保存的下面这些内容</span><br><span class="line">    CFMutableSetRef _sources0;</span><br><span class="line">    CFMutableSetRef _sources1;</span><br><span class="line">    CFMutableArrayRef _observers;</span><br><span class="line">    CFMutableArrayRef _timers;</span><br><span class="line">    CFMutableDictionaryRef _portToV1SourceMap;   //字典  key是mach_port_t，value是CFRunLoopSourceRef</span><br><span class="line">    __CFPortSet _portSet;    //保存所有需要监听的port，比如_wakeUpPort，_timerPort都保存在这个数组中</span><br><span class="line">    CFIndex _observerMask;</span><br><span class="line">#if USE_DISPATCH_SOURCE_FOR_TIMERS</span><br><span class="line">    dispatch_source_t _timerSource;</span><br><span class="line">    dispatch_queue_t _queue;</span><br><span class="line">    Boolean _timerFired; // set to true by the source when a timer has fired</span><br><span class="line">    Boolean _dispatchTimerArmed;</span><br><span class="line">#endif</span><br><span class="line">#if USE_MK_TIMER_TOO</span><br><span class="line">    mach_port_t _timerPort;</span><br><span class="line">    Boolean _mkTimerArmed;</span><br><span class="line">#endif</span><br><span class="line">#if DEPLOYMENT_TARGET_WINDOWS</span><br><span class="line">    DWORD _msgQMask;</span><br><span class="line">    void (*_msgPump)(void);</span><br><span class="line">#endif</span><br><span class="line">    uint64_t _timerSoftDeadline; /* TSR */</span><br><span class="line">    uint64_t _timerHardDeadline; /* TSR */</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ol>
<li>
<p>模式（Mode）指的是一个包括输入源（Inputsource）、定时器（Timer）、观察者（Observer）的模型对象。简单点来说，模式就是用来存储runloop需要响应的事件，这些事件包括许多输入源、定时器和观察者。</p>
</li>
<li>
<p>系统默认注册5个Mode:<br>
1.<strong>NSDefaultRunLoopMode：</strong> App的默认Mode,通常主线程是在这个Mode下运行<br>
2.**UITrackingRunLoopMode：**界面跟踪Mode,用于ScrollView`追踪触摸滑动，保证界面滑动时不受其他Mode影响。<br>
3.**NSRunLoopCommonModes：**并不是一个真的模式，它只是一个标记，如：被标记的 Timer可以在Default模式和UITracking下运行。<br>
4.**UIInitializationRunLoopMode：**私有的mode，App启动的时候的状态，加载出第一个页面后，就转成了Default，通常用不到<br>
5.**GSEventReceiveRunLoopMode：**系统的内部 Mode，通常用不到</p>
</li>
</ol>
<ul>
<li><strong>Source</strong>，输入源/事件源</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//CFRunLoop.h</span><br><span class="line">typedef struct __CFRunLoopSource *CFRunLoopSourceRef;</span><br><span class="line">//CFRunLoop.c</span><br><span class="line">struct __CFRunLoopSource&#123;</span><br><span class="line">    CFRuntimeBase _base;//</span><br><span class="line">    uint32_t _bits;</span><br><span class="line">    pthread_mutex_t lock;</span><br><span class="line">    CFIndex _order;  /*immutable*/</span><br><span class="line">    CFMutableBagRef _runLoops;</span><br><span class="line">    union&#123;</span><br><span class="line">        CFRunLoopSourceContext version0; /*immutable,except invalidation*/</span><br><span class="line">        CFRunLoopSourceContext1 version1; /*immutable,except invalidattion*/</span><br><span class="line">    &#125;_context;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>1.联合体的作用是共享存储空间，也就是说，version0和version1两个变量共享一段存储空间，一个__CFRunLoopSource结构体变量要么对应version0类型的事件源，要么对应version1类型的事件源。其中，version0和version1分别在源码中对应事件源Source0和Source1。</p>
<p>2.Source0对应需要手动触发的事件，对应官方文档Input Source中的Custom和performSelector:onThread事件源。</p>
<p>3.Source1表示基于端口触发的事件，对应官方文档Input Source中Port的事件源。</p>
<ul>
<li><strong>Timer</strong>，定时源</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">struct __CFRunLoopTimer &#123;</span><br><span class="line">    CFRuntimeBase _base;</span><br><span class="line">    uint16_t _bits;  //标记fire状态</span><br><span class="line">    pthread_mutex_t _lock;</span><br><span class="line">    CFRunLoopRef _runLoop;        //添加该timer的runloop</span><br><span class="line">    CFMutableSetRef _rlModes;     //存放所有 包含该timer的 mode的 modeName，意味着一个timer可能会在多个mode中存在</span><br><span class="line">    CFAbsoluteTime _nextFireDate;</span><br><span class="line">    CFTimeInterval _interval;     //理想时间间隔  /* immutable */</span><br><span class="line">    CFTimeInterval _tolerance;    //时间偏差      /* mutable */</span><br><span class="line">    uint64_t _fireTSR;          /* TSR units */</span><br><span class="line">    CFIndex _order;         /* immutable */</span><br><span class="line">    CFRunLoopTimerCallBack _callout;    /* immutable */</span><br><span class="line">    CFRunLoopTimerContext _context; /* immutable, except invalidation */</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>__CFRunLoopTimer是一个基于mk_timer实现的定时器，通过_callout回调实现定时执行任务。NSTimer其实是对CFRunLoopTimerRef的一个上层封装。</p>
<ul>
<li><strong>Observer</strong>，观察者</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">struct __CFRunLoopObserver &#123;</span><br><span class="line">    CFRuntimeBase _base;</span><br><span class="line">    pthread_mutex_t _lock;</span><br><span class="line">    CFRunLoopRef _runLoop;   //添加该Observer的RunLoop</span><br><span class="line">    CFIndex _rlCount;</span><br><span class="line">    CFOptionFlags _activities;      /* immutable */</span><br><span class="line">    CFIndex _order;         /* immutable */</span><br><span class="line">    CFRunLoopObserverCallBack _callout;     //设置回调函数，回调指针  /* immutable */</span><br><span class="line">    CFRunLoopObserverContext _context;  /* immutable, except invalidation */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>CFRunLoopObserver是观察者，可以观察RunLoop的各种状态，每个 Observer 都包含了一个回调（也就是上面的CFRunLoopObserverCallBack函数指针），当 RunLoop 的状态发生变化时，观察者就能通过回调接受到这个变化。</p>
<h4 id="4、Runloop-的监听状态有哪几种？">4、Runloop 的监听状态有哪几种？</h4>
<p>Entry-&gt;BeforeTimers-&gt;BeforeSources-&gt;BeforeWaiting(休眠)-&gt;AfterWaiting(唤醒)-&gt;Exit-&gt;AllActivities</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/* Run Loop Observer Activities */</span><br><span class="line">typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) &#123;</span><br><span class="line">    kCFRunLoopEntry = (1UL &lt;&lt; 0),                 // 即将进入Loop</span><br><span class="line">    kCFRunLoopBeforeTimers = (1UL &lt;&lt; 1),          // 即将处理Timer</span><br><span class="line">    kCFRunLoopBeforeSources = (1UL &lt;&lt; 2),         // 即将处理Source</span><br><span class="line">    kCFRunLoopBeforeWaiting = (1UL &lt;&lt; 5),         // 即将进入休眠</span><br><span class="line">    kCFRunLoopAfterWaiting = (1UL &lt;&lt; 6),          // 刚从休眠中唤醒</span><br><span class="line">    kCFRunLoopExit = (1UL &lt;&lt; 7),                  // 即将退出Loop</span><br><span class="line">    kCFRunLoopAllActivities = 0x0FFFFFFFU         // 所有状态</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>1）kCFRunLoopEntry表示刚进入runloop的时候。<br>
2）kCFRunLoopBeforeTimers表示将要处理timer。<br>
3）kCFRunLoopBeforeSources表示将要处理Source。<br>
4）kCFRunLoopBeforeWaiting表示将要进入休眠状态。<br>
5）kCFRunLoopAfterWaiting表示将要从休眠状态进入唤醒状态。<br>
6）kCFRunLoopExit表示退出状态。<br>
7）kCFRunLoopAllActivities表示所有1）～6）中的状态。</p>
<h4 id="5、Runloop-的工作流程？">5、Runloop 的工作流程？</h4>
<p><img src="https://upload-images.jianshu.io/upload_images/2752635-727254256ae06203.png" alt=""></p>
<p>Runloop 的工作流程.png</p>
<p>内部逻辑：</p>
<ol>
<li>通知 Observer 已经进入了 RunLoop</li>
<li>通知 Observer 即将处理 Timer</li>
<li>通知 Observer 即将处理非基于端口的输入源（即将处理 Source0）</li>
<li>处理那些准备好的非基于端口的输入源（处理 Source0）</li>
<li>如果基于端口的输入源准备就绪并等待处理，请立刻处理该事件。转到第 9 步（处理 Source1）</li>
<li>通知 Observer 线程即将休眠</li>
<li>将线程置于休眠状态，直到发生以下事件之一</li>
</ol>
<ul>
<li>事件到达基于端口的输入源（port-based input sources）(也就是 Source0)</li>
<li>Timer 到时间执行</li>
<li>外部手动唤醒</li>
<li>为 RunLoop 设定的时间超时</li>
</ul>
<ol start="8">
<li>通知 Observer 线程刚被唤醒（还没处理事件）</li>
<li>处理待处理事件</li>
</ol>
<ul>
<li>如果是 Timer 事件，处理 Timer 并重新启动循环，跳到第 2 步</li>
<li>如果输入源被触发，处理该事件（文档上是 deliver the event）</li>
<li>如果 RunLoop 被手动唤醒但尚未超时，重新启动循环，跳到第 2 步</li>
</ul>
<h4 id="6、Runloop-有哪些应用？">6、Runloop 有哪些应用？</h4>
<p>滑动scrollview时候的mode切换，cell的图片下载 将多个耗时操作分开执行，在每次 RunLoop唤醒时去做一个耗时任务。</p>
<h4 id="7、Runloop的内核态和用户态？">7、Runloop的内核态和用户态？</h4>
<ul>
<li>用户态-&gt;内核态 没有消息需要处理时，休眠以避免资源占用；</li>
<li>内核态-&gt;用户态 有消息需要处理时，立刻被唤醒。</li>
</ul>
<h4 id="8、点击APP图标，从程序启动、运行、退出这个过程当中，系统都发生了什么？">8、点击APP图标，从程序启动、运行、退出这个过程当中，系统都发生了什么？</h4>
<ul>
<li>程序启动后，调用<code>main</code>函数后，会调用<code>UIApplicationmain</code>函数，此函数内部会启动主线程的RunLoop，经过一系列处理，最终主线程RunLoop处于休眠状态；</li>
<li>如果此时点击了屏幕，会产生一个mach_port，基于mach_port最终转成Source1，唤醒主线程，运行处理；</li>
<li>当把程序杀死后，RunLoop退出，并且发送通知给观察者。RunLoop退出后线程即刻销毁。</li>
</ul>
<h3 id="Runtime">Runtime</h3>
<h4 id="1、概念">1、概念</h4>
<ul>
<li>oc是一门动态语言，所谓动态语言就是在编译阶段无法确定调用的函数以及属性的类型，只有在运行阶段首次确定类型和调用的函数。</li>
<li>Runtime就是动态语言下核心的一个库，底层都会通过<code>objc_msgSend</code>来处理消息转发机制。也是因为拥有Runtime使得oc语言灵活性比较强，能够具有动态、动态绑定、动态解析的特性。</li>
</ul>
<ol>
<li><strong>objc_msgSend</strong></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/* Basic Messaging Primitives</span><br><span class="line">*</span><br><span class="line">* On some architectures, use objc_msgSend_stret for some struct return types.</span><br><span class="line">* On some architectures, use objc_msgSend_fpret for some float return types.</span><br><span class="line">* On some architectures, use objc_msgSend_fp2ret for some float return types.</span><br><span class="line">*</span><br><span class="line">* These functions must be cast to an appropriate function pointer type </span><br><span class="line">* before being called. </span><br><span class="line">*/</span><br></pre></td></tr></table></figure>
<p>这是官方的声明，这是个最基本的用于发送消息的函数。另外，这个函数并不能发送所有类型的消息，只能发送基本的消息。比如，在一些处理器上，我们必须使用<code>objc_msgSend_stret</code>来发送返回值类型为结构体的消息，使用<code>objc_msgSend_fpret</code>来发送返回值类型为浮点类型的消息，而又在一些处理器上，还得使用<code>objc_msgSend_fp2ret</code>来发送返回值类型为浮点类型的消息。要调用<code>objc_msgSend</code>函数，必须要将函数强制转换成合适的函数指针类型才能调用。<br>
从<code>objc_msgSend</code>函数的声明来看，它应该是不带返回值的，但是我们在使用中却可以强制转换类型，以便接收返回值。另外，它的参数列表是可以任意多个的，前提也是要强制函数指针类型。<br>
编译器会根据情况在<code>objc_msgSend</code>, <code>objc_msgSend_stret</code>, <code>objc_msgSendSuper</code>, 或 <code>objc_msgSendSuper_stret</code>四个方法中选择一个来调用。如果消息是传递给超类，那么会调用名字带有<code>”Super”</code>的函数；如果消息返回值是数据结构而不是简单值时，那么会调用名字带有<code>”stret”</code>的函数。</p>
<ol start="2">
<li><strong>id</strong></li>
</ol>
<p><code>objc_msgSend</code>第一个参数类型为id，它是一个指向objc_object结构体的指针：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line">typedef struct objc_object *id;</span><br><span class="line"></span><br><span class="line">struct objc_object &#123;</span><br><span class="line">private:</span><br><span class="line">    isa_t isa;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">    // ISA() assumes this is NOT a tagged pointer object</span><br><span class="line">    Class ISA();</span><br><span class="line"></span><br><span class="line">    // rawISA() assumes this is NOT a tagged pointer object or a non pointer ISA</span><br><span class="line">    Class rawISA();</span><br><span class="line"></span><br><span class="line">    // getIsa() allows this to be a tagged pointer object</span><br><span class="line">    Class getIsa();</span><br><span class="line">    </span><br><span class="line">    uintptr_t isaBits() const;</span><br><span class="line"></span><br><span class="line">    // initIsa() should be used to init the isa of new objects only.</span><br><span class="line">    // If this object already has an isa, use changeIsa() for correctness.</span><br><span class="line">    // initInstanceIsa(): objects with no custom RR/AWZ</span><br><span class="line">    // initClassIsa(): class objects</span><br><span class="line">    // initProtocolIsa(): protocol objects</span><br><span class="line">    // initIsa(): other objects</span><br><span class="line">    void initIsa(Class cls /*nonpointer=false*/);</span><br><span class="line">    void initClassIsa(Class cls /*nonpointer=maybe*/);</span><br><span class="line">    void initProtocolIsa(Class cls /*nonpointer=maybe*/);</span><br><span class="line">    void initInstanceIsa(Class cls, bool hasCxxDtor);</span><br><span class="line"></span><br><span class="line">    // changeIsa() should be used to change the isa of existing objects.</span><br><span class="line">    // If this is a new object, use initIsa() for performance.</span><br><span class="line">    Class changeIsa(Class newCls);</span><br><span class="line"></span><br><span class="line">    bool hasNonpointerIsa();</span><br><span class="line">    bool isTaggedPointer();</span><br><span class="line">    bool isBasicTaggedPointer();</span><br><span class="line">    bool isExtTaggedPointer();</span><br><span class="line">    bool isClass();</span><br><span class="line"></span><br><span class="line">    // object may have associated objects?</span><br><span class="line">    bool hasAssociatedObjects();</span><br><span class="line">    void setHasAssociatedObjects();</span><br><span class="line"></span><br><span class="line">    // object may be weakly referenced?</span><br><span class="line">    bool isWeaklyReferenced();</span><br><span class="line">    void setWeaklyReferenced_nolock();</span><br><span class="line"></span><br><span class="line">    // object may have -.cxx_destruct implementation?</span><br><span class="line">    bool hasCxxDtor();</span><br><span class="line"></span><br><span class="line">    // Optimized calls to retain/release methods</span><br><span class="line">    id retain();</span><br><span class="line">    void release();</span><br><span class="line">    id autorelease();</span><br><span class="line"></span><br><span class="line">    // Implementations of retain/release methods</span><br><span class="line">    id rootRetain();</span><br><span class="line">    bool rootRelease();</span><br><span class="line">    id rootAutorelease();</span><br><span class="line">    bool rootTryRetain();</span><br><span class="line">    bool rootReleaseShouldDealloc();</span><br><span class="line">    uintptr_t rootRetainCount();</span><br><span class="line"></span><br><span class="line">    // Implementation of dealloc methods</span><br><span class="line">    bool rootIsDeallocating();</span><br><span class="line">    void clearDeallocating();</span><br><span class="line">    void rootDealloc();</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    void initIsa(Class newCls, bool nonpointer, bool hasCxxDtor);</span><br><span class="line"></span><br><span class="line">    // Slow paths for inline control</span><br><span class="line">    id rootAutorelease2();</span><br><span class="line">    uintptr_t overrelease_error();</span><br><span class="line"></span><br><span class="line">#if SUPPORT_NONPOINTER_ISA</span><br><span class="line">    // Unified retain count manipulation for nonpointer isa</span><br><span class="line">    id rootRetain(bool tryRetain, bool handleOverflow);</span><br><span class="line">    bool rootRelease(bool performDealloc, bool handleUnderflow);</span><br><span class="line">    id rootRetain_overflow(bool tryRetain);</span><br><span class="line">    uintptr_t rootRelease_underflow(bool performDealloc);</span><br><span class="line"></span><br><span class="line">    void clearDeallocating_slow();</span><br><span class="line"></span><br><span class="line">    // Side table retain count overflow for nonpointer isa</span><br><span class="line">    void sidetable_lock();</span><br><span class="line">    void sidetable_unlock();</span><br><span class="line"></span><br><span class="line">    void sidetable_moveExtraRC_nolock(size_t extra_rc, bool isDeallocating, bool weaklyReferenced);</span><br><span class="line">    bool sidetable_addExtraRC_nolock(size_t delta_rc);</span><br><span class="line">    size_t sidetable_subExtraRC_nolock(size_t delta_rc);</span><br><span class="line">    size_t sidetable_getExtraRC_nolock();</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    // Side-table-only retain count</span><br><span class="line">    bool sidetable_isDeallocating();</span><br><span class="line">    void sidetable_clearDeallocating();</span><br><span class="line"></span><br><span class="line">    bool sidetable_isWeaklyReferenced();</span><br><span class="line">    void sidetable_setWeaklyReferenced_nolock();</span><br><span class="line"></span><br><span class="line">    id sidetable_retain();</span><br><span class="line">    id sidetable_retain_slow(SideTable&amp; table);</span><br><span class="line"></span><br><span class="line">    uintptr_t sidetable_release(bool performDealloc = true);</span><br><span class="line">    uintptr_t sidetable_release_slow(SideTable&amp; table, bool performDealloc = true);</span><br><span class="line"></span><br><span class="line">    bool sidetable_tryRetain();</span><br><span class="line"></span><br><span class="line">    uintptr_t sidetable_retainCount();</span><br><span class="line">#if DEBUG</span><br><span class="line">    bool sidetable_present();</span><br><span class="line">#endif</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>objc_object</code>结构体包含一个isa指针，根据isa指针就可以找到对象所属的类。<br>
注意:isa指针不总是指向实例对象所属的类，不能依靠它来确定类型，而是应该用class方法来确定实例对象的类。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">union isa_t &#123;</span><br><span class="line">    isa_t() &#123; &#125;</span><br><span class="line">    isa_t(uintptr_t value) : bits(value) &#123; &#125;</span><br><span class="line"></span><br><span class="line">    Class cls;</span><br><span class="line">    uintptr_t bits;</span><br><span class="line">#if defined(ISA_BITFIELD)</span><br><span class="line">    struct &#123;</span><br><span class="line">        ISA_BITFIELD;  // defined in isa.h</span><br><span class="line">    &#125;;</span><br><span class="line">#endif</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"># if __arm64__</span><br><span class="line">// ARM64 simulators have a larger address space, so use the ARM64e</span><br><span class="line">// scheme even when simulators build for ARM64-not-e.</span><br><span class="line">#   if __has_feature(ptrauth_calls) || TARGET_OS_SIMULATOR</span><br><span class="line">#     define ISA_MASK        0x007ffffffffffff8ULL</span><br><span class="line">#     define ISA_MAGIC_MASK  0x0000000000000001ULL</span><br><span class="line">#     define ISA_MAGIC_VALUE 0x0000000000000001ULL</span><br><span class="line">#     define ISA_HAS_CXX_DTOR_BIT 0</span><br><span class="line">#     define ISA_BITFIELD                                                      \</span><br><span class="line">        uintptr_t nonpointer        : 1;                                       \</span><br><span class="line">        uintptr_t has_assoc         : 1;                                       \</span><br><span class="line">        uintptr_t weakly_referenced : 1;                                       \</span><br><span class="line">        uintptr_t shiftcls_and_sig  : 52;                                      \</span><br><span class="line">        uintptr_t has_sidetable_rc  : 1;                                       \</span><br><span class="line">        uintptr_t extra_rc          : 8</span><br><span class="line">#     define ISA_HAS_INLINE_RC    1</span><br><span class="line">#     define RC_HAS_SIDETABLE_BIT 55</span><br><span class="line">#     define RC_ONE_BIT           (RC_HAS_SIDETABLE_BIT+1)</span><br><span class="line">#     define RC_ONE               (1ULL&lt;&lt;RC_ONE_BIT)</span><br><span class="line">#     define RC_HALF              (1ULL&lt;&lt;7)</span><br><span class="line">#   else</span><br><span class="line">#     define ISA_MASK        0x0000000ffffffff8ULL</span><br><span class="line">#     define ISA_MAGIC_MASK  0x000003f000000001ULL</span><br><span class="line">#     define ISA_MAGIC_VALUE 0x000001a000000001ULL</span><br><span class="line">#     define ISA_HAS_CXX_DTOR_BIT 1</span><br><span class="line">#     define ISA_BITFIELD                                                      \</span><br><span class="line">        uintptr_t nonpointer        : 1;                                       \</span><br><span class="line">        uintptr_t has_assoc         : 1;                                       \</span><br><span class="line">        uintptr_t has_cxx_dtor      : 1;                                       \</span><br><span class="line">        uintptr_t shiftcls          : 33; /*MACH_VM_MAX_ADDRESS 0x1000000000*/ \</span><br><span class="line">        uintptr_t magic             : 6;                                       \</span><br><span class="line">        uintptr_t weakly_referenced : 1;                                       \</span><br><span class="line">        uintptr_t unused            : 1;                                       \</span><br><span class="line">        uintptr_t has_sidetable_rc  : 1;                                       \</span><br><span class="line">        uintptr_t extra_rc          : 19</span><br><span class="line">#     define ISA_HAS_INLINE_RC    1</span><br><span class="line">#     define RC_HAS_SIDETABLE_BIT 44</span><br><span class="line">#     define RC_ONE_BIT           (RC_HAS_SIDETABLE_BIT+1)</span><br><span class="line">#     define RC_ONE               (1ULL&lt;&lt;RC_ONE_BIT)</span><br><span class="line">#     define RC_HALF              (1ULL&lt;&lt;18)</span><br><span class="line">#   endif</span><br></pre></td></tr></table></figure>
<p>所以在isa_t联合体中Class cls和uintptr_t bits是互斥的。<br>
由 typedef unsigned long uintptr_t; 所知，bits占据8字节，共64位，64位中存储的即ISA_BITFIELD宏定义中的内容。</p>
<p>uintptr_t nonpointer : 1; 是否对isa指针开启优化。0:纯isa指针 1:不只类对象地址，还包括了类信息，对象对引用计数等。<br>
uintptr_t has_assoc : 1; 关联对象标识位 0:没有 1:存在。<br>
uintptr_t has_cxx_dtor : 1; 是否有c++或objc的析构函数 如果有则需要调用析构逻辑，如果没有则可以更快释放对象。<br>
uintptr_t shiftcls : 33; 存储类指针的值，开启指针优化时，有33位用来存放类指针。<br>
uintptr_t magic : 6; 用于调试器判断当前对象是真的对象还是未初始化的空间。<br>
uintptr_t weakly_referenced : 1; 标志对象是否被指向或曾经指向一个ARC的弱变量，没有弱引用的对象可以更快的释放。<br>
uintptr_t deallocating : 1; 标志对象是否正在释放内存。<br>
uintptr_t has_sidetable_rc : 1; 当引用计数大于10时，则需要借助该变量存储进位。<br>
uintptr_t extra_rc : 19 表示该对象的引用计数减1，如果引用计数为10，则extra_rc为9，如果引用计数大于10，则需要借助has_sidetable_rc。</p>
<ol start="3">
<li>
<p><strong>SEL</strong><br>
SEL其实是一个指向objc_selector结构体的指针：<code>typedef struct objc_selector *SEL</code>;<br>
<code>objc_msgSend</code>函数第二个参数类型为SEL，它是<code>selector</code>在Objc中的表示类型（Swift中是Selector类）。<br>
其实它就是个映射到方法的C字符串，你可以用 Objc 编译器命令<code>@selector()</code>或者 Runtime 系统的<code>sel_registerName</code>函数来获得一个SEL类型的方法选择器。</p>
</li>
<li>
<p><strong>Class</strong></p>
</li>
</ol>
<p>Class其实是一个指向objc_class结构体的指针：<br>
<code>typedef struct objc_class *Class</code>;</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">struct objc_class : objc_object &#123;</span><br><span class="line">    // Class ISA;</span><br><span class="line">    Class superclass;</span><br><span class="line">    cache_t cache;             // formerly cache pointer and vtable</span><br><span class="line">    class_data_bits_t bits;    // class_rw_t * plus custom rr/alloc flags</span><br><span class="line">    </span><br><span class="line">    class_rw_t *data() const &#123;</span><br><span class="line">        return bits.data();</span><br><span class="line">    &#125;</span><br><span class="line">    void setData(class_rw_t *newData) &#123;</span><br><span class="line">        bits.setData(newData);</span><br><span class="line">    &#125;</span><br><span class="line">    const class_ro_t *safe_ro() const &#123;</span><br><span class="line">        return bits.safe_ro();</span><br><span class="line">    &#125;</span><br><span class="line">    .....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">struct class_data_bits_t &#123;</span><br><span class="line">    friend objc_class;</span><br><span class="line">    class_rw_t* data() const &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">    void setData(class_rw_t *newData)</span><br><span class="line">    &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    const class_ro_t *safe_ro() const &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">struct cache_t &#123;</span><br><span class="line">    explicit_atomic&lt;uintptr_t&gt; _bucketsAndMaybeMask;</span><br><span class="line">    // _bucketsAndMaybeMask is a buckets_t pointer in the top 28 bits</span><br><span class="line">    union &#123;</span><br><span class="line">        // Note: _flags on ARM64 needs to line up with the unused bits of</span><br><span class="line">        // _originalPreoptCache because we access some flags (specifically</span><br><span class="line">        // FAST_CACHE_HAS_DEFAULT_CORE and FAST_CACHE_HAS_DEFAULT_AWZ) on</span><br><span class="line">        // unrealized classes with the assumption that they will start out</span><br><span class="line">        // as 0.</span><br><span class="line">        struct &#123;</span><br><span class="line">#if CACHE_MASK_STORAGE == CACHE_MASK_STORAGE_OUTLINED &amp;&amp; !__LP64__</span><br><span class="line">            // Outlined cache mask storage, 32-bit, we have mask and occupied.</span><br><span class="line">            explicit_atomic&lt;mask_t&gt;    _mask;</span><br><span class="line">            uint16_t                   _occupied;</span><br><span class="line">#elif CACHE_MASK_STORAGE == CACHE_MASK_STORAGE_OUTLINED &amp;&amp; __LP64__</span><br><span class="line">            // Outlined cache mask storage, 64-bit, we have mask, occupied, flags.</span><br><span class="line">            explicit_atomic&lt;mask_t&gt;    _mask;</span><br><span class="line">            uint16_t                   _occupied;</span><br><span class="line">            uint16_t                   _flags;</span><br><span class="line">#   define CACHE_T_HAS_FLAGS 1</span><br><span class="line">#elif __LP64__</span><br><span class="line">            // Inline cache mask storage, 64-bit, we have occupied, flags, and</span><br><span class="line">            // empty space to line up flags with originalPreoptCache.</span><br><span class="line">            //</span><br><span class="line">            // Note: the assembly code for objc_release_xN knows about the</span><br><span class="line">            // location of _flags and the</span><br><span class="line">            // FAST_CACHE_HAS_CUSTOM_DEALLOC_INITIATION flag within. Any changes</span><br><span class="line">            // must be applied there as well.</span><br><span class="line">            uint32_t                   _unused;</span><br><span class="line">            uint16_t                   _occupied;</span><br><span class="line">            uint16_t                   _flags;</span><br><span class="line">#   define CACHE_T_HAS_FLAGS 1</span><br><span class="line">#else</span><br><span class="line">            // Inline cache mask storage, 32-bit, we have occupied, flags.</span><br><span class="line">            uint16_t                   _occupied;</span><br><span class="line">            uint16_t                   _flags;</span><br><span class="line">#   define CACHE_T_HAS_FLAGS 1</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">        &#125;;</span><br><span class="line">        explicit_atomic&lt;preopt_cache_t *&gt; _originalPreoptCache;</span><br><span class="line">    &#125;;</span><br><span class="line">    ...</span><br><span class="line">public:</span><br><span class="line">    // The following four fields are public for objcdt&#x27;s use only.</span><br><span class="line">    // objcdt reaches into fields while the process is suspended</span><br><span class="line">    // hence doesn&#x27;t care for locks and pesky little details like this</span><br><span class="line">    // and can safely use these.</span><br><span class="line">    unsigned capacity() const;</span><br><span class="line">    struct bucket_t *buckets() const;</span><br><span class="line">    Class cls() const;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">struct bucket_t &#123;</span><br><span class="line">private:</span><br><span class="line">    // IMP-first is better for arm64e ptrauth and no worse for arm64.</span><br><span class="line">    // SEL-first is better for armv7* and i386 and x86_64.</span><br><span class="line">#if __arm64__</span><br><span class="line">    explicit_atomic&lt;uintptr_t&gt; _imp;</span><br><span class="line">    explicit_atomic&lt;SEL&gt; _sel;</span><br><span class="line">#else</span><br><span class="line">    explicit_atomic&lt;SEL&gt; _sel;</span><br><span class="line">    explicit_atomic&lt;uintptr_t&gt; _imp;</span><br><span class="line">#endif</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">struct class_rw_t &#123;</span><br><span class="line">    ...</span><br><span class="line">    explicit_atomic&lt;uintptr_t&gt; ro_or_rw_ext;</span><br><span class="line">    ...</span><br><span class="line">private:</span><br><span class="line">    using ro_or_rw_ext_t = objc::PointerUnion&lt;const class_ro_t, class_rw_ext_t, PTRAUTH_STR(&quot;class_ro_t&quot;), PTRAUTH_STR(&quot;class_rw_ext_t&quot;)&gt;;</span><br><span class="line">    const ro_or_rw_ext_t get_ro_or_rwe() const &#123;</span><br><span class="line">        return ro_or_rw_ext_t&#123;ro_or_rw_ext&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 设置ro</span><br><span class="line">    const class_ro_t *ro() const &#123;</span><br><span class="line">        auto v = get_ro_or_rwe();</span><br><span class="line">        if (slowpath(v.is&lt;class_rw_ext_t *&gt;())) &#123;</span><br><span class="line">            return v.get&lt;class_rw_ext_t *&gt;()-&gt;ro;</span><br><span class="line">        &#125;</span><br><span class="line">        return v.get&lt;const class_ro_t *&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    void set_ro(const class_ro_t *ro) &#123;</span><br><span class="line">        auto v = get_ro_or_rwe();</span><br><span class="line">        if (v.is&lt;class_rw_ext_t *&gt;()) &#123;</span><br><span class="line">            v.get&lt;class_rw_ext_t *&gt;(&amp;ro_or_rw_ext)-&gt;ro = ro;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            set_ro_or_rwe(ro);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 获取相关信息</span><br><span class="line">    const method_array_t methods() const &#123;</span><br><span class="line">        auto v = get_ro_or_rwe();</span><br><span class="line">        if (v.is&lt;class_rw_ext_t *&gt;()) &#123;</span><br><span class="line">            return v.get&lt;class_rw_ext_t *&gt;()-&gt;methods;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return method_array_t&#123;v.get&lt;const class_ro_t *&gt;()-&gt;baseMethods()&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    const property_array_t properties() const &#123;</span><br><span class="line">        auto v = get_ro_or_rwe();</span><br><span class="line">        if (v.is&lt;class_rw_ext_t *&gt;()) &#123;</span><br><span class="line">            return v.get&lt;class_rw_ext_t *&gt;()-&gt;properties;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return property_array_t&#123;v.get&lt;const class_ro_t *&gt;()-&gt;baseProperties&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    const protocol_array_t protocols() const &#123;</span><br><span class="line">        auto v = get_ro_or_rwe();</span><br><span class="line">        if (v.is&lt;class_rw_ext_t *&gt;()) &#123;</span><br><span class="line">            return v.get&lt;class_rw_ext_t *&gt;()-&gt;protocols;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return protocol_array_t&#123;v.get&lt;const class_ro_t *&gt;()-&gt;baseProtocols&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">struct class_rw_ext_t &#123;</span><br><span class="line">    const class_ro_t *ro;</span><br><span class="line">    method_array_t methods;</span><br><span class="line">    property_array_t properties;</span><br><span class="line">    protocol_array_t protocols;</span><br><span class="line">    char *demangledName;</span><br><span class="line">    uint32_t version;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">struct class_ro_t &#123;</span><br><span class="line">    uint32_t flags;</span><br><span class="line">    uint32_t instanceStart;</span><br><span class="line">    uint32_t instanceSize;</span><br><span class="line">#ifdef __LP64__</span><br><span class="line">    uint32_t reserved;</span><br><span class="line">#endif</span><br><span class="line">    const uint8_t * ivarLayout;</span><br><span class="line">    const char * name;</span><br><span class="line">    method_list_t * baseMethodList;</span><br><span class="line">    protocol_list_t * baseProtocols;</span><br><span class="line">    const ivar_list_t * ivars;</span><br><span class="line">    const uint8_t * weakIvarLayout;</span><br><span class="line">    property_list_t *baseProperties;</span><br><span class="line">    // This field exists only when RO_HAS_SWIFT_INITIALIZER is set.</span><br><span class="line">    _objc_swiftMetadataInitializer __ptrauth_objc_method_list_imp _swiftMetadataInitializer_NEVER_USE[0];</span><br><span class="line">    _objc_swiftMetadataInitializer swiftMetadataInitializer() const &#123;</span><br><span class="line">        if (flags &amp; RO_HAS_SWIFT_INITIALIZER) &#123;</span><br><span class="line">            return _swiftMetadataInitializer_NEVER_USE[0];</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return nil;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    method_list_t *baseMethods() const &#123;</span><br><span class="line">        return baseMethodList;</span><br><span class="line">    &#125;</span><br><span class="line">    class_ro_t *duplicate() const &#123;</span><br><span class="line">        if (flags &amp; RO_HAS_SWIFT_INITIALIZER) &#123;</span><br><span class="line">            size_t size = sizeof(*this) + sizeof(_swiftMetadataInitializer_NEVER_USE[0]);</span><br><span class="line">            class_ro_t *ro = (class_ro_t *)memdup(this, size);</span><br><span class="line">            ro-&gt;_swiftMetadataInitializer_NEVER_USE[0] = this-&gt;_swiftMetadataInitializer_NEVER_USE[0];</span><br><span class="line">            return ro;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            size_t size = sizeof(*this);</span><br><span class="line">            class_ro_t *ro = (class_ro_t *)memdup(this, size);</span><br><span class="line">            return ro;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Class本身是运行时加载的，在运行时会被改变，所以本身Class就是属于脏内存。那么如果想要获取Class的干净内存，也就是编译时确定的数据结构包括方法列表、成员变量等的，该怎么办？这其实就是class_ro_t的作用。因为class_ro_t是只读，意味着class_ro_t是从mach-o读取类的数据之后，就不会被改变。那如果我们想在运行时修改类的信息，比如添加方法，比如加载category怎么办呢？那这时候就有一个与之对应的class_rw_t结构，class_rw_t是运行时存储类的信息，可读可写的，可以在运行时修改。说到这里，好像还漏掉一个结构class_rw_ext_t，这个东西又是干什么用的呢？存在的意义是什么？其实还是跟运行时有关。实际上在我们的app运行中，需要运行时修改的类是非少的，据统计平均大概就10%左右。那也就是说大部分只需要读取class_ro_t中的数据就够了，少部分才需要修改。因此才会有class_rw_ext_t这个扩展的结构体。class_rw_ext_t的作用是这样的：当我们需要修改类结构时，比如添加方法、加载category等时，class_rw_t回去开辟一个额外的空间rwe（class_rw_ext_t），用于存储新的方法和class_ro_t中的方法等信息。这样做的目的有一个好处就是，对于绝大部分类是不需要这个开辟class_rw_ext_t这个结构体，节省内存。</p>
<h4 id="2、Runtime-如何实现-weak-属性？">2、Runtime 如何实现 weak 属性？</h4>
<p>weak 此特质表明该属性定义了一种「非拥有关系」(nonowning relationship)。为这种属性设置新值时，设置方法既不持有新值（新指向的对象），也不释放旧值（原来指向的对象）。</p>
<p>Runtime 对注册的类，会进行内存布局，维护一个 hash 表，这是一个全局表，表中是用 weak 指向的对象内存地址作为 key，用所有指向该对象的weak指针表作为 value。当此对象的引用计数为 0 的时候会调用<code>dealloc</code>，假如该对象内存地址是 a，那么就会以 a 为 key，在这个 weak 表中搜索，找到所有以 a 为键的 weak 对象，从而设置为 nil。</p>
<p>Runtime 如何实现 weak 属性具体流程大致分为 3 步：</p>
<ol>
<li>初始化时：runtime 会调用<code>objc_initWeak()</code>函数，初始化一个新的 weak 指针指向对象的地址。</li>
<li>添加引用时：<code>objc_initWeak()</code>函数会调用<code>objc_storeWeak()</code>函数，<code>objc_storeWeak()</code>的作用是更新指针指向**（指针可能原来指向着其他对象，这时候需要将该 weak 指针与旧对象解除绑定，会调用到<code>weak_unregister_no_lock</code>）**，如果指针指向的新对象非空，则创建对应的弱引用表，将 weak 指针与新对象进行绑定，会调用到<code>weak_register_no_lock</code>。在这个过程中，为了防止多线程中竞争冲突，会有一些锁的操作。</li>
<li>释放时：调用<code>clearDeallocating()</code>函数，该函数首先根据对象地址获取所有 weak 指针地址的数组，然后遍历这个数组把其中的数据设为 nil，最后把这个 entry 从 weak 表中删除，最后清理对象的记录。</li>
</ol>
<h4 id="3、Runtime具体应用">3、Runtime具体应用</h4>
<ol>
<li>利用关联对象（AssociatedObject）给分类添加属性</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objc_setAssociatedObject(&lt;#id object#&gt;, &lt;#const void *key#&gt;, &lt;#id value#&gt;, &lt;#objc_AssociationPolicy policy#&gt;)</span><br></pre></td></tr></table></figure>
<ul>
<li>第一个参数: id object : 需要传入的是 : 对象的主分支</li>
<li>第二个参数: const void *key : 是一个 static 类型的关键字,这里根据开发者自身来定义就行</li>
<li>第三个参数: id value : 传入的是: 对象的子分支</li>
<li>第四个参数: objc_AssociationPolicy policy :是当前关联对象的类型 strong,weak,copy (枚举类型:开发者可以点进去看)</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objc_getAssociatedObject(&lt;#id object#&gt;, &lt;#const void *key#&gt;)就相对来说容易理解一点了</span><br></pre></td></tr></table></figure>
<ul>
<li>第一个参数 : id object : 需要传入的是 : 对象的主分支</li>
<li>第二个参数 : const void *key : 是一个 static 类型的关键字,这里根据开发者自身来定义就行</li>
</ul>
<ol start="2">
<li>遍历类的所有成员变量（修改textfield的占位文字颜色、字典转模型、自动归档解档）</li>
<li>交换方法实现，在方法上增加额外功能（交换系统的方法）</li>
</ol>
<ul>
<li>有这样一个场景，出于某些需求，我们需要跟踪记录APP中按钮的点击次数和频率等数据，怎么解决？当然通过继承按钮类或者通过类别实现是一个办法，但是带来其他问题比如别人不一定会去实例化你写的子类，或者其他类别也实现了点击方法导致不确定会调用哪一个，runtime可以这样解决：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">@implementation UIButton (Hook)</span><br><span class="line"></span><br><span class="line">+ (void)load &#123;</span><br><span class="line"></span><br><span class="line">    static dispatch_once_t onceToken;</span><br><span class="line">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line"></span><br><span class="line">        Class selfClass = [self class];</span><br><span class="line"></span><br><span class="line">        SEL oriSEL = @selector(sendAction:to:forEvent:);</span><br><span class="line">        Method oriMethod = class_getInstanceMethod(selfClass, oriSEL);</span><br><span class="line"></span><br><span class="line">        SEL cusSEL = @selector(mySendAction:to:forEvent:);</span><br><span class="line">        Method cusMethod = class_getInstanceMethod(selfClass, cusSEL);</span><br><span class="line"></span><br><span class="line">        BOOL addSucc = class_addMethod(selfClass, oriSEL, method_getImplementation(cusMethod), method_getTypeEncoding(cusMethod));</span><br><span class="line">        if (addSucc) &#123;</span><br><span class="line">            class_replaceMethod(selfClass, cusSEL, method_getImplementation(oriMethod), method_getTypeEncoding(oriMethod));</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            method_exchangeImplementations(oriMethod, cusMethod);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)mySendAction:(SEL)action to:(id)target forEvent:(UIEvent *)event &#123;</span><br><span class="line">    [CountTool addClickCount];</span><br><span class="line">    [self mySendAction:action to:target forEvent:event];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>利用消息转发机制解决方法找不到的异常问题</li>
<li>动态变量控制<br>
在程序中，xiaowen的age是20，后来被runtime变成10</li>
</ol>
<ul>
<li>
<p>动态获取xiaowen类中的所有属性[包括私有]<br>
Ivar *ivar = class_copyIvarList([self.xiaowen class], &amp;count);</p>
</li>
<li>
<p>遍历属性找到对应name字段<br>
const char *varName = ivar_getName(var);</p>
</li>
<li>
<p>修改对应的字段值成20<br>
object_setIvar(self.xiaowen, var, @“20”);</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (void)changeAge &#123;</span><br><span class="line">     unsigned int count = 0;</span><br><span class="line">     Ivar *ivar = class_copyIvarList([self.xiaowen class], &amp;count);</span><br><span class="line">     for (int i = 0; i&lt;count; i++) &#123;</span><br><span class="line">         Ivar var = ivar[i];</span><br><span class="line">         const char *varName = ivar_getName(var);</span><br><span class="line">         NSString *name = [NSString stringWithUTF8String:varName];</span><br><span class="line">         if ([name isEqualToString:@&quot;_age&quot;]) &#123;</span><br><span class="line">             object_setIvar(self.xiaowen, var, @&quot;20&quot;);</span><br><span class="line">             break;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     NSLog(@&quot;age is %@&quot;,self.xiaowen.age);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<ol start="6">
<li>动态添加方法</li>
</ol>
<ul>
<li>动态给Person类中添加study方法：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (void)addMethod &#123;</span><br><span class="line">    class_addMethod([self.xiaowen class], @selector(study), (IMP)studyImp, &quot;v@:&quot;);</span><br><span class="line">    if ([self.xiaowen respondsToSelector:@selector(study)]) &#123;</span><br><span class="line">        [self.xiaowen performSelector:@selector(study)];</span><br><span class="line">    &#125; else&#123;</span><br><span class="line">        NSLog(@&quot;Sorry,I don&#x27;t know&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void studyImp(id self,SEL _cmd) &#123;</span><br><span class="line">    NSLog(@&quot;i am from beijing&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(IMP)studyImp 意思是studyImp的地址指针;<br>
“v@:” 意思是，v代表无返回值void，如果是i则代表int；@代表 id self; : 代表 SEL _cmd;<br>
“v@:@@” 意思是，两个参数的没有返回值。</p>
<ol start="7">
<li>KVC 字典转模型</li>
</ol>
<ul>
<li>先实现最外层的属性转换</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// 创建对应模型对象</span><br><span class="line"> id objc = [[self alloc] init];</span><br><span class="line"></span><br><span class="line"> unsigned int count = 0;</span><br><span class="line"></span><br><span class="line"> // 1.获取成员属性数组</span><br><span class="line"> Ivar *ivarList = class_copyIvarList(self, &amp;count);</span><br><span class="line"></span><br><span class="line"> // 2.遍历所有的成员属性名,一个一个去字典中取出对应的value给模型属性赋值</span><br><span class="line"> for (int i = 0; i &lt; count; i++) &#123;</span><br><span class="line"></span><br><span class="line">     // 2.1 获取成员属性</span><br><span class="line">     Ivar ivar = ivarList[i];</span><br><span class="line"></span><br><span class="line">     // 2.2 获取成员属性名 C -&gt; OC 字符串</span><br><span class="line">     NSString *ivarName = [NSString stringWithUTF8String:ivar_getName(ivar)];</span><br><span class="line"></span><br><span class="line">     // 2.3 _成员属性名 =&gt; 字典key</span><br><span class="line">     NSString *key = [ivarName substringFromIndex:1];</span><br><span class="line"></span><br><span class="line">     // 2.4 去字典中取出对应value给模型属性赋值</span><br><span class="line">     id value = dict[key];</span><br><span class="line"></span><br><span class="line">     // 获取成员属性类型</span><br><span class="line">     NSString *ivarType = [NSString stringWithUTF8String:ivar_getTypeEncoding(ivar)];</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>内层数组，字典的转换</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">if ([value isKindOfClass:[NSDictionary class]] &amp;&amp; ![ivarType containsString:@&quot;NS&quot;]) &#123; </span><br><span class="line">       //  是字典对象,并且属性名对应类型是自定义类型</span><br><span class="line">      // 处理类型字符串 @\&quot;User\&quot; -&gt; User</span><br><span class="line">      ivarType = [ivarType stringByReplacingOccurrencesOfString:@&quot;@&quot; withString:@&quot;&quot;];</span><br><span class="line">      ivarType = [ivarType stringByReplacingOccurrencesOfString:@&quot;\&quot;&quot; withString:@&quot;&quot;];</span><br><span class="line">      // 自定义对象,并且值是字典</span><br><span class="line">      // value:user字典 -&gt; User模型</span><br><span class="line">      // 获取模型(user)类对象</span><br><span class="line">      Class modalClass = NSClassFromString(ivarType);</span><br><span class="line"></span><br><span class="line">      // 字典转模型</span><br><span class="line">      if (modalClass) &#123;</span><br><span class="line">          // 字典转模型 user</span><br><span class="line">          value = [modalClass objectWithDict:value];</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  if ([value isKindOfClass:[NSArray class]]) &#123;</span><br><span class="line">      // 判断对应类有没有实现字典数组转模型数组的协议</span><br><span class="line">      if ([self respondsToSelector:@selector(arrayContainModelClass)]) &#123;</span><br><span class="line"></span><br><span class="line">          // 转换成id类型，就能调用任何对象的方法</span><br><span class="line">          id idSelf = self;</span><br><span class="line"></span><br><span class="line">          // 获取数组中字典对应的模型</span><br><span class="line">          NSString *type =  [idSelf arrayContainModelClass][key];</span><br><span class="line"></span><br><span class="line">          // 生成模型</span><br><span class="line">          Class classModel = NSClassFromString(type);</span><br><span class="line">          NSMutableArray *arrM = [NSMutableArray array];</span><br><span class="line">          // 遍历字典数组，生成模型数组</span><br><span class="line">          for (NSDictionary *dict in value) &#123;</span><br><span class="line">              // 字典转模型</span><br><span class="line">              id model =  [classModel objectWithDict:dict];</span><br><span class="line">              [arrM addObject:model];</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          // 把模型数组赋值给value</span><br><span class="line">          value = arrM;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<ol start="8">
<li>动态的添加对象的成员变量和方法</li>
<li>实现NSCoding的自动归档和解档，我们把encodeWithCoder 和 initWithCoder这两个方法抽成宏</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;Person.h&quot;</span><br><span class="line">#import &lt;objc/runtime.h&gt;</span><br><span class="line"></span><br><span class="line">#define encodeRuntime(A) \</span><br><span class="line">\</span><br><span class="line">unsigned int count = 0;\</span><br><span class="line">Ivar *ivars = class_copyIvarList([A class], &amp;count);\</span><br><span class="line">for (int i = 0; i&lt;count; i++) &#123;\</span><br><span class="line">Ivar ivar = ivars[i];\</span><br><span class="line">const char *name = ivar_getName(ivar);\</span><br><span class="line">NSString *key = [NSString stringWithUTF8String:name];\</span><br><span class="line">id value = [self valueForKey:key];\</span><br><span class="line">[encoder encodeObject:value forKey:key];\</span><br><span class="line">&#125;\</span><br><span class="line">free(ivars);\</span><br><span class="line">\</span><br><span class="line"></span><br><span class="line">#define initCoderRuntime(A) \</span><br><span class="line">\</span><br><span class="line">if (self = [super init]) &#123;\</span><br><span class="line">unsigned int count = 0;\</span><br><span class="line">Ivar *ivars = class_copyIvarList([A class], &amp;count);\</span><br><span class="line">for (int i = 0; i&lt;count; i++) &#123;\</span><br><span class="line">Ivar ivar = ivars[i];\</span><br><span class="line">const char *name = ivar_getName(ivar);\</span><br><span class="line">NSString *key = [NSString stringWithUTF8String:name];\</span><br><span class="line">id value = [decoder decodeObjectForKey:key];\</span><br><span class="line">[self setValue:value forKey:key];\</span><br><span class="line">&#125;\</span><br><span class="line">free(ivars);\</span><br><span class="line">&#125;\</span><br><span class="line">return self;\</span><br><span class="line">\</span><br><span class="line"></span><br><span class="line">@implementation Person</span><br><span class="line"></span><br><span class="line">- (void)encodeWithCoder:(NSCoder *)encoder &#123;</span><br><span class="line">    encodeRuntime(Person)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (id)initWithCoder:(NSCoder *)decoder &#123;</span><br><span class="line">    initCoderRuntime(Person)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<h4 id="4、Runtime方法调用流程？">4、Runtime方法调用流程？</h4>
<p>1、当调用对象方法的时候，会通过obj_object的isa指针找对对应的归属类。<br>
2、从归属类（obj_class）类中的cache中寻找对应的相等的sel方法编号。<br>
3、如果没有找到，继续obj_class中的method_list中查找，如果找到写入cache中。<br>
4、如果没有到找到，会一直找到它的元类上。<br>
5、如果元类也没有的话，会调用消息动态解析方法<code>+resovleInstanceMethod:</code>和<code>+resloveClassMethod:</code>的方法，查看是否存在绑定的方法。<br>
6、如果没有绑定方法，会调用消息转发方法<code>-forwardingTargetForSelector:</code>的方法。查看是否存在转发对象。<br>
7、如果没有存在消息转发对象，会调用<code>-methodSignatureForSelector:</code>的方法，查看是否有方法签名返回类型和参数类型。<br>
8、不存在签名方法和类型，就会来到<code>-doseNotRecognizeSelector:</code>方法内部程序crash提示无法识别选择器unrecognized selector sent to instance。<br>
9、存在签名的方法，就是继续执行<code>-forwardInvocation:</code>寻找IMP，没有找到IMP，就会来到<code>-doseNotRecognizeSelector:</code>方法内部程序crash提示无法识别选择器unrecognized selector sent to instance。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">@implementation Person</span><br><span class="line">- (BOOL)respondsToSelector:(SEL)aSelector &#123;</span><br><span class="line">    bool a= [super respondsToSelector:aSelector];</span><br><span class="line">    return a;</span><br><span class="line">&#125;</span><br><span class="line">//如果方法没有实现，默认返回false</span><br><span class="line">//如果返回false，就会走消息转发</span><br><span class="line">+ (BOOL)resolveInstanceMethod:(SEL)sel &#123;</span><br><span class="line">    bool a = [super resolveInstanceMethod:sel];</span><br><span class="line">    return a;</span><br><span class="line">&#125;</span><br><span class="line">//默认返回空</span><br><span class="line">//又被称为快速消息转发。</span><br><span class="line">// 如果为空，走慢速消息转发，继续转发消息</span><br><span class="line">- (id)forwardingTargetForSelector:(SEL)aSelector &#123;</span><br><span class="line">    id a = [super forwardingTargetForSelector:aSelector];</span><br><span class="line">    return a;</span><br><span class="line">&#125;</span><br><span class="line">// 默认一般普通方法是返回空的。</span><br><span class="line">// 如果是协议方法，没有实现，不会反回空。</span><br><span class="line">//反回空，到这里就会崩溃了</span><br><span class="line">//如果这里返回了签名，会再次调用resolveInstanceMethod:(SEL)sel判断是否实现</span><br><span class="line">//如果仍然没有实现，就会走到fowardInvocation:</span><br><span class="line">- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector &#123;</span><br><span class="line">    NSMethodSignature *a = [super methodSignatureForSelector:aSelector];</span><br><span class="line">    return a;</span><br><span class="line">&#125;</span><br><span class="line">//默认实现是崩溃</span><br><span class="line">//并且不能用try-catch捕获</span><br><span class="line">- (void)forwardInvocation:(NSInvocation *)anInvocation &#123;</span><br><span class="line">    [super forwardInvocation:anInvocation];</span><br><span class="line">    NSLog(@&quot;&quot;);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<h4 id="5、Runtime的方法交换的流程？">5、Runtime的方法交换的流程？</h4>
<p>1、方法交换要放在<code>+(viod)load</code>中处理。<br>
2、在load中首先使用<code>class_addMethod</code>的方法添加新方法。<br>
3、添加成功后，使用<code>class_replaceMethod</code>替换原来的方法。<br>
4、如果添加失败的话，则说明已经有添加成功。直接使用<code>class_exchangeMethod</code>的方法替换。<br>
5、在交换方法时候，使用<code>dispach_one</code>的方法。<br>
6、在新方法中调用新方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">使用注意要点：</span><br><span class="line">1、使用load时候，切记不要做初始化和大开销大内存逻辑。因为程序顺序是，父类-&gt;当前类-&gt;分类-&gt;mian</span><br><span class="line">2、使用的时候如果方法相同是不会覆盖原来的方法，会放在置顶，所以一般不会调用到原来的方法。</span><br><span class="line">3、在新方法中调用新方法。</span><br></pre></td></tr></table></figure>
<h4 id="6、常见方法？">6、常见方法？</h4>
<ul>
<li>获取属性列表</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">objc_property_t *propertyList = class_copyPropertyList([self class], &amp;count);</span><br><span class="line">for (unsigned int i=0; i&lt;count; i++) &#123;</span><br><span class="line">    const char *propertyName = property_getName(propertyList[i]);</span><br><span class="line">    NSLog(@&quot;property----&gt;%@&quot;, [NSString stringWithUTF8String:propertyName]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>获取方法列表</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Method *methodList = class_copyMethodList([self class], &amp;count);</span><br><span class="line">for (unsigned int i; i&lt;count; i++) &#123;</span><br><span class="line">    Method method = methodList[i];</span><br><span class="line">    NSLog(@&quot;Method----&gt;%@&quot;, NSStringFromSelector(method_getName(method)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>获取成员变量列表</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Ivar *ivarList = class_copyIvarList([self class], &amp;count);</span><br><span class="line">for (unsigned int i; i&lt;count; i++) &#123;</span><br><span class="line">    Ivar myIvar = ivarList[i];</span><br><span class="line">    const char *ivarName = ivar_getName(myIvar);</span><br><span class="line">    NSLog(@&quot;Ivar----&gt;%@&quot;, [NSString stringWithUTF8String:ivarName]);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<ul>
<li>获取协议列表</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">__unsafe_unretained Protocol **protocolList = class_copyProtocolList([self class], &amp;count);</span><br><span class="line">for (unsigned int i; i&lt;count; i++) &#123;</span><br><span class="line">    Protocol *myProtocal = protocolList[i];</span><br><span class="line">    const char *protocolName = protocol_getName(myProtocal);</span><br><span class="line">    NSLog(@&quot;protocol----&gt;%@&quot;, [NSString stringWithUTF8String:protocolName]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="计算机网络">计算机网络</h3>
<h4 id="1、网络七层协议">1、网络七层协议</h4>
<ul>
<li><strong>应用层：</strong><br>
1.用户接口、应用程序；<br>
2.Application典型设备：网关；<br>
3.典型协议、标准和应用：TELNET、FTP、HTTP</li>
<li><strong>表示层：</strong><br>
1.数据表示、压缩和加密presentation<br>
2.典型设备：网关<br>
3.典型协议、标准和应用：ASCLL、PICT、TIFF、JPEG|MPEG<br>
4.表示层相当于一个东西的表示，表示的一些协议，比如图片、声音和视频MPEG。</li>
<li><strong>会话层：</strong><br>
1.会话的建立和结束；<br>
2.典型设备：网关；<br>
3.典型协议、标准和应用：RPC、SQL、NFS、X WINDOWS、ASP</li>
<li><strong>传输层：</strong><br>
1.主要功能：端到端控制Transport；<br>
2.典型设备：网关；<br>
3.典型协议、标准和应用：TCP、UDP、SPX</li>
<li><strong>网络层：</strong><br>
1.主要功能：路由、寻址Network；<br>
2.典型设备：路由器；<br>
3.典型协议、标准和应用：IP、IPX、APPLETALK、ICMP；</li>
<li><strong>数据链路层：</strong><br>
1.主要功能：保证无差错的疏忽链路的data link；<br>
2.典型设备：交换机、网桥、网卡；<br>
3.典型协议、标准和应用：802.2、802.3ATM、HDLC、FRAME RELAY；</li>
<li><strong>物理层：</strong><br>
1.主要功能：传输比特流Physical；<br>
2.典型设备：集线器、中继器<br>
3.典型协议、标准和应用：V.35、EIA/TIA-232.</li>
</ul>
<h4 id="2、Http-和-Https-的区别？Https为什么更加安全？">2、Http 和 Https 的区别？Https为什么更加安全？</h4>
<ul>
<li><strong>区别</strong><br>
1.HTTPS 需要向机构申请 CA 证书，极少免费。<br>
2.HTTP 属于明文传输，HTTPS基于 SSL 进行加密传输。<br>
3.HTTP 端口号为 80，HTTPS 端口号为 443 。<br>
4.HTTPS 是加密传输，有身份验证的环节，更加安全。</li>
<li><strong>安全</strong><br>
SSL(安全套接层) TLS(传输层安全)<br>
以上两者在传输层之上，对网络连接进行加密处理，保障数据的完整性，更加的安全。</li>
</ul>
<h4 id="3、HTTPS的连接建立流程？">3、HTTPS的连接建立流程？</h4>
<ul>
<li>服务器端的公钥和私钥，用来进行非对称加密</li>
<li>客户端生成的随机密钥，用来进行对称加密</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/2752635-bbc482d077daa839.jpg" alt=""></p>
<p>http建立连接过程.jpg</p>
<p>如上图，HTTPS连接过程大致可分为八步:</p>
<ol>
<li>
<p>客户端访问HTTPS连接。<br>
客户端会把安全协议版本号、客户端支持的加密算法列表、随机数C发给服务端。</p>
</li>
<li>
<p>服务端发送证书给客户端</p>
</li>
</ol>
<ul>
<li>
<p>服务端接收密钥算法配件后，会和自己支持的加密算法列表进行比对，如果不符合，则断开连接。否则，服务端会在该算法列表中，选择一种对称算法（如AES）、一种公钥算法（如具有特定秘钥长度的RSA）和一种MAC算法发给客户端。</p>
</li>
<li>
<p>服务器端有一个密钥对，即公钥和私钥，是用来进行非对称加密使用的，服务器端保存着私钥，不能将其泄露，公钥可以发送给任何人。</p>
</li>
<li>
<p>在发送加密算法的同时还会把数字证书和随机数S发送给客户端</p>
</li>
</ul>
<ol start="3">
<li>
<p>客户端验证server证书<br>
会对server公钥进行检查，验证其合法性，如果发现发现公钥有问题，那么HTTPS传输就无法继续。</p>
</li>
<li>
<p>客户端组装会话秘钥<br>
如果公钥合格，那么客户端会用服务器公钥来生成一个前主秘钥(Pre-Master Secret，PMS)，并通过该前主秘钥和随机数C、S来组装成会话秘钥</p>
</li>
<li>
<p>客户端将前主秘钥加密发送给服务端<br>
是通过服务端的公钥来对前主秘钥进行非对称加密，发送给服务端</p>
</li>
<li>
<p>服务端通过私钥解密得到前主秘钥<br>
服务端接收到加密信息后，用私钥解密得到主秘钥。</p>
</li>
<li>
<p>服务端组装会话秘钥<br>
服务端通过前主秘钥和随机数C、S来组装会话秘钥。<br>
至此，服务端和客户端都已经知道了用于此次会话的主秘钥。</p>
</li>
<li>
<p>数据传输<br>
客户端收到服务器发送来的密文，用客户端密钥对其进行对称解密，得到服务器发送的数据。<br>
同理，服务端收到客户端发送来的密文，用服务端密钥对其进行对称解密，得到客户端发送的数据。</p>
</li>
</ol>
<h4 id="4、解释一下三次握手和四次挥手？">4、解释一下三次握手和四次挥手？</h4>
<ul>
<li>
<p><strong>三次握手</strong><br>
1.由客户端向服务端发送 SYN 同步报文。<br>
2.当服务端收到 SYN 同步报文之后，会返回给客户端 SYN 同步报文和 ACK 确认报文。<br>
3.客户端会向服务端发送 ACK 确认报文，此时客户端和服务端的连接正式建立。</p>
</li>
<li>
<p><strong>建立连接</strong><br>
1.这个时候客户端就可以通过 Http 请求报文，向服务端发送请求<br>
2.服务端接收到客户端的请求之后，向客户端回复 Http 响应报文。</p>
</li>
<li>
<p><strong>四次挥手</strong><br>
1.先由客户端向服务端发送 FIN 结束报文。<br>
2.服务端会返回给客户端 ACK 确认报文 。此时，由客户端发起的断开连接已经完成。<br>
3.服务端会发送给客户端 FIN 结束报文 和 ACK 确认报文。<br>
4.客户端会返回 ACK 确认报文到服务端，至此，由服务端方向的断开连接已经完成。</p>
</li>
</ul>
<h4 id="5、TCP-和-UDP的区别？">5、TCP 和 UDP的区别？</h4>
<ul>
<li>**TCP：**面向连接、传输可靠(保证数据正确性,保证数据顺序)、用于传输大量数据(流模式)、速度慢，建立连接需要开销较多(时间，系统资源)。</li>
<li>**UDP：**面向非连接、传输不可靠、用于传输少量数据(数据包模式)、速度快。</li>
</ul>
<h4 id="多线程">多线程</h4>
<h4 id="1、进程与线程">1、进程与线程</h4>
<ul>
<li>
<p><strong>进程：</strong><br>
1.进程是一个具有一定独立功能的程序关于某次数据集合的一次运行活动，它是操作系统分配资源的基本单元.<br>
2.进程是指在系统中正在运行的一个应用程序，就是一段程序的执行过程,我们可以理解为手机上的一个app.<br>
3.每个进程之间是独立的，每个进程均运行在其专用且受保护的内存空间内，拥有独立运行所需的全部资源</p>
</li>
<li>
<p><strong>线程：</strong><br>
1.程序执行流的最小单元，线程是进程中的一个实体.<br>
2.一个进程要想执行任务,必须至少有一条线程.应用程序启动的时候，系统会默认开启一条线程,也就是主线程</p>
</li>
<li>
<p><strong>进程和线程的关系</strong><br>
1.线程是进程的执行单元，进程的所有任务都在线程中执行<br>
2.线程是 CPU 分配资源和调度的最小单位<br>
3.一个程序可以对应多个进程(多进程),一个进程中可有多个线程,但至少要有一条线程<br>
4.同一个进程内的线程共享进程资源</p>
</li>
</ul>
<h4 id="2、什么是多线程？">2、什么是多线程？</h4>
<ul>
<li>多线程的实现原理：事实上，同一时间内单核的CPU只能执行一个线程，多线程是CPU快速的在多个线程之间进行切换（调度），造成了多个线程同时执行的假象。</li>
<li>如果是多核CPU就真的可以同时处理多个线程了。</li>
<li>多线程的目的是为了同步完成多项任务，通过提高系统的资源利用率来提高系统的效率。</li>
</ul>
<h4 id="3、多线程的优点和缺点？">3、多线程的优点和缺点？</h4>
<ul>
<li>
<p><strong>优点:</strong><br>
能适当提高程序的执行效率<br>
能适当提高资源利用率（CPU、内存利用率）</p>
</li>
<li>
<p><strong>缺点:</strong></p>
</li>
</ul>
<ol>
<li>开启线程需要占用一定的内存空间（默认情况下，主线程占用1M，子线程占用512KB），如果开启大量的线程，会占用大量的内存空间，降低程序的性能</li>
<li>线程越多，CPU在调度线程上的开销就越大</li>
<li>程序设计更加复杂：比如线程之间的通信、多线程的数据共享</li>
</ol>
<h4 id="4、多线程的并行和并发有什么区别？">4、多线程的<strong>并行</strong>和<strong>并发</strong>有什么区别？</h4>
<ul>
<li>**并行：**充分利用计算机的多核，在多个线程上同步进行</li>
<li>**并发：**在一条线程上通过快速切换，让人感觉在同步进行</li>
</ul>
<h4 id="5、iOS中实现多线程的几种方案，各自有什么特点？">5、iOS中实现多线程的几种方案，各自有什么特点？</h4>
<ul>
<li>NSThread 面向对象的，需要程序员手动创建线程，但不需要手动销毁。子线程间通信很难。</li>
<li>GCD C语言，充分利用了设备的多核，自动管理线程生命周期。比NSOperation效率更高。</li>
<li>NSOperation 基于GCD封装，更加面向对象，比GCD多了一些功能。</li>
</ul>
<h4 id="6、多个网络请求完成后执行下一步？">6、多个网络请求完成后执行下一步？</h4>
<p><strong>使用GCD的dispatch_group_t</strong></p>
<p>创建一个dispatch_group_t</p>
<p>每次网络请求前先<code>dispatch_group_enter</code>,请求回调后再<code>dispatch_group_leave</code>，enter和leave必须配合使用，有几次enter就要有几次leave，否则group会一直存在。</p>
<p>当所有enter的block都leave后，会执行<code>dispatch_group_notify</code>的block。</p>
<p>栅栏函数中传入的参数队列必须是由 <code>dispatch_queue_create</code> 方法创建的队列，否则，与 <code>dispatch_async</code> 无异，起不到“栅栏”的作用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">NSString *str = @&quot;http://xxxx.com/&quot;;</span><br><span class="line">NSURL *url = [NSURL URLWithString:str];</span><br><span class="line">NSURLRequest *request = [NSURLRequest requestWithURL:url];</span><br><span class="line">NSURLSession *session = [NSURLSession sharedSession];</span><br><span class="line"></span><br><span class="line">dispatch_group_t downloadGroup = dispatch_group_create();</span><br><span class="line">for (int i=0; i&lt;10; i++) &#123;</span><br><span class="line">    dispatch_group_enter(downloadGroup);</span><br><span class="line"></span><br><span class="line">    NSURLSessionDataTask *task = [session dataTaskWithRequest:request completionHandler:^(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error) &#123;</span><br><span class="line">        NSLog(@&quot;%d---%d&quot;,i,i);</span><br><span class="line">        dispatch_group_leave(downloadGroup);</span><br><span class="line">    &#125;];</span><br><span class="line">    [task resume];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dispatch_group_notify(downloadGroup, dispatch_get_main_queue(), ^&#123;</span><br><span class="line">    NSLog(@&quot;end&quot;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><strong>使用GCD的信号量dispatch_semaphore_t</strong></p>
<p>dispatch_semaphore信号量为基于计数器的一种多线程同步机制。如果semaphore计数大于等于1，计数-1，返回，程序继续运行。如果计数为0，则等待。<code>dispatch_semaphore_signal(semaphore)</code>为计数+1操作,<code>dispatch_semaphore_wait(sema, DISPATCH_TIME_FOREVER)</code>为设置等待时间，这里设置的等待时间是一直等待。</p>
<p>创建semaphore为0，等待，等10个网络请求都完成了，dispatch_semaphore_signal(semaphore)为计数+1，然后计数-1返回</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">NSString *str = @&quot;http://xxxx.com/&quot;;</span><br><span class="line">NSURL *url = [NSURL URLWithString:str];</span><br><span class="line">NSURLRequest *request = [NSURLRequest requestWithURL:url];</span><br><span class="line">NSURLSession *session = [NSURLSession sharedSession];</span><br><span class="line"></span><br><span class="line">dispatch_semaphore_t sem = dispatch_semaphore_create(0);</span><br><span class="line">for (int i=0; i&lt;10; i++) &#123;</span><br><span class="line"></span><br><span class="line">    NSURLSessionDataTask *task = [session dataTaskWithRequest:request completionHandler:^(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error) &#123;</span><br><span class="line">        NSLog(@&quot;%d---%d&quot;,i,i);</span><br><span class="line">        count++;</span><br><span class="line">        if (count==10) &#123;</span><br><span class="line">            dispatch_semaphore_signal(sem);</span><br><span class="line">            count = 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">    [task resume];</span><br><span class="line">&#125;</span><br><span class="line">dispatch_semaphore_wait(sem, DISPATCH_TIME_FOREVER);</span><br><span class="line"></span><br><span class="line">dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">    NSLog(@&quot;end&quot;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h4 id="7、多个网络请求顺序执行后执行下一步？">7、多个网络请求顺序执行后执行下一步？</h4>
<p><strong>使用信号量semaphore</strong></p>
<p>每一次遍历，都让其<code>dispatch_semaphore_wait(sem, DISPATCH_TIME_FOREVER)</code>，这个时候线程会等待，阻塞当前线程，直到<code>dispatch_semaphore_signal(sem)</code>调用之后</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">NSString *str = @&quot;http://www.jianshu.com/p/6930f335adba&quot;;</span><br><span class="line">NSURL *url = [NSURL URLWithString:str];</span><br><span class="line">NSURLRequest *request = [NSURLRequest requestWithURL:url];</span><br><span class="line">NSURLSession *session = [NSURLSession sharedSession];</span><br><span class="line"></span><br><span class="line">dispatch_semaphore_t sem = dispatch_semaphore_create(0);</span><br><span class="line">for (int i=0; i&lt;10; i++) &#123;</span><br><span class="line"></span><br><span class="line">    NSURLSessionDataTask *task = [session dataTaskWithRequest:request completionHandler:^(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error) &#123;</span><br><span class="line"></span><br><span class="line">        NSLog(@&quot;%d---%d&quot;,i,i);</span><br><span class="line">        dispatch_semaphore_signal(sem);</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    [task resume];</span><br><span class="line">    dispatch_semaphore_wait(sem, DISPATCH_TIME_FOREVER);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">    NSLog(@&quot;end&quot;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h4 id="8、异步操作两组数据时-执行完第一组之后-才能执行第二组？">8、异步操作两组数据时, 执行完第一组之后, 才能执行第二组？</h4>
<p>这里使用dispatch_barrier_async栅栏方法即可实现</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t queue = dispatch_queue_create(&quot;test&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line"></span><br><span class="line">dispatch_async(queue, ^&#123;</span><br><span class="line">    NSLog(@&quot;第一次任务的主线程为: %@&quot;, [NSThread currentThread]);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">dispatch_async(queue, ^&#123;</span><br><span class="line">    NSLog(@&quot;第二次任务的主线程为: %@&quot;, [NSThread currentThread]);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">dispatch_barrier_async(queue, ^&#123;</span><br><span class="line">    NSLog(@&quot;第一次任务, 第二次任务执行完毕, 继续执行&quot;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">dispatch_async(queue, ^&#123;</span><br><span class="line">    NSLog(@&quot;第三次任务的主线程为: %@&quot;, [NSThread currentThread]);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">dispatch_async(queue, ^&#123;</span><br><span class="line">    NSLog(@&quot;第四次任务的主线程为: %@&quot;, [NSThread currentThread]);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h4 id="9、多线程中的死锁？">9、多线程中的死锁？</h4>
<p>死锁是由于多个线程（进程）在执行过程中，因为争夺资源而造成的互相等待现象，你可以理解为卡主了。产生死锁的必要条件有四个：</p>
<ul>
<li>**互斥条件：**指进程对所分配到的资源进行排它性使用，即在一段时间内某资源只由一个进程占用。如果此时还有其它进程请求资源，则请求者只能等待，直至占有资源的进程用毕释放。</li>
<li>**请求和保持条件：**指进程已经保持至少一个资源，但又提出了新的资源请求，而该资源已被其它进程占有，此时请求进程阻塞，但又对自己已获得的其它资源保持不放。</li>
<li>**不可剥夺条件：**指进程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完时由自己释放。</li>
<li>**环路等待条件：**指在发生死锁时，必然存在一个进程——资源的环形链，即进程集合{P0，P1，P2，···，Pn}中的P0正在等待一个P1占用的资源；P1正在等待P2占用的资源，……，Pn正在等待已被P0占用的资源。</li>
</ul>
<p>最常见的就是 <strong>同步函数 + 主队列</strong> 的组合，本质是队列阻塞。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">dispatch_sync(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">    NSLog(@&quot;2&quot;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;1&quot;);</span><br><span class="line">// 什么也不会打印，直接报错</span><br></pre></td></tr></table></figure>
<h4 id="10、GCD执行原理？">10、GCD执行原理？</h4>
<ul>
<li>GCD有一个底层线程池，这个池中存放的是一个个的线程。之所以称为“池”，很容易理解出这个“池”中的线程是可以重用的，当一段时间后这个线程没有被调用的话，这个线程就会被销毁。注意：开多少条线程是由底层线程池决定的（线程建议控制再3~5条），池是系统自动来维护，不需要我们程序员来维护，我们只关心的是向队列中添加任务，队列调度即可。</li>
<li>如果队列中存放的是同步任务，则任务出队后，底层线程池中会提供一条线程供这个任务执行，任务执行完毕后这条线程再回到线程池。这样队列中的任务反复调度，因为是同步的，所以当我们用currentThread打印的时候，就是同一条线程。</li>
<li>如果队列中存放的是异步的任务，（注意异步可以开线程），当任务出队后，底层线程池会提供一个线程供任务执行，因为是异步执行，队列中的任务不需等待当前任务执行完毕就可以调度下一个任务，这时底层线程池中会再次提供一个线程供第二个任务执行，执行完毕后再回到底层线程池中。</li>
<li>这样就对线程完成一个复用，而不需要每一个任务执行都开启新的线程，也就从而节约的系统的开销，提高了效率。在iOS7.0的时候，使用GCD系统通常只能开5-8条线程，iOS8.0以后，系统可以开启很多条线程，但是实在开发应用中，建议开启线程条数：3-5条最为合理。</li>
</ul>
<h3 id="项目架构">项目架构</h3>
<h4 id="1、MVC、MVVM模式">1、MVC、MVVM模式</h4>
<h5 id="MVC（Model、View、Controller）">MVC（Model、View、Controller）</h5>
<p>MVC是比较直观的架构模式，最核心的就是通过Controller层来进行调控<br>
Model和View永远不能相互通信，只能通过Controller传递<br>
Controller可以直接与Model对话（读写调用Model），Model通过Notification和KVO机制与Controller间接通信<br>
Controller可以直接与View对话，通过IBoutlet直接操作View，IBoutlet直接对应View的控件（例如创建一个Button：需声明一个 IBOutlet UIButton * btn），View通过action向Controller报告时间的发生(用户点击了按钮)。Controller是View的直接数据源</p>
<ul>
<li><strong>优点:</strong> 对于混乱的项目组织方式，有了一个明确的组织方式。通过Controller来掌控全局，同时将View展示和Model的变化分开</li>
<li><strong>缺点:</strong> 愈发笨重的Controller，随着业务逻辑的增加，大量的代码放进Controller，导致Controller越来越臃肿，堆积成千上万行代码，后期维护起来费时费力</li>
</ul>
<h5 id="MVVM（Model、Controller-View、ViewModel）">MVVM（Model、Controller/View、ViewModel）</h5>
<p>在MVVM中，View和ViewController联系在一起，我们把它们视为一个组件，View和ViewController都不能直接引用model，而是引用是视图模型即ViewModel。 ViewModel是一个用来放置用户输入验证逻辑、视图显示逻辑、网络请求等业务逻辑的地方，这样的设计模式，会轻微增加代码量，但是会减少代码的复杂性</p>
<ul>
<li><strong>优点:</strong> View可以独立于Model的变化和修改，一个ViewModel可以绑定到不同的View上，降低耦合，增加重用</li>
<li><strong>缺点:</strong> 过于简单的项目不适用、大型的项目视图状态较多时构建和维护成本太大<br>
合理的运用架构模式有利于项目、团队开发工作，不同的设计模式，只是让不同的场景有了更多的选择方案。根据项目场景和开发需求，选择最合适的解决方案。</li>
</ul>
<h3 id="调试技巧">调试技巧</h3>
<h4 id="1、LLDB常用的调试命令？">1、LLDB常用的调试命令？</h4>
<p>**po：**print object的缩写，表示显示对象的文本描述，如果对象不存在则打印nil。<br>
**p：**可以用来打印基本数据类型。<br>
**call：**执行一段代码 如：call NSLog(@“%@”, @“yang”)<br>
**expr：**动态执行指定表达式<br>
**bt：**打印当前线程堆栈信息 （bt all 打印所有线程堆栈信息）<br>
**image：**常用来寻找栈地址对应代码位置 如：image lookup --address 0xxxx</p>
<h4 id="2、断点调试？">2、断点调试？</h4>
<p><strong>条件断点</strong><br>
打上断点之后，对断点进行编辑，设置相应过滤条件。下面简单的介绍一下条件设置：</p>
<ol>
<li>Condition：返回一个布尔值，当布尔值为真触发断点，一般里面我们可以写一个表达式。</li>
<li>Ignore：忽略前N次断点，到N+1次再触发断点。</li>
<li>Action：断点触发事件，分为六种：</li>
</ol>
<ul>
<li>AppleScript：执行脚本。</li>
<li>Capture GPU Frame：用于OpenGL ES调试，捕获断点处GPU当前绘制帧。</li>
<li>Debugger Command：和控制台中输入LLDB调试命令一致。</li>
<li>Log Message：输出自定义格式信息至控制台。</li>
<li>Shell Command：接收命令文件及相应参数列表，Shell Command是异步执行的，只有勾选“Wait until done”才会等待Shell命令执行完在执行调试。</li>
<li>Sound：断点触发时播放声音。</li>
<li>Options(Automatically continue after evaluating actions选项)：选中后，表示断点不会终止程序的运行。</li>
</ul>
<p><strong>异常断点</strong><br>
异常断点可以快速定位不满足特定条件的异常，比如常见的数组越界，这时候很难通过异常信息定位到错误所在位置。这个时候异常断点就可以发挥作用了。<br>
Exception：可以选择抛出异常对象类型：OC或C++。<br>
Break：选择断点接收的抛出异常来源是Throw还是Catch语句。</p>
<p><strong>符号断点</strong><br>
符号断点的创建方式和异常断点一样一样的，在符号断点中可以指定要中断执行的方法：<br>
Symbol:[类名 方法名]可以执行到指定类的指定方法中开始断点。</p>
<h4 id="3、iOS-常见的崩溃类型有哪些？">3、iOS 常见的崩溃类型有哪些？</h4>
<ul>
<li>unrecognized selector crash</li>
<li>KVO crash</li>
<li>NSNotification crash</li>
<li>NSTimer crash</li>
<li>Container crash</li>
<li>NSString crash</li>
<li>Bad Access crash （野指针）</li>
<li>UI not on Main Thread Crash</li>
</ul>
<h3 id="性能优化">性能优化</h3>
<h4 id="1、造成tableView卡顿的原因有哪些？">1、造成tableView卡顿的原因有哪些？</h4>
<ol>
<li>最常用的就是cell的重用， 注册重用标识符</li>
</ol>
<ul>
<li>如果不重用cell时，每当一个cell显示到屏幕上时，就会重新创建一个新的cell</li>
<li>如果重用cell，为cell创建一个ID，每当需要显示cell 的时候，都会先去缓冲池中寻找可循环利用的cell，如果没有再重新创建cell</li>
</ul>
<ol start="2">
<li>避免cell的重新布局</li>
</ol>
<ul>
<li>cell的布局填充等操作比较耗时，一般创建时就布局好</li>
</ul>
<ol start="3">
<li>提前计算并缓存cell的属性及内容</li>
</ol>
<ul>
<li>当我们创建cell的数据源方法时，编译器并不是先创建cell 再定cell的高度</li>
<li>而是先根据内容一次确定每一个cell的高度，高度确定后，再创建要显示的cell，滚动时，每当cell进入凭虚都会计算高度，提前估算高度告诉编译器，编译器知道高度后，紧接着就会创建cell，这时再调用高度的具体计算方法，这样可以方式浪费时间去计算显示以外的cell</li>
</ul>
<ol start="4">
<li>减少cell中控件的数量</li>
</ol>
<ul>
<li>尽量使cell得布局大致相同，不同风格的cell可以使用不用的重用标识符，初始化时添加控件，</li>
<li>不适用的可以先隐藏</li>
</ul>
<ol start="5">
<li>不要使用ClearColor，无背景色，透明度也不要设置为0</li>
</ol>
<ul>
<li>渲染耗时比较长</li>
</ul>
<ol start="6">
<li>使用局部更新</li>
</ol>
<ul>
<li>如果只是更新某组的话，使用reloadSection进行局部更</li>
</ul>
<ol start="7">
<li>加载网络数据，下载图片，使用异步加载，并缓存</li>
<li>少使用addView 给cell动态添加view</li>
<li>按需加载cell，cell滚动很快时，只加载范围内的cell</li>
<li>不要实现无用的代理方法，tableView只遵守两个协议</li>
<li>缓存行高：estimatedHeightForRow不能和HeightForRow里面的layoutIfNeed同时存在，这两者同时存在才会出现“窜动”的bug。所以我的建议是：只要是固定行高就写预估行高来减少行高调用次数提升性能。如果是动态行高就不要写预估方法了，用一个行高的缓存字典来减少代码的调用次数即可</li>
<li>不要做多余的绘制工作。在实现drawRect:的时候，它的rect参数就是需要绘制的区域，这个区域之外的不需要进行绘制。例如上例中，就可以用CGRectIntersectsRect、CGRectIntersection或CGRectContainsRect判断是否需要绘制image和text，然后再调用绘制方法。</li>
<li>预渲染图像。当新的图像出现时，仍然会有短暂的停顿现象。解决的办法就是在bitmap context里先将其画一遍，导出成UIImage对象，然后再绘制到屏幕；</li>
<li>使用正确的数据结构来存储数据。</li>
</ol>
<h4 id="2、如何提升-tableview-的流畅度？">2、如何提升 tableview 的流畅度？</h4>
<p>本质上是降低 CPU、GPU 的工作，从这两个大的方面去提升性能。<br>
**CPU：**对象的创建和销毁、对象属性的调整、布局计算、文本的计算和排版、图片的格式转换和解码、图像的绘制<br>
**GPU：**纹理的渲染</p>
<ol>
<li>卡顿优化在 CPU 层面</li>
</ol>
<ul>
<li>尽量用轻量级的对象，比如用不到事件处理的地方，可以考虑使用 CALayer 取代 UIView</li>
<li>不要频繁地调用 UIView 的相关属性，比如 frame、bounds、transform 等属性，尽量减少不必要的修改</li>
<li>尽量提前计算好布局，在有需要时一次性调整对应的属性，不要多次修改属性</li>
<li>Autolayout 会比直接设置 frame 消耗更多的 CPU 资源</li>
<li>图片的 size 最好刚好跟 UIImageView 的 size 保持一致</li>
<li>控制一下线程的最大并发数量</li>
<li>尽量把耗时的操作放到子线程</li>
<li>文本处理（尺寸计算、绘制）</li>
<li>图片处理（解码、绘制）</li>
</ul>
<ol start="2">
<li>卡顿优化在 GPU层面</li>
</ol>
<ul>
<li>尽量避免短时间内大量图片的显示，尽可能将多张图片合成一张进行显示</li>
<li>GPU能处理的最大纹理尺寸是 4096x4096，一旦超过这个尺寸，就会占用 CPU 资源进行处理，所以纹理尽量不要超过这个尺寸</li>
<li>尽量减少视图数量和层次</li>
<li>减少透明的视图（alpha&lt;1），不透明的就设置 opaque 为 YES</li>
<li>尽量避免出现离屏渲染</li>
</ul>
<h4 id="3、iOS-保持界面流畅的技巧？">3、iOS 保持界面流畅的技巧？</h4>
<ol>
<li>预排版，提前计算</li>
</ol>
<ul>
<li>在接收到服务端返回的数据后，尽量将 CoreText 排版的结果、单个控件的高度、cell 整体的高度提前计算好，将其存储在模型的属性中。需要使用时，直接从模型中往外取，避免了计算的过程。</li>
<li>尽量少用 UILabel，可以使用 CALayer 。避免使用 AutoLayout 的自动布局技术，采取纯代码的方式</li>
</ul>
<ol start="2">
<li>预渲染，提前绘制</li>
</ol>
<ul>
<li>例如圆形的图标可以提前在，在接收到网络返回数据时，在后台线程进行处理，直接存储在模型数据里，回到主线程后直接调用就可以了</li>
<li>避免使用 CALayer 的 Border、corner、shadow、mask 等技术，这些都会触发离屏渲染。</li>
</ul>
<ol start="3">
<li>异步绘制</li>
<li>全局并发线程</li>
<li>高效的图片异步加载</li>
</ol>
<h4 id="4、APP启动时间应从哪些方面优化？">4、APP启动时间应从哪些方面优化？</h4>
<p>App启动时间可以通过xcode提供的工具来度量，在Xcode的Product-&gt;Scheme–&gt;Edit Scheme-&gt;Run-&gt;Auguments中，将环境变量DYLD_PRINT_STATISTICS设为YES，优化需以下方面入手</p>
<ol>
<li>dylib loading time</li>
</ol>
<ul>
<li>核心思想是减少dylibs的引用</li>
<li>合并现有的dylibs（最好是6个以内）</li>
<li>使用静态库</li>
</ul>
<ol start="2">
<li>rebase/binding time</li>
</ol>
<ul>
<li>核心思想是减少DATA块内的指针</li>
<li>减少Object C元数据量，减少Objc类数量，减少实例变量和函数（与面向对象设计思想冲突）</li>
<li>减少c++虚函数</li>
<li>多使用Swift结构体（推荐使用swift）</li>
</ul>
<ol start="3">
<li>ObjC setup time</li>
</ol>
<ul>
<li>核心思想同上，这部分内容基本上在上一阶段优化过后就不会太过耗时</li>
<li>initializer time</li>
</ul>
<ol start="4">
<li>使用initialize替代load方法</li>
</ol>
<ul>
<li>减少使用c/c++的attribute((constructor))；推荐使用<code>dispatch_once() pthread_once() std:once()</code>等方法</li>
<li>推荐使用swift</li>
<li>不要在初始化中调用<code>dlopen()</code>方法，因为加载过程是单线程，无锁，如果调用dlopen则会变成多线程，会开启锁的消耗，同时有可能死锁</li>
<li>不要在初始化中创建线程</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://www.nickxu.top">Peter</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://www.nickxu.top/post/6db1ba4f.html">https://www.nickxu.top/post/6db1ba4f.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://www.nickxu.top" target="_blank">Peter の 博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/iOS/">iOS</a><a class="post-meta__tags" href="/tags/%E9%9D%A2%E8%AF%95/">面试</a></div><div class="post_share"></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/static/header.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Peter</div><div class="author-info__description">折腾就是快乐</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">2</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">3</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/zwp233" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:zwp233@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#iOS2023%E5%B9%B4%E6%9C%80%E6%96%B0%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%E4%B8%AD%EF%BC%89"><span class="toc-number">1.</span> <span class="toc-text">iOS2023年最新面试题（持续更新中）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Excerpt"><span class="toc-number">1.1.</span> <span class="toc-text">Excerpt</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#iOS2023%E5%B9%B4%E6%9C%80%E6%96%B0%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%E4%B8%AD%EF%BC%89-2"><span class="toc-number">1.2.</span> <span class="toc-text">iOS2023年最新面试题（持续更新中）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#OC%E5%92%8CSwift%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80"><span class="toc-number">1.2.1.</span> <span class="toc-text">OC和Swift语言基础</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81-synthesize%E5%92%8C-dynamic%E5%88%86%E5%88%AB%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">1、@synthesize和@dynamic分别有什么作用？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81Swift%E5%92%8COC%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.2.1.2.</span> <span class="toc-text">2、Swift和OC的区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81Swift%E4%B8%ADstruct%E5%92%8Cclass%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.2.1.3.</span> <span class="toc-text">3、Swift中struct和class的区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E3%80%81KVC%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="toc-number">1.2.1.4.</span> <span class="toc-text">4、KVC实现原理？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5%E3%80%81KVO%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="toc-number">1.2.1.5.</span> <span class="toc-text">5、KVO的实现原理？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6%E3%80%81%E5%A6%82%E4%BD%95%E6%89%8B%E5%8A%A8%E8%A7%A6%E5%8F%91KVO%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="toc-number">1.2.1.6.</span> <span class="toc-text">6、如何手动触发KVO方法？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88Block%E7%94%A8copy%E5%85%B3%E9%94%AE%E5%AD%97%EF%BC%9F"><span class="toc-number">1.2.1.7.</span> <span class="toc-text">7、为什么Block用copy关键字？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8%E3%80%81-weak%E5%92%8Cassign%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%8C%E4%BB%80%E4%B9%88%E5%9C%BA%E6%99%AF%E4%B8%8B%E4%BD%BF%E7%94%A8%EF%BC%8C%E4%BB%A3%E7%90%86%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8weak%EF%BC%9F"><span class="toc-number">1.2.1.8.</span> <span class="toc-text">8、 weak和assign的区别，什么场景下使用，代理为什么使用weak？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9%E3%80%81load%E5%92%8Cinitialize%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.2.1.9.</span> <span class="toc-text">9、load和initialize的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10%E3%80%81%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3copy-on-write%EF%BC%9F"><span class="toc-number">1.2.1.10.</span> <span class="toc-text">10、如何理解copy-on-write？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#UI"><span class="toc-number">1.2.2.</span> <span class="toc-text">UI</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81UIView%E5%92%8CCALayer%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E8%81%94%E7%B3%BB%EF%BC%9F"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">1、UIView和CALayer的区别和联系？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81%E8%B0%88%E8%B0%88%E5%AF%B9UIResponder%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F"><span class="toc-number">1.2.2.2.</span> <span class="toc-text">2、谈谈对UIResponder的理解？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81loadView%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="toc-number">1.2.2.3.</span> <span class="toc-text">3、loadView的作用？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-number">1.2.3.</span> <span class="toc-text">内存管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RunLoop"><span class="toc-number">1.2.4.</span> <span class="toc-text">RunLoop</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81RunLoop-%E7%9A%84%E6%9C%AC%E8%B4%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.2.4.1.</span> <span class="toc-text">1、RunLoop 的本质是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81Runloop%E5%92%8C%E7%BA%BF%E7%A8%8B%E6%98%AF%E4%BB%80%E4%B9%88%E5%85%B3%E7%B3%BB%EF%BC%9F"><span class="toc-number">1.2.4.2.</span> <span class="toc-text">2、Runloop和线程是什么关系？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81Runloop%E7%9A%84%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%98%AF%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84%EF%BC%9F%E6%9C%89%E5%87%A0%E7%A7%8D%E8%BF%90%E8%A1%8C%E6%A8%A1%E5%BC%8F%EF%BC%88mode%EF%BC%89%EF%BC%9F%E6%AF%8F%E4%B8%AA%E8%BF%90%E8%A1%8C%E6%A8%A1%E5%BC%8F%E4%B8%8B%E9%9D%A2%E7%9A%84CFRunloopMode%E6%98%AF%E5%93%AA%E4%BA%9B%EF%BC%9F%E4%BB%96%E4%BB%AC%E5%88%86%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%E8%81%8C%E8%B4%A3%EF%BC%9F"><span class="toc-number">1.2.4.3.</span> <span class="toc-text">3、Runloop的底层数据结构是什么样的？有几种运行模式（mode）？每个运行模式下面的CFRunloopMode是哪些？他们分别是什么职责？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E3%80%81Runloop-%E7%9A%84%E7%9B%91%E5%90%AC%E7%8A%B6%E6%80%81%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%EF%BC%9F"><span class="toc-number">1.2.4.4.</span> <span class="toc-text">4、Runloop 的监听状态有哪几种？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5%E3%80%81Runloop-%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B%EF%BC%9F"><span class="toc-number">1.2.4.5.</span> <span class="toc-text">5、Runloop 的工作流程？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6%E3%80%81Runloop-%E6%9C%89%E5%93%AA%E4%BA%9B%E5%BA%94%E7%94%A8%EF%BC%9F"><span class="toc-number">1.2.4.6.</span> <span class="toc-text">6、Runloop 有哪些应用？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7%E3%80%81Runloop%E7%9A%84%E5%86%85%E6%A0%B8%E6%80%81%E5%92%8C%E7%94%A8%E6%88%B7%E6%80%81%EF%BC%9F"><span class="toc-number">1.2.4.7.</span> <span class="toc-text">7、Runloop的内核态和用户态？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8%E3%80%81%E7%82%B9%E5%87%BBAPP%E5%9B%BE%E6%A0%87%EF%BC%8C%E4%BB%8E%E7%A8%8B%E5%BA%8F%E5%90%AF%E5%8A%A8%E3%80%81%E8%BF%90%E8%A1%8C%E3%80%81%E9%80%80%E5%87%BA%E8%BF%99%E4%B8%AA%E8%BF%87%E7%A8%8B%E5%BD%93%E4%B8%AD%EF%BC%8C%E7%B3%BB%E7%BB%9F%E9%83%BD%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.2.4.8.</span> <span class="toc-text">8、点击APP图标，从程序启动、运行、退出这个过程当中，系统都发生了什么？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Runtime"><span class="toc-number">1.2.5.</span> <span class="toc-text">Runtime</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E6%A6%82%E5%BF%B5"><span class="toc-number">1.2.5.1.</span> <span class="toc-text">1、概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81Runtime-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0-weak-%E5%B1%9E%E6%80%A7%EF%BC%9F"><span class="toc-number">1.2.5.2.</span> <span class="toc-text">2、Runtime 如何实现 weak 属性？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81Runtime%E5%85%B7%E4%BD%93%E5%BA%94%E7%94%A8"><span class="toc-number">1.2.5.3.</span> <span class="toc-text">3、Runtime具体应用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E3%80%81Runtime%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E6%B5%81%E7%A8%8B%EF%BC%9F"><span class="toc-number">1.2.5.4.</span> <span class="toc-text">4、Runtime方法调用流程？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5%E3%80%81Runtime%E7%9A%84%E6%96%B9%E6%B3%95%E4%BA%A4%E6%8D%A2%E7%9A%84%E6%B5%81%E7%A8%8B%EF%BC%9F"><span class="toc-number">1.2.5.5.</span> <span class="toc-text">5、Runtime的方法交换的流程？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6%E3%80%81%E5%B8%B8%E8%A7%81%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="toc-number">1.2.5.6.</span> <span class="toc-text">6、常见方法？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C"><span class="toc-number">1.2.6.</span> <span class="toc-text">计算机网络</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E7%BD%91%E7%BB%9C%E4%B8%83%E5%B1%82%E5%8D%8F%E8%AE%AE"><span class="toc-number">1.2.6.1.</span> <span class="toc-text">1、网络七层协议</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81Http-%E5%92%8C-Https-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9FHttps%E4%B8%BA%E4%BB%80%E4%B9%88%E6%9B%B4%E5%8A%A0%E5%AE%89%E5%85%A8%EF%BC%9F"><span class="toc-number">1.2.6.2.</span> <span class="toc-text">2、Http 和 Https 的区别？Https为什么更加安全？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81HTTPS%E7%9A%84%E8%BF%9E%E6%8E%A5%E5%BB%BA%E7%AB%8B%E6%B5%81%E7%A8%8B%EF%BC%9F"><span class="toc-number">1.2.6.3.</span> <span class="toc-text">3、HTTPS的连接建立流程？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E3%80%81%E8%A7%A3%E9%87%8A%E4%B8%80%E4%B8%8B%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%EF%BC%9F"><span class="toc-number">1.2.6.4.</span> <span class="toc-text">4、解释一下三次握手和四次挥手？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5%E3%80%81TCP-%E5%92%8C-UDP%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.2.6.5.</span> <span class="toc-text">5、TCP 和 UDP的区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.2.6.6.</span> <span class="toc-text">多线程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.2.6.7.</span> <span class="toc-text">1、进程与线程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%9F"><span class="toc-number">1.2.6.8.</span> <span class="toc-text">2、什么是多线程？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BC%98%E7%82%B9%E5%92%8C%E7%BC%BA%E7%82%B9%EF%BC%9F"><span class="toc-number">1.2.6.9.</span> <span class="toc-text">3、多线程的优点和缺点？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C%E5%92%8C%E5%B9%B6%E5%8F%91%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.2.6.10.</span> <span class="toc-text">4、多线程的并行和并发有什么区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5%E3%80%81iOS%E4%B8%AD%E5%AE%9E%E7%8E%B0%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%A1%88%EF%BC%8C%E5%90%84%E8%87%AA%E6%9C%89%E4%BB%80%E4%B9%88%E7%89%B9%E7%82%B9%EF%BC%9F"><span class="toc-number">1.2.6.11.</span> <span class="toc-text">5、iOS中实现多线程的几种方案，各自有什么特点？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6%E3%80%81%E5%A4%9A%E4%B8%AA%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E5%AE%8C%E6%88%90%E5%90%8E%E6%89%A7%E8%A1%8C%E4%B8%8B%E4%B8%80%E6%AD%A5%EF%BC%9F"><span class="toc-number">1.2.6.12.</span> <span class="toc-text">6、多个网络请求完成后执行下一步？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7%E3%80%81%E5%A4%9A%E4%B8%AA%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E9%A1%BA%E5%BA%8F%E6%89%A7%E8%A1%8C%E5%90%8E%E6%89%A7%E8%A1%8C%E4%B8%8B%E4%B8%80%E6%AD%A5%EF%BC%9F"><span class="toc-number">1.2.6.13.</span> <span class="toc-text">7、多个网络请求顺序执行后执行下一步？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8%E3%80%81%E5%BC%82%E6%AD%A5%E6%93%8D%E4%BD%9C%E4%B8%A4%E7%BB%84%E6%95%B0%E6%8D%AE%E6%97%B6-%E6%89%A7%E8%A1%8C%E5%AE%8C%E7%AC%AC%E4%B8%80%E7%BB%84%E4%B9%8B%E5%90%8E-%E6%89%8D%E8%83%BD%E6%89%A7%E8%A1%8C%E7%AC%AC%E4%BA%8C%E7%BB%84%EF%BC%9F"><span class="toc-number">1.2.6.14.</span> <span class="toc-text">8、异步操作两组数据时, 执行完第一组之后, 才能执行第二组？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%AD%E7%9A%84%E6%AD%BB%E9%94%81%EF%BC%9F"><span class="toc-number">1.2.6.15.</span> <span class="toc-text">9、多线程中的死锁？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10%E3%80%81GCD%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="toc-number">1.2.6.16.</span> <span class="toc-text">10、GCD执行原理？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%B9%E7%9B%AE%E6%9E%B6%E6%9E%84"><span class="toc-number">1.2.7.</span> <span class="toc-text">项目架构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81MVC%E3%80%81MVVM%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.2.7.1.</span> <span class="toc-text">1、MVC、MVVM模式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#MVC%EF%BC%88Model%E3%80%81View%E3%80%81Controller%EF%BC%89"><span class="toc-number">1.2.7.1.1.</span> <span class="toc-text">MVC（Model、View、Controller）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#MVVM%EF%BC%88Model%E3%80%81Controller-View%E3%80%81ViewModel%EF%BC%89"><span class="toc-number">1.2.7.1.2.</span> <span class="toc-text">MVVM（Model、Controller&#x2F;View、ViewModel）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7"><span class="toc-number">1.2.8.</span> <span class="toc-text">调试技巧</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81LLDB%E5%B8%B8%E7%94%A8%E7%9A%84%E8%B0%83%E8%AF%95%E5%91%BD%E4%BB%A4%EF%BC%9F"><span class="toc-number">1.2.8.1.</span> <span class="toc-text">1、LLDB常用的调试命令？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81%E6%96%AD%E7%82%B9%E8%B0%83%E8%AF%95%EF%BC%9F"><span class="toc-number">1.2.8.2.</span> <span class="toc-text">2、断点调试？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81iOS-%E5%B8%B8%E8%A7%81%E7%9A%84%E5%B4%A9%E6%BA%83%E7%B1%BB%E5%9E%8B%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">1.2.8.3.</span> <span class="toc-text">3、iOS 常见的崩溃类型有哪些？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96"><span class="toc-number">1.2.9.</span> <span class="toc-text">性能优化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E9%80%A0%E6%88%90tableView%E5%8D%A1%E9%A1%BF%E7%9A%84%E5%8E%9F%E5%9B%A0%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">1.2.9.1.</span> <span class="toc-text">1、造成tableView卡顿的原因有哪些？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81%E5%A6%82%E4%BD%95%E6%8F%90%E5%8D%87-tableview-%E7%9A%84%E6%B5%81%E7%95%85%E5%BA%A6%EF%BC%9F"><span class="toc-number">1.2.9.2.</span> <span class="toc-text">2、如何提升 tableview 的流畅度？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81iOS-%E4%BF%9D%E6%8C%81%E7%95%8C%E9%9D%A2%E6%B5%81%E7%95%85%E7%9A%84%E6%8A%80%E5%B7%A7%EF%BC%9F"><span class="toc-number">1.2.9.3.</span> <span class="toc-text">3、iOS 保持界面流畅的技巧？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E3%80%81APP%E5%90%AF%E5%8A%A8%E6%97%B6%E9%97%B4%E5%BA%94%E4%BB%8E%E5%93%AA%E4%BA%9B%E6%96%B9%E9%9D%A2%E4%BC%98%E5%8C%96%EF%BC%9F"><span class="toc-number">1.2.9.4.</span> <span class="toc-text">4、APP启动时间应从哪些方面优化？</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/post/6db1ba4f.html" title="iOS面试题">iOS面试题</a><time datetime="2023-06-07T00:59:38.000Z" title="发表于 2023-06-07 08:59:38">2023-06-07</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/post/78b31bc4.html" title="佛山游记（五一）">佛山游记（五一）</a><time datetime="2023-04-27T02:00:00.000Z" title="发表于 2023-04-27 10:00:00">2023-04-27</time></div></div></div></div></div></div></main><footer id="footer" style="background: #0d0d0d"><div id="footer-wrap"><div class="copyright">&copy;2023 By Peter</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/pluginsSrc/@fancyapps/ui/dist/fancybox.umd.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><link rel="stylesheet" type="text/css" href="/pluginsSrc/katex/dist/katex.min.css"><script src="/pluginsSrc/katex/dist/contrib/copy-tex.min.js"></script><link rel="stylesheet" type="text/css" href="/pluginsSrc/katex/dist/contrib/copy-tex.css"><script>(() => {
  document.querySelectorAll('#article-container span.katex-display').forEach(item => {
    btf.wrap(item, 'div', { class: 'katex-wrap'})
  })
})()</script></div><script defer src="https://npm.elemecdn.com/jquery@latest/dist/jquery.min.js"></script><script defer data-pjax src="/js/cat.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>