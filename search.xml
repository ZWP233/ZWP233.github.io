<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Podfile</title>
      <link href="/post/8672b3c7.html"/>
      <url>/post/8672b3c7.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>iOS开发会经常用到cocoapods管理第三方，简单、方便、高效。如何集成cocoapods在<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fcocoapods.org%2F">cocoapods官网</a>和<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fguides.cocoapods.org%2Fsyntax%2Fpodfile.html">Podfile语法说明</a>会有详细介绍，本文我想介绍的是关于集成cocoapods时会用到的一个文件Podfile文件。</p><h2 id="什么是Podfile">什么是Podfile</h2><p>Podfile是一个规范，描述了一个或多个一套工程目标的依赖项</p><p>一个简单写法:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">target &#x27;MyApp&#x27; do</span><br><span class="line">  pod &#x27;AFNetworking&#x27;, &#x27;~&gt; 3.0&#x27;</span><br><span class="line">end</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这是最简单最普遍的写法，针对MyApp这个target引入AFNetworking这个依赖库，也是大家平时用的最多的一种方式。</p><p>下面是个更复杂的一个例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"># 下面两行是指明依赖库的来源地址</span><br><span class="line">source &#x27;https://github.com/CocoaPods/Specs.git&#x27;</span><br><span class="line">source &#x27;https://github.com/Artsy/Specs.git&#x27;</span><br><span class="line"></span><br><span class="line"># 说明平台是ios，版本是9.0</span><br><span class="line">platform :ios, &#x27;9.0&#x27;</span><br><span class="line"></span><br><span class="line"># 忽略引入库的所有警告（强迫症者的福音啊）</span><br><span class="line">inhibit_all_warnings!</span><br><span class="line"></span><br><span class="line"># 针对MyApp target引入AFNetworking</span><br><span class="line"># 针对MyAppTests target引入OCMock，</span><br><span class="line">target &#x27;MyApp&#x27; do </span><br><span class="line">    pod &#x27;AFNetworking&#x27;, &#x27;~&gt; 3.0&#x27; </span><br><span class="line">    target &#x27;MyAppTests&#x27; do</span><br><span class="line">       inherit! :search_paths </span><br><span class="line">       pod &#x27;OCMock&#x27;, &#x27;~&gt; 2.0.1&#x27; </span><br><span class="line">    end</span><br><span class="line">end</span><br><span class="line"># 这个是cocoapods的一些配置,官网并没有太详细的说明,一般采取默认就好了,也就是不写.</span><br><span class="line">post_install do |installer|       </span><br><span class="line">   installer.pods_project.targets.each do |target| </span><br><span class="line">     puts target.name </span><br><span class="line">   end</span><br><span class="line">end</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="主配置">主配置</h2><p><code>install!</code> 这个命令是cocoapods声明的一个安装命令，用于安装引入Podfile里面的依赖库。<br><code>install!</code> 这个命令还有一些个人设置选项，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">install! &#x27;cocoapods&#x27;, </span><br><span class="line">  :deterministic_uuids =&gt; false, </span><br><span class="line">  :integrate_targets =&gt; false</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>还支持其他的选项：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Supported Keys:</span><br><span class="line"></span><br><span class="line">:clean</span><br><span class="line"></span><br><span class="line">:deduplicate_targets</span><br><span class="line"></span><br><span class="line">:deterministic_uuids</span><br><span class="line"></span><br><span class="line">:integrate_targets</span><br><span class="line"></span><br><span class="line">:lock_pod_sources</span><br><span class="line"></span><br><span class="line">:share_schemes_for_development_pods</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>关于以上的配置，官网也没有一个确切的说明，以为我们只需用系统默认即可。</p><h2 id="Dependencies（依赖项）">Dependencies（依赖项）</h2><p>Podfile指定每个target的依赖项</p><ul><li><code>pod</code>指定特定的依赖库</li><li><code>podspec</code>可以提供一个API来创建podspecs</li><li><code>target</code>通过target指定依赖范围</li></ul><h4 id="pod-指定项目的依赖项">pod - 指定项目的依赖项</h4><p>依赖项规范是由Pod的名称和一个可选的版本组合一起。<br>1&gt; 如果后面不写依赖库的具体版本号，那么cocoapods会默认选取最新版本。</p><p>2&gt; 如果你想要特定的依赖库的版本，就需要在后面写上具体版本号，格式：</p><p>3&gt; 也可以指定版本范围</p><ul><li><code>&gt; 0.1</code> 高于0.1版本（不包含0.1版本）的任意一个版本</li><li><code>&gt;= 0.1</code> 高于0.1版本（包含0.1版本）的任意一个版本</li><li><code>&lt; 0.1</code> 低于0.1版本（不包含0.1版本）的任意一个</li><li><code>&lt;= 0.1</code>低于0.1版本（包含0.1版本）的任意一个</li><li><code>~&gt; 0.1.2</code> 版本 0.1.2的版本到0.2 ，不包括0.2。这个基于你指定的版本号的最后一个部分。这个例子等效于&gt;= 0.1.2并且 &lt;0.2.0，并且始终是你指定范围内的最新版本。</li></ul><p>关于版本形式规范详情请参考下面链接：<br><a href="https://links.jianshu.com/go?to=http%3A%2F%2Fsemver.org%2Flang%2Fzh-CN%2F">语义化版本</a></p><h4 id="Build-configurations（编译配置）">Build configurations（编译配置）</h4><p>默认情况下， 依赖项会被安装在所有target的build configuration中。为了调试或者处于其他原因，依赖项只能在给定的build configuration中被启用。<br>下面写法指明只有在Debug和Beta模式下才有启用配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pod &#x27;PonyDebugger&#x27;, :configurations =&gt; [&#x27;Debug&#x27;, &#x27;Beta&#x27;]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>或者，可以弄白名单只指定一个build configurations。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pod &#x27;PonyDebugger&#x27;, :configuration =&gt; &#x27;Debug&#x27;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>注意：默认情况下如果不指定具体生成配置，那么会包含在所有的配置中，如果你想具体指定就必须手动指明。</p><h4 id="Subspecs">Subspecs</h4><p>一般情况我们会通过依赖库的名称来引入，cocoapods会默认安装依赖库的所有内容。<br>我们也可以指定安装具体依赖库的某个子模块，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 仅安装QueryKit库下的Attribute模块</span><br><span class="line">pod &#x27;QueryKit/Attribute&#x27;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 仅安装QueryKit下的Attribute和QuerySet模块</span><br><span class="line">pod &#x27;QueryKit&#x27;, :subspecs =&gt; [&#x27;Attribute&#x27;, &#x27;QuerySet&#x27;]</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="Using-the-files-from-a-local-path-使用本地文件">Using the files from a local path (使用本地文件)</h4><p>我们也可以指定依赖库的来源地址。如果我们想引入我们本地的一个库，可以这样写：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pod &#x27;AFNetworking&#x27;, :path =&gt; &#x27;~/Documents/AFNetworking&#x27;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>使用这个选项后，Cocoapods会将给定的文件夹认为是Pod的源，并且在工程中直接引用这些文件。这就意味着你编辑的部分可以保留在CocoaPods安装中，如果我们更新本地AFNetworking里面的代码，cocoapods也会自动更新。</p><p>被引用的文件夹可以来自你喜爱的SCM，甚至当前仓库的一个git子模块</p><p>注意：Pod的podspec文件也应该被放在这个文件夹当中</p><h4 id="From-a-podspec-in-the-root-of-a-library-repository-引用仓库根目录的podspec">From a podspec in the root of a library repository (引用仓库根目录的podspec)</h4><p>有时我们需要引入依赖库指定的分支或节点，写法如下。</p><ul><li>引入master分支（默认）</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pod &#x27;AFNetworking&#x27;, :git =&gt; &#x27;https://github.com/gowalla/AFNetworking.git&#x27;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>引入指定的分支</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pod &#x27;AFNetworking&#x27;, :git =&gt; &#x27;https://github.com/gowalla/AFNetworking.git&#x27;, :branch =&gt; &#x27;dev&#x27;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>引入某个节点的代码</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pod &#x27;AFNetworking&#x27;, :git =&gt; &#x27;https://github.com/gowalla/AFNetworking.git&#x27;, :tag =&gt; &#x27;0.7.0&#x27;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>引入某个特殊的提交节点</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pod &#x27;AFNetworking&#x27;, :git =&gt; &#x27;https://github.com/gowalla/AFNetworking.git&#x27;, :commit =&gt; &#x27;082f8319af&#x27;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>需要特别注意的是，虽然这样将会满足任何在Pod中的依赖项通过其他Pods 但是podspec必须存在于仓库的根目录中。</p><h3 id="从外部引入podspec引入">从外部引入podspec引入</h3><p>podspec可以从另一个源库的地址引入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pod &#x27;JSONKit&#x27;, :podspec =&gt; &#x27;https://example.com/JSONKit.podspec&#x27;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="podspec">podspec</h4><p>使用给定podspec文件中定义的代码库的依赖关系。如果没有传入任何参数，podspec优先使用根目录，如果是其他情况必须在后面指明。(一般使用默认设置即可)例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 不指定表示使用根目录下的podspec，默认一般都会放在根目录下</span><br><span class="line">podspec</span><br><span class="line"># 如果podspec的名字与库名不一样，可以通过这样来指定</span><br><span class="line">podspec :name =&gt; &#x27;QuickDialog&#x27;</span><br><span class="line"># 如果podspec不是在根目录下，那么可以通过:path来指定路径</span><br><span class="line">podspec :path =&gt; &#x27;/Documents/PrettyKit/PrettyKit.podspec&#x27;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="target">target</h4><p>在给定的块内定义pod的target（Xcode工程中的target）和指定依赖的范围。一个target应该与Xcode工程的target有关联。默认情况下，target会包含定义在块外的依赖，除非指定不使用inherit!来继承（说的是嵌套的块里的继承问题）</p><ul><li>定义一个简单target <code>ZipApp</code>引入<code>SSZipArchive</code>库</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">target &#x27;ZipApp&#x27; do </span><br><span class="line">  pod &#x27;SSZipArchive&#x27;</span><br><span class="line">end</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>定义一个<code>ZipApp</code>target仅引入<code>SSZipArchive</code>库，定义<code>ZipAppTests</code>target 引入<code>Nimble</code>的同时也会继承<code>ZipApp</code>target里面的<code>SSZipArchive</code>库</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">target &#x27;ZipApp&#x27; do </span><br><span class="line">  pod &#x27;SSZipArchive&#x27; </span><br><span class="line">  target &#x27;ZipAppTests&#x27; do</span><br><span class="line">    inherit! :search_paths </span><br><span class="line">    pod &#x27;Nimble&#x27; </span><br><span class="line">  end</span><br><span class="line">end</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>target块中嵌套多个子块</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">target &#x27;ShowsApp&#x27; do</span><br><span class="line">    # ShowsApp 仅仅引入ShowsKit</span><br><span class="line">    pod &#x27;ShowsKit&#x27; </span><br><span class="line">    # 引入 ShowsKit 和 ShowTVAuth </span><br><span class="line">    target &#x27;ShowsTV&#x27; do </span><br><span class="line">        pod &#x27;ShowTVAuth&#x27; </span><br><span class="line">    end </span><br><span class="line">    # 引入了Specta和Expecta以及ShowsKit</span><br><span class="line">    target &#x27;ShowsTests&#x27; do </span><br><span class="line">        inherit! :search_paths </span><br><span class="line">        pod &#x27;Specta&#x27; </span><br><span class="line">        pod &#x27;Expecta&#x27; </span><br><span class="line">    end</span><br><span class="line">end</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="抽象target">抽象target</h4><p>定义一个新的抽象目标，它可以方便的用于目标依赖继承。</p><ul><li>简单写法</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">abstract_target &#x27;Networking&#x27; do</span><br><span class="line">    pod &#x27;AlamoFire&#x27; </span><br><span class="line">    target &#x27;Networking App 1&#x27; </span><br><span class="line">    target &#x27;Networking App 2&#x27;</span><br><span class="line">end</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>定义一种abstract_target包含多个target</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># 注意：这是个抽象的target也就是说在工程中并没有这个target引入ShowsKit</span><br><span class="line">abstract_target &#x27;Shows&#x27; do</span><br><span class="line">    pod &#x27;ShowsKit&#x27;</span><br><span class="line">    # ShowsiOS target会引入ShowWebAuth库以及继承自Shows的ShowsKit库</span><br><span class="line">    target &#x27;ShowsiOS&#x27; do</span><br><span class="line">        pod &#x27;ShowWebAuth&#x27;</span><br><span class="line">    end</span><br><span class="line">    # ShowsTV target会引入ShowTVAuth库以及继承自Shows的ShowsKit库</span><br><span class="line">    target &#x27;ShowsTV&#x27; do</span><br><span class="line">        pod &#x27;ShowTVAuth&#x27;</span><br><span class="line">    end</span><br><span class="line">    # ShowsTests target引入了Specta和Expecta库，并且指明继承Shows，所以也会引入ShowsKit</span><br><span class="line">    target &#x27;ShowsTests&#x27; do</span><br><span class="line">        inherit! :search_paths </span><br><span class="line">        pod &#x27;Specta&#x27; </span><br><span class="line">        pod &#x27;Expecta&#x27; </span><br><span class="line">    end</span><br><span class="line">end</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="abstract-和-inherit">abstract! 和 inherit!</h4><ul><li>abstract! 指示当前的target是抽象的，因此不会直接链接Xcode target。</li><li>inherit! 设置当前target的继承模式。例如：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">target &#x27;App&#x27; do</span><br><span class="line">   target &#x27;AppTests&#x27; do</span><br><span class="line">      inherit! :search_paths </span><br><span class="line">   end</span><br><span class="line">end</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Target-configuration-目标项配置">Target configuration (目标项配置)</h2><p>使用target 配置来控制的cocoapods生成project。<br>开始时详细说明您正在使用什么平台上。工程文件里允许您具体说明哪些项目的链接。</p><h4 id="platform">platform</h4><p>platform用于指定应建立的静态库的平台。CocoaPods提供了默认的平台版本配置：</p><ul><li>iOS-&gt;4.3</li><li>OS X-&gt;10.6</li><li>tvOS-&gt;9.0</li><li>watchOS-&gt;2.0</li></ul><p>如果部署目标需要iOS &lt; 4.3，armv6体系结构将被添加到ARCHS。<br>例如:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#指定具体平台和版本</span><br><span class="line">platform :ios, &#x27;4.0&#x27;</span><br><span class="line">platform :ios</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="project">project</h4><p>如果没有显示的project被指定，那么会默认使用target的父target指定的project作为目标。如果如果没有任何一个target指定目标，那么就会使用和Podefile在同一目录下的project。同样也能够指定是否这些设置在release或者debug模式下生效。为了做到这一点，你必须指定一个名字和:release/:debuge关联起来</p><p>Examples:<br>Specifying the user project</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># MyGPSApp这个target引入的库只能在FastGPS工程中引用</span><br><span class="line">target &#x27;MyGPSApp&#x27; do </span><br><span class="line">    project &#x27;FastGPS&#x27; </span><br><span class="line">    ...</span><br><span class="line">end</span><br><span class="line"># 原理同上</span><br><span class="line">target &#x27;MyNotesApp&#x27; do </span><br><span class="line">    project &#x27;FastNotes&#x27; </span><br><span class="line">    ...</span><br><span class="line">end</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>使用自定义的编译配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">project &#x27;TestProject&#x27;, &#x27;Mac App Store&#x27; =&gt; :release, &#x27;Test&#x27; =&gt; :debug</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="inhibit-all-warnings-（强迫症者的福音）">inhibit_all_warnings!（强迫症者的福音）</h4><p>inhibit_all_warnings! 屏蔽所有来自于cocoapods依赖库的警告。你可以全局定义，也能在子target里面定义，也可以指定某一个库：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 隐藏SSZipArchive的警告而不隐藏ShowTVAuth的警告</span><br><span class="line">pod &#x27;SSZipArchive&#x27;, :inhibit_warnings =&gt; true</span><br><span class="line">pod &#x27;ShowTVAuth&#x27;, :inhibit_warnings =&gt; false</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="use-frameworks">use_frameworks!</h4><p>通过指定use_frameworks!要求生成的是framework而不是静态库。<br>如果使用use_frameworks!命令会在Pods工程下的Frameworks目录下生成依赖库的framework<br>如果不使用use_frameworks!命令会在Pods工程下的Products目录下生成.a的静态库</p><h2 id="Workspace">Workspace</h2><p>默认情况下，我们不需要指定，直接使用与Podfile所在目录的工程名一样就可以了。如果要指定另外的名称，而不是使用工程的名称，可以这样指定：</p><h2 id="Source">Source</h2><p>source是指定pod的来源。如果不指定source，默认是使用CocoaPods官方的source。(建议使用默认设置)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CocoaPods Master Repository</span><br><span class="line"># 使用其他来源地址</span><br><span class="line">source &#x27;https://github.com/artsy/Specs.git&#x27;</span><br><span class="line"># 使用官方默认地址（默认）</span><br><span class="line">source &#x27;https://github.com/CocoaPods/Specs.git&#x27;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Hooks">Hooks</h2><p>Podfile提供了hook机制，它将在安装过程中调用。hook是全局性的，不存储于每个target中。</p><h3 id="Plugin">Plugin</h3><p>指定应在安装期间使用的插件。使用此方法指定应在安装期间使用的插件，以及当它被调用时，应传递给插件的选项。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 指定在安装期间使用cocoapods-keys和slather这两个插件</span><br><span class="line">plugin &#x27;cocoapods-keys&#x27;, :keyring =&gt; &#x27;Eidolon&#x27;</span><br><span class="line">plugin &#x27;slather&#x27;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="pre-install">pre_install</h4><p>当我们下载完成，但是还没有安装之时，可以使用hook机制通过pre_install指定要做更改，更改完之后进入安装阶段。<br>格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pre_install do |installer| </span><br><span class="line">    # 做一些安装之前的更改</span><br><span class="line">end</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="post-install">post_install</h4><p>当我们安装完成，但是生成的工程还没有写入磁盘之时，我们可以指定要执行的操作。<br>比如，我们可以在写入磁盘之前，修改一些工程的配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">post_install do |installer| installer.pods_project.targets.each do |target| </span><br><span class="line">        target.build_configurations.each do |config| </span><br><span class="line">            config.build_settings[&#x27;GCC_ENABLE_OBJC_GC&#x27;] = &#x27;supported&#x27; </span><br><span class="line">        end </span><br><span class="line">    end</span><br><span class="line">end</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="def">def</h4><p>我们还可以通过def命令来声明一个pod集：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def &#x27;CustomPods&#x27;</span><br><span class="line">   pod &#x27;IQKeyboardManagerSwift&#x27;</span><br><span class="line">end </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后，我们就可以在需要引入的target处引入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">target &#x27;MyTarget&#x27; do </span><br><span class="line">   CustomPods</span><br><span class="line">end </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这么写的好处是：如果有多个target，而不同target之间并不全包含，那么可以通过这种方式来分开引入。</p><h2 id="总结">总结</h2><p>本文主要介绍Podfile文件的一些要素，也是自己的一个学习记录过程，由于本人水平有限，难免会有纰漏之处，还望指出。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MacOS终端利器iTerm2</title>
      <link href="/post/db3cbb2c.html"/>
      <url>/post/db3cbb2c.html</url>
      
        <content type="html"><![CDATA[<p><a href="http://zwp233.top/post/db3cbb2c/webp-20230609105120325"><img src="http://zwp233.top/post/db3cbb2c/webp-20230609105120325" alt=""></a></p><p>image</p><blockquote><p>Mac OS 终端利器 iTerm2  image 之前一直使用 Mac OS 自带的终端，用起来虽然有些不太方便，但总体来说还是可以接受的，是有想换个终端的想法，然后今天偶然看到一个终端利器 iTerm2，发现真的很强大，也非常的好用，按照网上配置了主题什么的，还是有些坑的，这边再记录下，以便后面查阅。 安装 iTerm2 下载地址：<a href="https://www.iterm2.com/download">https://www.iterm2.com/download</a></p></blockquote><h2 id="1-安装-iTerm2">1. 安装 iTerm2</h2><p>下载地址：<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fwww.iterm2.com%2Fdownloads.html">https://www.iterm2.com/downloads.html</a></p><p>下载的是压缩文件，解压后是执行程序文件，你可以直接双击，或者直接将它拖到 Applications 目录下。</p><p>或者你可以直接使用 Homebrew 进行安装：</p><h2 id="2-配置-iTerm2-主题">2. 配置 iTerm2 主题</h2><p>iTerm2 最常用的主题是 Solarized Dark theme，下载地址：<a href="https://links.jianshu.com/go?to=http%3A%2F%2Fethanschoonover.com%2Fsolarized">http://ethanschoonover.com/solarized</a></p><p>下载的是压缩文件，你先解压一下，然后打开 iTerm2，按<code>Command + ,</code>键，打开 Preferences 配置界面，然后<code>Profiles -&gt; Colors -&gt; Color Presets -&gt; Import</code>，选择刚才解压的<code>solarized-&gt;iterm2-colors-solarized-&gt;Solarized Dark.itermcolors</code>文件，导入成功，最后选择 Solarized Dark 主题，就可以了。</p><p><a href="http://zwp233.top/post/db3cbb2c/webp-20230609105120380"><img src="http://zwp233.top/post/db3cbb2c/webp-20230609105120380" alt=""></a></p><p>image</p><h2 id="3-配置-Oh-My-Zsh">3. 配置 Oh My Zsh</h2><p>Oh My Zsh 是对主题的进一步扩展，地址：<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Frobbyrussell%2Foh-my-zsh">https://github.com/robbyrussell/oh-my-zsh</a></p><p>一键安装：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sh -c &quot;$(curl -fsSL https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh)&quot;</span><br></pre></td></tr></table></figure><p>安装好之后，需要把 Zsh 设置为当前用户的默认 Shell（这样新建标签的时候才会使用 Zsh）：</p><p>然后，我们编辑<code>vim ~/.zshrc</code>文件，将主题配置修改为<code>ZSH_THEME=&quot;agnoster&quot;</code>。</p><p><a href="http://zwp233.top/post/db3cbb2c/webp-20230609105120348"><img src="http://zwp233.top/post/db3cbb2c/webp-20230609105120348" alt=""></a></p><p>image</p><p><code>agnoster</code>是比较常用的 zsh 主题之一，你可以挑选你喜欢的主题，zsh 主题列表：<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Frobbyrussell%2Foh-my-zsh%2Fwiki%2Fthemes">https://github.com/robbyrussell/oh-my-zsh/wiki/themes</a></p><p>效果如下（配置了声明高亮）：</p><p><a href="http://zwp233.top/post/db3cbb2c/webp-20230609105120414"><img src="http://zwp233.top/post/db3cbb2c/webp-20230609105120414" alt=""></a></p><p>image</p><h2 id="4-配置-Meslo-字体">4. 配置 Meslo 字体</h2><p>使用上面的主题，需要 Meslo 字体支持，要不然会出现乱码的情况，字体下载地址：<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Fpowerline%2Ffonts%2Fblob%2Fmaster%2FMeslo%2520Slashed%2FMeslo%2520LG%2520M%2520Regular%2520for%2520Powerline.ttf">Meslo LG M Regular for Powerline.ttf</a></p><p>下载好之后，直接在 Mac OS 中安装即可。</p><p>然后打开 iTerm2，按<code>Command + ,</code>键，打开 Preferences 配置界面，然后<code>Profiles -&gt; Text -&gt; Font -&gt; Chanage Font</code>，选择 Meslo LG M Regular for Powerline 字体。</p><p><a href="http://zwp233.top/post/db3cbb2c/webp-20230609105120374"><img src="http://zwp233.top/post/db3cbb2c/webp-20230609105120374" alt=""></a></p><p>image</p><p>当然，如果你觉得默认的<code>12px</code>字体大小不合适，可以自己进行修改。</p><p>另外，VS Code 的终端字体，也需要进行配置，打开 VS Code，按<code>Command + ,</code>键，打开用户配置，搜索<code>fontFamily</code>，然后将右边的配置增加<code>&quot;terminal.integrated.fontFamily&quot;: &quot;Meslo LG M for Powerline&quot;</code>，示例：</p><p><a href="http://zwp233.top/post/db3cbb2c/webp-20230609105120359"><img src="http://zwp233.top/post/db3cbb2c/webp-20230609105120359" alt=""></a></p><p>image</p><h2 id="5-声明高亮">5. 声明高亮</h2><p>效果就是上面截图的那样，特殊命令和错误命令，会有高亮显示。</p><p>使用 Homebrew 安装：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ brew install zsh-syntax-highlighting</span><br></pre></td></tr></table></figure><p>安装成功之后，编辑<code>vim ~/.zshrc</code>文件，在最后一行增加下面配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source /usr/local/share/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh</span><br></pre></td></tr></table></figure><p><a href="http://zwp233.top/post/db3cbb2c/webp-20230609105120418"><img src="http://zwp233.top/post/db3cbb2c/webp-20230609105120418" alt=""></a></p><p>image</p><h2 id="6-自动建议填充">6. 自动建议填充</h2><p>这个功能是非常实用的，可以方便我们快速的敲命令。</p><p>配置步骤，先克隆<code>zsh-autosuggestions</code>项目，到指定目录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git clone https://github.com/zsh-users/zsh-autosuggestions ~/.oh-my-zsh/custom/plugins/zsh-autosuggestions</span><br></pre></td></tr></table></figure><p>然后编辑<code>vim ~/.zshrc</code>文件，找到<code>plugins</code>配置，增加<code>zsh-autosuggestions</code>插件。</p><p><a href="http://zwp233.top/post/db3cbb2c/webp-20230609105120421"><img src="http://zwp233.top/post/db3cbb2c/webp-20230609105120421" alt=""></a></p><p>image</p><p>注：上面声明高亮，如果配置不生效的话，在<code>plugins</code>配置，再增加<code>zsh-syntax-highlighting</code>插件试试。</p><p>有时候因为自动填充的颜色和背景颜色很相似，以至于自动填充没有效果，我们可以手动更改下自动填充的颜色配置，我修改的颜色值为：<code>586e75</code>，示例：</p><p><a href="http://zwp233.top/post/db3cbb2c/webp-20230609105120428"><img src="http://zwp233.top/post/db3cbb2c/webp-20230609105120428" alt=""></a></p><p>image</p><p>效果：</p><p><a href="http://zwp233.top/post/db3cbb2c/webp-20230609105120430"><img src="http://zwp233.top/post/db3cbb2c/webp-20230609105120430" alt=""></a></p><p>image</p><h2 id="7-左右键跳转">7. 左右键跳转</h2><p>主要是按住<code>option + → or ←</code>键，在命令的开始和结尾跳转切换，原本是不生效的，需要手动开启下。</p><p>打开 iTerm2，按<code>Command + ,</code>键，打开 Preferences 配置界面，然后<code>Profiles → Keys → Load Preset... → Natural Text Editing</code>，就可以了。</p><h2 id="8-iTerm2-快速隐藏和显示">8. iTerm2 快速隐藏和显示</h2><p>这个功能也非常使用，就是通过快捷键，可以快速的隐藏和打开 iTerm2，示例配置（<code>Commond + .</code>）：</p><p><a href="http://zwp233.top/post/db3cbb2c/webp-20230609105120463"><img src="http://zwp233.top/post/db3cbb2c/webp-20230609105120463" alt=""></a></p><p>image</p><h2 id="9-iTerm2-隐藏用户名和主机名">9. iTerm2 隐藏用户名和主机名</h2><p>有时候我们的用户名和主机名太长，比如我的<code>xishuai@xishuaideMacBook-Pro</code>，终端显示的时候会很不好看（上面图片中可以看到），我们可以手动去除。</p><p>编辑<code>vim ~/.zshrc</code>文件，增加<code>DEFAULT_USER=&quot;xishuai&quot;</code>配置，示例：</p><p><a href="http://zwp233.top/post/db3cbb2c/webp-20230609105120471"><img src="http://zwp233.top/post/db3cbb2c/webp-20230609105120471" alt=""></a></p><p>image</p><p>我们可以通过<code>whoami</code>命令，查看当前用户，效果（另外分屏的效果）：</p><p><a href="http://zwp233.top/post/db3cbb2c/webp-20230609105120475"><img src="http://zwp233.top/post/db3cbb2c/webp-20230609105120475" alt=""></a></p><p>image</p><h2 id="10-iTerm2-配置代理">10. iTerm2 配置代理</h2><p>编辑<code>~ vim ~/.zshrc</code>，增加下面配置（使用的 shadowsocks）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># proxy list</span><br><span class="line">alias proxy=&#x27;export all_proxy=socks5://127.0.0.1:1086&#x27;</span><br><span class="line">alias unproxy=&#x27;unset all_proxy&#x27;</span><br></pre></td></tr></table></figure><p>iTerm2 需要新建标签页，才有效果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ proxy</span><br><span class="line">$ curl ip.cn</span><br><span class="line">当前 IP：185.225.14.5 来自：美国</span><br><span class="line"></span><br><span class="line">$ unproxy</span><br><span class="line">$ curl ip.cn</span><br><span class="line">当前 IP：115.236.186.130 来自：浙江省杭州市 电信</span><br></pre></td></tr></table></figure><p>我们可以测试下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ curl https://packages.cloud.google.com/yum/repos/kubernetes-el7-x86_64</span><br><span class="line"></span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;title&gt;Directory listing for /yum/repos/kubernetes-el7-x86_64/&lt;/title&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;h2&gt;Index of /yum/repos/kubernetes-el7-x86_64/&lt;/h2&gt;</span><br><span class="line">    &lt;p&gt;&lt;/p&gt;</span><br><span class="line">    &lt;a href=&quot;/yum/repos/kubernetes-el7-x86_64/repodata&quot;&gt;repodata&lt;/a&gt;&lt;br /&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h2 id="11-iTerm2-快捷命令">11. iTerm2 快捷命令</h2><p>快捷命令说明：</p><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>command + t</td><td>新建标签</td></tr><tr><td>command + w</td><td>关闭标签</td></tr><tr><td>command + 数字 command + 左右方向键</td><td>切换标签</td></tr><tr><td>command + enter</td><td>切换全屏</td></tr><tr><td>command + f</td><td>查找</td></tr><tr><td>command + d</td><td>垂直分屏</td></tr><tr><td>command + shift + d</td><td>水平分屏</td></tr><tr><td>command + option + 方向键 command + [ 或 command + ]</td><td>切换屏幕</td></tr><tr><td>command + ;</td><td>查看历史命令</td></tr><tr><td>command + shift + h</td><td>查看剪贴板历史</td></tr><tr><td>ctrl + u</td><td>清除当前行</td></tr><tr><td>ctrl + l</td><td>清屏</td></tr><tr><td>ctrl + a</td><td>到行首</td></tr><tr><td>ctrl + e</td><td>到行尾</td></tr><tr><td>ctrl + f/b</td><td>前进后退</td></tr><tr><td>ctrl + p</td><td>上一条命令</td></tr><tr><td>ctrl + r</td><td>搜索命令历史</td></tr></tbody></table><p>参考资料：</p><ul><li><a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgist.github.com%2Fkevin-smets%2F8568070">iTerm2 + Oh My Zsh + Solarized color scheme + Meslo powerline font + [Powerlevel9k] - (macOS)</a>（<strong>推荐</strong>）</li><li><a href="https://www.jianshu.com/p/0ff3269bc261">iTerm2 + oh my zsh + solarized + Meslo powerline font (OS X / macOS)</a></li><li><a href="https://links.jianshu.com/go?to=http%3A%2F%2Fzhuxin.tech%2F2017%2F09%2F21%2Fzsh%25E9%2585%258D%25E7%25BD%25AE%2F">Mac 下终端配置（item2 + oh-my-zsh + solarized 配色方案）</a></li><li><a href="https://links.jianshu.com/go?to=https%3A%2F%2Fwww.zybuluo.com%2FSweetfish%2Fnote%2F636550">MAC 下 iTerm 主题配置</a></li><li><a href="https://links.jianshu.com/go?to=https%3A%2F%2Fcnbin.github.io%2Fblog%2F2015%2F06%2F20%2Fiterm2-kuai-jie-jian-da-quan%2F">iTerm2 快捷键大全</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cocoapod安装</title>
      <link href="/post/8a163dc8.html"/>
      <url>/post/8a163dc8.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>一.</p></blockquote><p>1.在装之前最好先卸载点老版本</p><p><code>$ sudo gem uninstall cocoapods</code></p><p>2.查看本地安装过的cocopods相关东西</p><p><code>$ gem list --local | grep cocoapods</code></p><p>显示如下:</p><p>cocoapods (1.0.1)</p><p>cocoapods-core (1.0.1)</p><p>cocoapods-deintegrate (1.0.1)</p><p>cocoapods-downloader (1.1.1)</p><p>cocoapods-plugins (1.0.0)</p><p>cocoapods-search (1.0.0)</p><p>cocoapods-stats (1.0.0)</p><p>cocoapods-trunk (1.0.0)</p><p>cocoapods-try (1.1.0)</p><p>然后使用命令逐个删除</p><p><code>$ sudo gem uninstall cocoapods-core</code></p><p><code>$ sudo gem uninstall cocoapods-deintegrate</code><br>…<br>或者找出目前版本的pod路径</p><p><code>$ which pod</code></p><p>移除现有pod</p><p><code>$ rm -rf /usr/local/bin/pod</code></p><p>删除完之后接下来安装RVM</p><p>RVM 是干什么的这里就不解释了，后面你将会慢慢搞明白。<br><code>$ curl -L https://get.rvm.io | bash -s stable</code></p><p>然后，载入 RVM 环境<br><code>$ source ~/.rvm/scripts/rvm</code></p><p>检查一下是否安装正确<br><code>$ rvm -v</code><br>rvm 1.29.7 (latest) by Michal Papis, Piotr Kuczynski, Wayne E. Seguin [<a href="https://links.jianshu.com/go?to=https%3A%2F%2Frvm.io%255D">https://rvm.io]</a></p><p>用RVM安装Ruby环境</p><p>可以先查询已经安装的ruby<br><code>$ rvm list</code></p><p>卸载一个已安装版本<br><code>$ rvm remove 2.4.0</code></p><p>列出已知的ruby版本<br><code>$ rvm list known</code></p><p>可以选择现有的rvm版本来进行安装（下面以rvm 2.6.0版本的安装为例）<br><code>$ rvm install 2.6.0</code></p><p>这里需要等上一段时间</p><p>设置Ruby版本<br>RVM 装好以后，需要执行下面的命令将指定版本的 Ruby 设置为系统默认版本<br><code>$ rvm 2.6.0 --default</code></p><p>同样，也可以用其他版本号，前提是你有用 rvm install 安装过那个版本<br>这个时候你可以测试是否正确<br><code>$ ruby -v</code></p><p>ruby 2.6.0p0 (2018-12-25 revision 66547) [x86_64-darwin18]</p><p>三</p><p>安装 coocapods 其实也需要FQ的,这里不多说了,直接切换到淘宝镜像服务器</p><p>查询：<br><code>$ gem sources -l</code><br>可以查看当前是什么连接，然后替换方式如下：<br><code>$ gem source -r https://gems.ruby-china.org</code><br><code>$ gem sources --add https://gems.ruby-china.com</code></p><p>要想验证是否替换成功了，可以执行：<br><code>$ gem sources -l</code></p><p>成功显示</p><p>*** CURRENT SOURCES ***</p><p><a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgems.ruby-china.com%2F">https://gems.ruby-china.com/</a></p><p>四</p><p>这里开始安装 cocoapods</p><p><code>$ sudo gem install cocoapods</code> 差不多过个几十秒吧</p><p>会提示:gems installed</p><p><code>$ pod setup</code></p><p>Terminal会停留在 Setting up CocoaPods master repo 这个状态一段时间,是因为要进行下载安装,而且目录比较大,需要耐心等待一下</p><p>看到最后一条</p><p>五 coocapods 的使用,</p><p>使用 xcode 创建一个项目 然后cd 进入文件夹</p><p>执行命令 <code>touch Podfile</code> 创建 podfile 文件</p><p>打开 podfile文件 <code>open -e Podfile</code> ,或者拖动文件直接使用 xcode打开</p><p>在文件中输入</p><p>platform :ios, ‘8.1’</p><p>//这里不写版本号,默认是下载最新的</p><p>pod ‘AFNetworking’</p><p>注意:新版本要加上下面两句话</p><p>target “项目的名称” do<br>end</p><p>注意：'项目名称’是你项目文件中’xx.xcodeproj’文件，'xx.xcodeproj’去掉后缀名所得的‘xx’==（就是）‘你的项目名称’</p><p>如果不加会报以下错误</p><p>[!] The dependency <code>AFNetworking (~&gt; 3.0)</code> is not used in any concrete target.</p><p>最后执行命令:</p><p><code>pod install</code></p><p>或</p><p><code>pod install --verbose --no-repo-update</code></p><p>verbose此参数可以显示命令执行过程中的详细信息</p><p>pod install或pod update可能会卡在Analyzing dependencies步骤，因为这两个命令会升级 CocoaPods 的 spec 仓库，追加该参数可以省略此步骤，提升命令执行速度。</p><p>完成.</p><p>如后面需添加新的库 使用 <code>pod search SDWebImage</code></p><p>搜索你需要找的库</p><p>然后 <code>pod update</code> 更新就好了</p>]]></content>
      
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git</title>
      <link href="/post/518e617c.html"/>
      <url>/post/518e617c.html</url>
      
        <content type="html"><![CDATA[<p>如果你正在使用Mac做开发，有两种安装Git的方法。</p><p>一是安装homebrew，然后通过homebrew安装Git，具体方法请参考homebrew的文档：<a href="https://links.jianshu.com/go?to=http%3A%2F%2Fbrew.sh%2F">http://brew.sh/</a>。</p><p>第二种方法更简单，也是推荐的方法，就是直接从AppStore安装Xcode，Xcode集成了Git，不过默认没有安装，你需要运行Xcode，选择菜单“Xcode”-&gt;“Preferences”，在弹出窗口中找到“Downloads”，选择“Command Line Tools”，点“Install”就可以完成安装了。</p><h3 id="二-创建版本库">二.创建版本库</h3><p>初始化一个Git仓库，使用<code>git init</code>命令。</p><p>添加文件到Git仓库，分两步：</p><p>使用命令<code>git add &lt;file&gt;</code>，注意，可反复多次使用，添加多个文件；<br>使用命令<code>git commit -m &lt;message&gt;</code>，完成。</p><h3 id="三-时光机穿梭">三.时光机穿梭</h3><p>要随时掌握工作区的状态，使用<code>git status</code>命令。</p><p>如果git status告诉你有文件被修改过，用<code>git diff</code>可以查看修改内容。</p><h4 id="1-版本回退">1.版本回退</h4><p>HEAD指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard commit_id</span><br></pre></td></tr></table></figure><p>回退到上一版本：</p><p>穿梭前，用<code>git log</code>可以查看提交历史，以便确定要回退到哪个版本。如果嫌输出信息太多，看得眼花缭乱的，可以试试加上<code>--pretty=oneline</code>参数</p><p>要重返未来，用<code>git reflog</code>查看命令历史，以便确定要回到未来的哪个版本。</p><h4 id="2-撤销修改">2.撤销修改</h4><p>场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令<code>git checkout -- file</code>。</p><p>场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令<code>git reset HEAD &lt;file&gt;</code>，就回到了场景1，第二步按场景1操作。</p><p>场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，参考版本回退一节，不过前提是没有推送到远程库。</p><h4 id="3-删除文件">3.删除文件</h4><p>本地仓库删除了文件或者<code>rm &lt;file&gt;</code></p><p>现在你有两个选择：<br>一是确实要从版本库中删除该文件，那就用命令<code>git rm</code>删掉，并且<code>git commit</code>:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git rm test.txt</span><br><span class="line">rm &#x27;test.txt&#x27;</span><br><span class="line"></span><br><span class="line">$ git commit -m &quot;remove test.txt&quot;</span><br><span class="line">[master d46f35e] remove test.txt</span><br><span class="line"> 1 file changed, 1 deletion(-)</span><br><span class="line"> delete mode 100644 test.txt</span><br></pre></td></tr></table></figure><p>文件就从版本库中被删除了</p><p>二是删错了，因为版本库里还有呢，所以可以很轻松地把误删的文件恢复到最新版本：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -- test.txt</span><br></pre></td></tr></table></figure><p><code>git checkout</code>其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。</p><p>注意：从来没有被添加到版本库就被删除的文件，是无法恢复的！</p><p>命令<code>git rm</code>用于删除一个文件。如果一个文件已经被提交到版本库，那么你永远不用担心误删，但是要小心，你只能恢复文件到最新版本，你会丢失最近一次提交后你修改的内容。</p><h3 id="四-远程仓库">四.远程仓库</h3><p>获得GitHub远程仓库<br>第1步：创建SSH Key。在用户主目录(user)下，看看有没有.ssh目录，如果有，再看看这个目录下有没有id_rsa和id_rsa.pub这两个文件，如果已经有了，可直接跳到下一步。如果没有，打开Shell（Windows下打开Git Bash），创建SSH Key：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-keygen -t rsa -C &quot;xxxxx@mail.com&quot;</span><br></pre></td></tr></table></figure><p>你需要把邮件地址换成你自己的邮件地址，然后一路回车，使用默认值即可，由于这个Key也不是用于军事目的，所以也无需设置密码。</p><p>如果一切顺利的话，可以在用户主目录里找到.ssh目录，里面有id_rsa和id_rsa.pub两个文件，这两个就是SSH Key的秘钥对，id_rsa是私钥，不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人。</p><p>第2步：登陆<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2F">GitHub</a>，点击右上角头像，选择<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Fsettings%2Fprofile">Settings</a>，<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Fsettings%2Fkeys">SSH and GPG keys</a>页面;</p><p>然后，点<code>New SSH Key</code>，填上任意Title，在Key文本框里粘贴id_rsa.pub文件的内容;</p><p>点<code>Add SSH Key</code>，你就应该看到已经添加的Key;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">为什么GitHub需要SSH Key呢？因为GitHub需要识别出你推送的提交确实是你推送的，而不是别人冒充的，而Git支持SSH协议，所以，GitHub只要知道了你的公钥，就可以确认只有你自己才能推送。</span><br><span class="line"></span><br><span class="line">当然，GitHub允许你添加多个Key。假定你有若干电脑，你一会儿在公司提交，一会儿在家里提交，只要把每台电脑的Key都添加到GitHub，就可以在每台电脑上往GitHub推送了。</span><br><span class="line"></span><br><span class="line">最后友情提示，在GitHub上免费托管的Git仓库，任何人都可以看到喔（但只有你自己才能改）。所以，不要把敏感信息放进去。</span><br><span class="line"></span><br><span class="line">如果你不想让别人看到Git库，有两个办法，一个是交点保护费，让GitHub把公开的仓库变成私有的，这样别人就看不见了（不可读更不可写）。另一个办法是自己动手，搭一个Git服务器，因为是你自己的Git服务器，所以别人也是看不见的。这个方法我们后面会讲到的，相当简单，公司内部开发必备。</span><br></pre></td></tr></table></figure><h4 id="1-添加远程库">1.添加远程库</h4><p>现在的情景是，你已经在本地创建了一个Git仓库后，又想在GitHub创建一个Git仓库，并且让这两个仓库进行远程同步，这样，GitHub上的仓库既可以作为备份，又可以让其他人通过该仓库来协作，真是一举多得。</p><p>首先，登陆<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2F">GitHub</a>，然后，在右上角+号找到<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Fnew">New repository</a>按钮，创建一个新的仓库;</p><p>在Repository name填入仓库名<code>learngit</code>，其他保持默认设置，点击<code>Create repository</code>按钮，就成功地创建了一个新的Git仓库;</p><p>目前，在GitHub上的这个<code>learngit</code>仓库还是空的，GitHub告诉我们，可以从这个仓库克隆出新的仓库，也可以把一个已有的本地仓库与之关联，然后，把本地仓库的内容推送到GitHub仓库。</p><p>现在，我们根据GitHub的提示，在本地的<code>learngit</code>仓库下运行命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git remote add origin git@github.com:xxxxx/learngit.git</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>请千万注意，把上面的<code>xxxxx</code>替换成你自己的<code>GitHub账户名</code>，否则，你在本地关联的就是别人的远程库，关联没有问题，但是你以后推送是推不上去的，因为你的SSH Key公钥不在别人的账户列表中。</p><p>添加后，远程库的名字就是<code>origin</code>，这是Git默认的叫法，也可以改成别的，但是<code>origin</code>这个名字一看就知道是远程库。</p><p>下一步，就可以把本地库的所有内容推送到远程库上：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ git push -u origin master</span><br><span class="line">Counting objects: 20, done.</span><br><span class="line">Delta compression using up to 4 threads.</span><br><span class="line">Compressing objects: 100% (15/15), done.</span><br><span class="line">Writing objects: 100% (20/20), 1.64 KiB | 560.00 KiB/s, done.</span><br><span class="line">Total 20 (delta 5), reused 0 (delta 0)</span><br><span class="line">remote: Resolving deltas: 100% (5/5), done.</span><br><span class="line">To github.com:michaelliao/learngit.git</span><br><span class="line"> * [new branch]      master -&gt; master</span><br><span class="line">Branch &#x27;master&#x27; set up to track remote branch &#x27;master&#x27; from &#x27;origin&#x27;.</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>把本地库的内容推送到远程，用<code>git push</code>命令，实际上是把当前分支<code>master</code>推送到远程。</p><p>由于远程库是空的，我们第一次推送<code>master</code>分支时，加上了<code>-u</code>参数，Git不但会把本地的<code>master</code>分支内容推送的远程新的<code>master</code>分支，还会把本地的<code>master</code>分支和远程的<code>master</code>分支关联起来，在以后的推送或者拉取时就可以简化命令。</p><p>从现在起，只要本地作了提交，就可以通过命令：</p><p>把本地<code>master</code>分支的最新修改推送至GitHub，现在，你就拥有了真正的分布式版本库！</p><h5 id="SSH警告">SSH警告</h5><p>当你第一次使用Git的<code>clone</code>或者<code>push</code>命令连接GitHub时，会得到一个警告：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">The authenticity of host &#x27;github.com (xx.xx.xx.xx)&#x27; can&#x27;t be established.</span><br><span class="line">RSA key fingerprint is xx.xx.xx.xx.xx.</span><br><span class="line">Are you sure you want to continue connecting (yes/no)?</span><br></pre></td></tr></table></figure><p>这是因为Git使用SSH连接，而SSH连接在第一次验证GitHub服务器的Key时，需要你确认GitHub的Key的指纹信息是否真的来自GitHub的服务器，输入<code>yes</code>回车即可。</p><p>Git会输出一个警告，告诉你已经把GitHub的Key添加到本机的一个信任列表里了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Warning: Permanently added &#x27;github.com&#x27; (RSA) to the list of known hosts.</span><br></pre></td></tr></table></figure><p>这个警告只会出现一次，后面的操作就不会有任何警告了。</p><p>如果你实在担心有人冒充GitHub服务器，输入<code>yes</code>前可以对照<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fhelp.github.com%2Farticles%2Fwhat-are-github-s-ssh-key-fingerprints%2F">GitHub的RSA Key的指纹信息</a>是否与SSH连接给出的一致。</p><h5 id="小结">小结</h5><p>要关联一个远程库，使用命令<code>git remote add origin git@server-name:path/repo-name.git</code>；</p><p>关联后，使用命令<code>git push -u origin master</code>第一次推送master分支的所有内容；</p><p>此后，每次本地提交后，只要有必要，就可以使用命令<code>git push origin master</code>推送最新修改；</p><p>分布式版本系统的最大好处之一是在本地工作完全不需要考虑远程库的存在，也就是有没有联网都可以正常工作，而SVN在没有联网的时候是拒绝干活的！当有网络的时候，再把本地提交推送一下就完成了同步，真是太方便了！</p><h4 id="2-从远程库克隆">2.从远程库克隆</h4><p>首先，登陆GitHub，创建一个新的仓库，名字叫<code>gitskills</code>;</p><p>勾选<code>Initialize this repository with a README</code>，这样GitHub会自动为我们创建一个README.md文件。创建完毕后，可以看到README.md文件；</p><p>现在，远程库已经准备好了，下一步是用命令<code>git clone</code>克隆一个本地库:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git clone git@github.com:xxxxx/gitskills.git</span><br><span class="line">Cloning into &#x27;gitskills&#x27;...</span><br><span class="line">remote: Counting objects: 3, done.</span><br><span class="line">remote: Total 3 (delta 0), reused 0 (delta 0), pack-reused 3</span><br><span class="line">Receiving objects: 100% (3/3), done.</span><br></pre></td></tr></table></figure><p>注意把Git库的地址换成你自己的，然后进入<code>gitskills</code>目录看看，已经有README.md文件了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cd gitskills</span><br><span class="line">$ ls</span><br><span class="line">README.md</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">如果有多个人协作开发，那么每个人各自从远程克隆一份就可以了。</span><br><span class="line"></span><br><span class="line">你也许还注意到，GitHub给出的地址不止一个，还可以用https://github.com/michaelliao/gitskills.git这样的地址。实际上，Git支持多种协议，默认的git://使用ssh，但也可以使用https等其他协议。</span><br><span class="line"></span><br><span class="line">使用https除了速度慢以外，还有个最大的麻烦是每次推送都必须输入口令，但是在某些只开放http端口的公司内部就无法使用ssh协议而只能用https。</span><br></pre></td></tr></table></figure><h5 id="小结-2">小结</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">要克隆一个仓库，首先必须知道仓库的地址，然后使用git clone命令克隆。</span><br><span class="line"></span><br><span class="line">Git支持多种协议，包括https，但通过ssh支持的原生git协议速度最快。</span><br></pre></td></tr></table></figure><h3 id="五-分支管理">五.分支管理</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">分支就是科幻电影里面的平行宇宙，当你正在电脑前努力学习Git的时候，另一个你正在另一个平行宇宙里努力学习SVN。</span><br><span class="line"></span><br><span class="line">如果两个平行宇宙互不干扰，那对现在的你也没啥影响。不过，在某个时间点，两个平行宇宙合并了，结果，你既学会了Git又学会了SVN！</span><br><span class="line"></span><br><span class="line">分支在实际中有什么用呢？假设你准备开发一个新功能，但是需要两周才能完成，第一周你写了50%的代码，如果立刻提交，由于代码还没写完，不完整的代码库会导致别人不能干活了。如果等代码全部写完再一次提交，又存在丢失每天进度的巨大风险。</span><br><span class="line"></span><br><span class="line">现在有了分支，就不用怕了。你创建了一个属于你自己的分支，别人看不到，还继续在原来的分支上正常工作，而你在自己的分支上干活，想提交就提交，直到开发完毕后，再一次性合并到原来的分支上，这样，既安全，又不影响别人工作。</span><br><span class="line"></span><br><span class="line">其他版本控制系统如SVN等都有分支管理，但是用过之后你会发现，这些版本控制系统创建和切换分支比蜗牛还慢，简直让人无法忍受，结果分支功能成了摆设，大家都不去用。</span><br><span class="line"></span><br><span class="line">但Git的分支是与众不同的，无论创建、切换和删除分支，Git在1秒钟之内就能完成！无论你的版本库是1个文件还是1万个文件。</span><br></pre></td></tr></table></figure><h4 id="1-创建与合并分支">1.创建与合并分支</h4><p>首先，我们创建<code>dev</code>分支，然后切换到<code>dev</code>分支：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b dev</span><br><span class="line">Switched to a new branch &#x27;dev&#x27;</span><br></pre></td></tr></table></figure><p><code>git checkout</code>命令加上<code>-b</code>参数表示创建并切换，相当于以下两条命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git branch dev</span><br><span class="line">$ git checkout dev</span><br><span class="line">Switched to branch &#x27;dev&#x27;</span><br></pre></td></tr></table></figure><p>然后，用<code>git branch</code>命令查看当前分支：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git branch</span><br><span class="line">* dev</span><br><span class="line">  master</span><br></pre></td></tr></table></figure><p><code>git branch</code>命令会列出所有分支，当前分支前面会标一个<code>*</code>号。</p><p>然后，我们就可以在<code>dev</code>分支上正常提交，比如对readme.txt做个修改，加上一行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Creating a new branch is quick.</span><br></pre></td></tr></table></figure><p>然后提交：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git add readme.txt </span><br><span class="line">$ git commit -m &quot;branch test&quot;</span><br><span class="line">[dev b17d20e] branch test</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br></pre></td></tr></table></figure><p>现在，<code>dev</code>分支的工作完成，我们就可以切换回<code>master</code>分支：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line">Switched to branch &#x27;master&#x27;</span><br></pre></td></tr></table></figure><p>切换回<code>master</code>分支后，再查看一个readme.txt文件，刚才添加的内容不见了！因为那个提交是在<code>dev</code>分支上，而<code>master</code>分支此刻的提交点并没有变;</p><p>现在，我们把<code>dev</code>分支的工作成果合并到<code>master</code>分支上：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git merge dev</span><br><span class="line">Updating d46f35e..b17d20e</span><br><span class="line">Fast-forward</span><br><span class="line"> readme.txt | 1 +</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br></pre></td></tr></table></figure><p><code>git merge</code>命令用于合并指定分支到当前分支。合并后，再查看readme.txt的内容，就可以看到，和<code>dev</code>分支的最新提交是完全一样的。</p><p>注意到上面的<code>Fast-forward</code>信息，Git告诉我们，这次合并是“快进模式”，也就是直接把<code>master</code>指向<code>dev</code>的当前提交，所以合并速度非常快。</p><p>当然，也不是每次合并都能<code>Fast-forward</code>，我们后面会讲其他方式的合并。</p><p>合并完成后，就可以放心地删除<code>dev</code>分支了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -d dev</span><br><span class="line">Deleted branch dev (was b17d20e).</span><br></pre></td></tr></table></figure><p>删除后，查看<code>branch</code>，就只剩下<code>master</code>分支了：</p><p>因为创建、合并和删除分支非常快，所以Git鼓励你使用分支完成某个任务，合并后再删掉分支，这和直接在<code>master</code>分支上工作效果是一样的，但过程更安全。</p><h5 id="小结-3">小结</h5><p>Git鼓励大量使用分支：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">查看分支：git branch</span><br><span class="line"></span><br><span class="line">创建分支：git branch &lt;name&gt;</span><br><span class="line"></span><br><span class="line">切换分支：git checkout &lt;name&gt;</span><br><span class="line"></span><br><span class="line">创建+切换分支：git checkout -b &lt;name&gt;</span><br><span class="line"></span><br><span class="line">合并某分支到当前分支：git merge &lt;name&gt;</span><br><span class="line"></span><br><span class="line">删除分支：git branch -d &lt;name&gt;</span><br></pre></td></tr></table></figure><h4 id="2-解决冲突">2.解决冲突</h4><p>人生不如意之事十之八九，合并分支往往也不是一帆风顺的。</p><p>准备新的<code>feature1</code>分支，继续我们的新分支开发：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b feature1</span><br><span class="line">Switched to a new branch &#x27;feature1&#x27;</span><br></pre></td></tr></table></figure><p>修改<code>readme.txt</code>最后一行，改为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Creating a new branch is quick AND simple.</span><br></pre></td></tr></table></figure><p>在<code>feature1</code>分支上提交：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git add readme.txt</span><br><span class="line">$ git commit -m &quot;AND simple&quot;</span><br><span class="line">[feature1 14096d0] AND simple</span><br><span class="line"> 1 file changed, 1 insertion(+), 1 deletion(-)</span><br></pre></td></tr></table></figure><p>切换到<code>master</code>分支：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line">Switched to branch &#x27;master&#x27;</span><br><span class="line">Your branch is ahead of &#x27;origin/master&#x27; by 1 commit.</span><br><span class="line">  (use &quot;git push&quot; to publish your local commits)</span><br></pre></td></tr></table></figure><p>Git还会自动提示我们当前<code>master</code>分支比远程的<code>master</code>分支要超前1个提交。</p><p>在<code>master</code>分支上把<code>readme.txt</code>文件的最后一行改为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Creating a new branch is quick &amp; simple.</span><br></pre></td></tr></table></figure><p>提交：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git add readme.txt </span><br><span class="line">$ git commit -m &quot;&amp; simple&quot;</span><br><span class="line">[master 5dc6824] &amp; simple</span><br><span class="line"> 1 file changed, 1 insertion(+), 1 deletion(-)</span><br></pre></td></tr></table></figure><p>现在，<code>master</code>分支和<code>feature1</code>分支各自都分别有新的提交;</p><p>这种情况下，Git无法执行“快速合并”，只能试图把各自的修改合并起来，但这种合并就可能会有冲突，我们试试看：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git merge feature1</span><br><span class="line">Auto-merging readme.txt</span><br><span class="line">CONFLICT (content): Merge conflict in readme.txt</span><br><span class="line">Automatic merge failed; fix conflicts and then commit the result.</span><br></pre></td></tr></table></figure><p>果然冲突了！Git告诉我们，<code>readme.txt</code>文件存在冲突，必须手动解决冲突后再提交。<code>git status</code>也可以告诉我们冲突的文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is ahead of &#x27;origin/master&#x27; by 2 commits.</span><br><span class="line">  (use &quot;git push&quot; to publish your local commits)</span><br><span class="line">You have unmerged paths.</span><br><span class="line">  (fix conflicts and run &quot;git commit&quot;)</span><br><span class="line">  (use &quot;git merge --abort&quot; to abort the merge)</span><br><span class="line">Unmerged paths:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to mark resolution)</span><br><span class="line">    both modified:   readme.txt</span><br><span class="line">no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</span><br></pre></td></tr></table></figure><p>我们可以直接查看readme.txt的内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Git is a distributed version control system.</span><br><span class="line">Git is free software distributed under the GPL.</span><br><span class="line">Git has a mutable index called stage.</span><br><span class="line">Git tracks changes of files.</span><br><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span><br><span class="line">Creating a new branch is quick &amp; simple.</span><br><span class="line">=======</span><br><span class="line">Creating a new branch is quick AND simple.</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt; feature1</span><br></pre></td></tr></table></figure><p>Git用<code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code>，<code>=======</code>，<code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code>标记出不同分支的内容，我们修改如下后保存：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Creating a new branch is quick and simple.</span><br></pre></td></tr></table></figure><p>再提交：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git add readme.txt </span><br><span class="line">$ git commit -m &quot;conflict fixed&quot;</span><br><span class="line">[master cf810e4] conflict fixed</span><br></pre></td></tr></table></figure><p>现在，<code>master</code>分支和<code>feature1</code>分支变成了下图所示：</p><p>[图片上传失败…(image-bd478-1557217136484)]</p><p>用带参数的<code>git log</code>也可以看到分支的合并情况：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ git log --graph --pretty=oneline --abbrev-commit</span><br><span class="line">*   cf810e4 (HEAD -&gt; master) conflict fixed</span><br><span class="line">|\  </span><br><span class="line">| * 14096d0 (feature1) AND simple</span><br><span class="line">* | 5dc6824 &amp; simple</span><br><span class="line">|/  </span><br><span class="line">* b17d20e branch test</span><br><span class="line">* d46f35e (origin/master) remove test.txt</span><br><span class="line">* b84166e add test.txt</span><br><span class="line">* 519219b git tracks changes</span><br><span class="line">* e43a48b understand how stage works</span><br><span class="line">* 1094adb append GPL</span><br><span class="line">* e475afc add distributed</span><br><span class="line">* eaadf4e wrote a readme file</span><br></pre></td></tr></table></figure><p>最后，删除<code>feature1</code>分支：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -d feature1</span><br><span class="line">Deleted branch feature1 (was 14096d0).</span><br></pre></td></tr></table></figure><h5 id="小结-4">小结</h5><p>当Git无法自动合并分支时，就必须首先解决冲突。解决冲突后，再提交，合并完成。</p><p>解决冲突就是把Git合并失败的文件手动编辑为我们希望的内容，再提交。</p><p>用<code>git log --graph</code>命令可以看到分支合并图。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log --graph --pretty=oneline --abbrev-commit</span><br></pre></td></tr></table></figure><h4 id="3-分支管理策略">3.分支管理策略</h4><p>通常，合并分支时，如果可能，Git会用Fast forward模式，但这种模式下，删除分支后，会丢掉分支信息。</p><p>如果要强制禁用Fast forward模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。</p><p>下面我们实战一下–no-ff方式的git merge：</p><p>首先，仍然创建并切换dev分支：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b dev</span><br><span class="line">Switched to a new branch &#x27;dev&#x27;</span><br></pre></td></tr></table></figure><p>修改readme.txt文件，并提交一个新的commit：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git add readme.txt </span><br><span class="line">$ git commit -m &quot;add merge&quot;</span><br><span class="line">[dev f52c633] add merge</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br></pre></td></tr></table></figure><p>现在，我们切换回master：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line">Switched to branch &#x27;master&#x27;</span><br></pre></td></tr></table></figure><p>准备合并dev分支，请注意–no-ff参数，表示禁用Fast forward：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git merge --no-ff -m &quot;merge with no-ff&quot; dev</span><br><span class="line">Merge made by the &#x27;recursive&#x27; strategy.</span><br><span class="line"> readme.txt | 1 +</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br></pre></td></tr></table></figure><p>因为本次合并要创建一个新的commit，所以加上-m参数，把commit描述写进去。</p><p>合并后，我们用git log看看分支历史：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git log --graph --pretty=oneline --abbrev-commit</span><br><span class="line">*   e1e9c68 (HEAD -&gt; master) merge with no-ff</span><br><span class="line">|\  </span><br><span class="line">| * f52c633 (dev) add merge</span><br><span class="line">|/  </span><br><span class="line">*   cf810e4 conflict fixed</span><br></pre></td></tr></table></figure><h5 id="分支策略">分支策略</h5><p>在实际开发中，我们应该按照几个基本原则进行分支管理：</p><p>首先，<code>master</code>分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活；</p><p>那在哪干活呢？干活都在<code>dev</code>分支上，也就是说，<code>dev</code>分支是不稳定的，到某个时候，比如1.0版本发布时，再把<code>dev</code>分支合并到<code>master</code>上，在<code>master</code>分支发布1.0版本；</p><p>你和你的小伙伴们每个人都在<code>dev</code>分支上干活，每个人都有自己的分支，时不时地往<code>dev</code>分支上合并就可以了。</p><h5 id="小结-5">小结</h5><p>Git分支十分强大，在团队开发中应该充分应用。</p><p>合并分支时，加上<code>--no-ff</code>参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而<code>fast forward</code>合并就看不出来曾经做过合并。</p><h4 id="5-Bug分支">5.Bug分支</h4><p>软件开发中，bug就像家常便饭一样。有了bug就需要修复，在Git中，由于分支是如此的强大，所以，每个bug都可以通过一个新的临时分支来修复，修复后，合并分支，然后将临时分支删除。</p><p>当你接到一个修复一个代号101的bug的任务时，很自然地，你想创建一个分支issue-101来修复它，但是，等等，当前正在dev上进行的工作还没有提交：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch dev</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line">    new file:   hello.py</span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line">    modified:   readme.txt</span><br></pre></td></tr></table></figure><p>并不是你不想提交，而是工作只进行到一半，还没法提交，预计完成还需1天时间。但是，必须在两个小时内修复该bug，怎么办？</p><p>幸好，Git还提供了一个stash功能，可以把当前工作现场“储藏”起来，等以后恢复现场后继续工作：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git stash</span><br><span class="line">Saved working directory and index state WIP on dev: f52c633 add merge</span><br></pre></td></tr></table></figure><p>现在，用git status查看工作区，就是干净的（除非有没有被Git管理的文件），因此可以放心地创建分支来修复bug。</p><p>首先确定要在哪个分支上修复bug，假定需要在master分支上修复，就从master创建临时分支：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line">Switched to branch &#x27;master&#x27;</span><br><span class="line">Your branch is ahead of &#x27;origin/master&#x27; by 6 commits.</span><br><span class="line">  (use &quot;git push&quot; to publish your local commits)</span><br><span class="line"></span><br><span class="line">$ git checkout -b issue-101</span><br><span class="line">Switched to a new branch &#x27;issue-101&#x27;</span><br></pre></td></tr></table></figure><p>现在修复bug，需要把“Git is free software …”改为“Git is a free software …”，然后提交：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git add readme.txt </span><br><span class="line">$ git commit -m &quot;fix bug 101&quot;</span><br><span class="line">[issue-101 4c805e2] fix bug 101</span><br><span class="line"> 1 file changed, 1 insertion(+), 1 deletion(-)</span><br></pre></td></tr></table></figure><p>修复完成后，切换到master分支，并完成合并，最后删除issue-101分支：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line">Switched to branch &#x27;master&#x27;</span><br><span class="line">Your branch is ahead of &#x27;origin/master&#x27; by 6 commits.</span><br><span class="line">  (use &quot;git push&quot; to publish your local commits)</span><br><span class="line"></span><br><span class="line">$ git merge --no-ff -m &quot;merged bug fix 101&quot; issue-101</span><br><span class="line">Merge made by the &#x27;recursive&#x27; strategy.</span><br><span class="line"> readme.txt | 2 +-</span><br><span class="line"> 1 file changed, 1 insertion(+), 1 deletion(-)</span><br></pre></td></tr></table></figure><p>太棒了，原计划两个小时的bug修复只花了5分钟！现在，是时候接着回到dev分支干活了！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout dev</span><br><span class="line">Switched to branch &#x27;dev&#x27;</span><br><span class="line"></span><br><span class="line">$ git status</span><br><span class="line">On branch dev</span><br><span class="line">nothing to commit, working tree clean</span><br></pre></td></tr></table></figure><p>工作区是干净的，刚才的工作现场存到哪去了？用git stash list命令看看：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git stash list</span><br><span class="line">stash@&#123;0&#125;: WIP on dev: f52c633 add merge</span><br></pre></td></tr></table></figure><p>工作现场还在，Git把stash内容存在某个地方了，但是需要恢复一下，有两个办法：</p><p>一是用<code>git stash apply</code>恢复，但是恢复后，stash内容并不删除，你需要用git stash drop来删除；</p><p>另一种方式是用<code>git stash pop</code>，恢复的同时把stash内容也删了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ git stash pop</span><br><span class="line">On branch dev</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line">    new file:   hello.py</span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line">    modified:   readme.txt</span><br><span class="line">Dropped refs/stash@&#123;0&#125; (5d677e2ee266f39ea296182fb2354265b91b3b2a)</span><br></pre></td></tr></table></figure><p>再用<code>git stash list</code>查看，就看不到任何stash内容了：</p><p>你可以多次stash，恢复的时候，先用git stash list查看，然后恢复指定的stash，用命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git stash apply stash@&#123;0&#125;</span><br></pre></td></tr></table></figure><h5 id="小结-6">小结</h5><p>修复bug时，我们会通过创建新的bug分支进行修复，然后合并，最后删除；</p><p>当手头工作没有完成时，先把工作现场<code>git stash</code>一下，然后去修复bug，修复后，再<code>git stash pop</code>，回到工作现场。</p><h4 id="6-Feature分支">6.Feature分支</h4><p>软件开发中，总有无穷无尽的新的功能要不断添加进来。</p><p>添加一个新功能时，你肯定不希望因为一些实验性质的代码，把主分支搞乱了，所以，每添加一个新功能，最好新建一个feature分支，在上面开发，完成后，合并，最后，删除该feature分支。</p><p>现在，你终于接到了一个新任务：开发代号为Vulcan的新功能，该功能计划用于下一代星际飞船。</p><p>于是准备开发：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b feature-vulcan</span><br><span class="line">Switched to a new branch &#x27;feature-vulcan&#x27;</span><br></pre></td></tr></table></figure><p>5分钟后，开发完毕：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ git add vulcan.py</span><br><span class="line">$ git status</span><br><span class="line">On branch feature-vulcan</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line">    new file:   vulcan.py</span><br><span class="line">$ git commit -m &quot;add feature vulcan&quot;</span><br><span class="line">[feature-vulcan 287773e] add feature vulcan</span><br><span class="line"> 1 file changed, 2 insertions(+)</span><br><span class="line"> create mode 100644 vulcan.py</span><br></pre></td></tr></table></figure><p>切回dev，准备合并：</p><p>一切顺利的话，feature分支和bug分支是类似的，合并，然后删除。</p><p>但是！</p><p>就在此时，接到上级命令，因经费不足，新功能必须取消！</p><p>虽然白干了，但是这个包含机密资料的分支还是必须就地销毁：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -d feature-vulcan</span><br><span class="line">error: The branch &#x27;feature-vulcan&#x27; is not fully merged.</span><br><span class="line">If you are sure you want to delete it, run &#x27;git branch -D feature-vulcan&#x27;.</span><br></pre></td></tr></table></figure><p>销毁失败。Git友情提醒，feature-vulcan分支还没有被合并，如果删除，将丢失掉修改，如果要强行删除，需要使用大写的-D参数。。</p><p>现在我们强行删除：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -D feature-vulcan</span><br><span class="line">Deleted branch feature-vulcan (was 287773e).</span><br></pre></td></tr></table></figure><p>终于删除成功！</p><h5 id="小结-7">小结</h5><p>开发一个新feature，最好新建一个分支；<br>如果要丢弃一个没有被合并过的分支，可以通过<code>git branch -D &lt;name&gt;</code>强行删除。</p><h3 id="7-多人协作">7.多人协作</h3><p>当你从远程仓库克隆时，实际上Git自动把本地的<code>master</code>分支和远程的<code>master</code>分支对应起来了，并且，远程仓库的默认名称是<code>origin</code>。</p><p>要查看远程库的信息，用<code>git remote</code>：</p><p>或者，用<code>git remote -v</code>显示更详细的信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git remote -v</span><br><span class="line">origin  git@github.com:michaelliao/learngit.git (fetch)</span><br><span class="line">origin  git@github.com:michaelliao/learngit.git (push)</span><br></pre></td></tr></table></figure><p>上面显示了可以抓取和推送的<code>origin</code>的地址。如果没有推送权限，就看不到push的地址。</p><h5 id="推送分支">推送分支</h5><p>推送分支，就是把该分支上的所有本地提交推送到远程库。推送时，要指定本地分支，这样，Git就会把该分支推送到远程库对应的远程分支上：</p><p>如果要推送其他分支，比如<code>dev</code>，就改成：</p><p>但是，并不是一定要把本地分支往远程推送，那么，哪些分支需要推送，哪些不需要呢？</p><ul><li><p><code>master</code>分支是主分支，因此要时刻与远程同步；</p></li><li><p><code>dev</code>分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步；</p></li><li><p>bug分支只用于在本地修复bug，就没必要推到远程了，除非老板要看看你每周到底修复了几个bug；</p></li><li><p>feature分支是否推到远程，取决于你是否和你的小伙伴合作在上面开发。</p></li></ul><p>总之，就是在Git中，分支完全可以在本地自己藏着玩，是否推送，视你的心情而定！</p><h5 id="抓取分支">抓取分支</h5><p>多人协作时，大家都会往<code>master</code>和<code>dev</code>分支上推送各自的修改。</p><p>现在，模拟一个你的小伙伴，可以在另一台电脑（注意要把SSH Key添加到GitHub）或者同一台电脑的另一个目录下克隆：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git clone git@github.com:michaelliao/learngit.git</span><br><span class="line">Cloning into &#x27;learngit&#x27;...</span><br><span class="line">remote: Counting objects: 40, done.</span><br><span class="line">remote: Compressing objects: 100% (21/21), done.</span><br><span class="line">remote: Total 40 (delta 14), reused 40 (delta 14), pack-reused 0</span><br><span class="line">Receiving objects: 100% (40/40), done.</span><br><span class="line">Resolving deltas: 100% (14/14), done.</span><br></pre></td></tr></table></figure><p>当你的小伙伴从远程库clone时，默认情况下，你的小伙伴只能看到本地的<code>master</code>分支。不信可以用<code>git branch</code>命令看看：</p><p>现在，你的小伙伴要在<code>dev</code>分支上开发，就必须创建远程<code>origin</code>的<code>dev</code>分支到本地，于是他用这个命令创建本地<code>dev</code>分支：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b dev origin/dev</span><br></pre></td></tr></table></figure><p>现在，他就可以在<code>dev</code>上继续修改，然后，时不时地把<code>dev</code>分支<code>push</code>到远程：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ git add env.txt</span><br><span class="line"></span><br><span class="line">$ git commit -m &quot;add env&quot;</span><br><span class="line">[dev 7a5e5dd] add env</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line"> create mode 100644 env.txt</span><br><span class="line"></span><br><span class="line">$ git push origin dev</span><br><span class="line">Counting objects: 3, done.</span><br><span class="line">Delta compression using up to 4 threads.</span><br><span class="line">Compressing objects: 100% (2/2), done.</span><br><span class="line">Writing objects: 100% (3/3), 308 bytes | 308.00 KiB/s, done.</span><br><span class="line">Total 3 (delta 0), reused 0 (delta 0)</span><br><span class="line">To github.com:michaelliao/learngit.git</span><br><span class="line">   f52c633..7a5e5dd  dev -&gt; dev</span><br></pre></td></tr></table></figure><p>你的小伙伴已经向<code>origin/dev</code>分支推送了他的提交，而碰巧你也对同样的文件作了修改，并试图推送：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">$ cat env.txt</span><br><span class="line">env</span><br><span class="line"></span><br><span class="line">$ git add env.txt</span><br><span class="line"></span><br><span class="line">$ git commit -m &quot;add new env&quot;</span><br><span class="line">[dev 7bd91f1] add new env</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line"> create mode 100644 env.txt</span><br><span class="line"></span><br><span class="line">$ git push origin dev</span><br><span class="line">To github.com:michaelliao/learngit.git</span><br><span class="line"> ! [rejected]        dev -&gt; dev (non-fast-forward)</span><br><span class="line">error: failed to push some refs to &#x27;git@github.com:michaelliao/learngit.git&#x27;</span><br><span class="line">hint: Updates were rejected because the tip of your current branch is behind</span><br><span class="line">hint: its remote counterpart. Integrate the remote changes (e.g.</span><br><span class="line">hint: &#x27;git pull ...&#x27;) before pushing again.</span><br><span class="line">hint: See the &#x27;Note about fast-forwards&#x27; in &#x27;git push --help&#x27; for details.</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>推送失败，因为你的小伙伴的最新提交和你试图推送的提交有冲突，解决办法也很简单，Git已经提示我们，先用<code>git pull</code>把最新的提交从<code>origin/dev</code>抓下来，然后，在本地合并，解决冲突，再推送：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git pull</span><br><span class="line">There is no tracking information for the current branch.</span><br><span class="line">Please specify which branch you want to merge with.</span><br><span class="line">See git-pull(1) for details.</span><br><span class="line">    git pull &lt;remote&gt; &lt;branch&gt;</span><br><span class="line">If you wish to set tracking information for this branch you can do so with:</span><br><span class="line">    git branch --set-upstream-to=origin/&lt;branch&gt; dev</span><br></pre></td></tr></table></figure><p><code>git pull</code>也失败了，原因是没有指定本地<code>dev</code>分支与远程<code>origin/dev</code>分支的链接，根据提示，设置<code>dev</code>和<code>origin/dev</code>的链接：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git branch --set-upstream-to=origin/dev dev</span><br><span class="line">Branch &#x27;dev&#x27; set up to track remote branch &#x27;dev&#x27; from &#x27;origin&#x27;.</span><br></pre></td></tr></table></figure><p>再pull：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git pull</span><br><span class="line">Auto-merging env.txt</span><br><span class="line">CONFLICT (add/add): Merge conflict in env.txt</span><br><span class="line">Automatic merge failed; fix conflicts and then commit the result.</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这回<code>git pull</code>成功，但是合并有冲突，需要手动解决，解决的方法和分支管理中的解决冲突完全一样。解决后，提交，再push：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -m &quot;fix env conflict&quot;</span><br><span class="line">[dev 57c53ab] fix env conflict</span><br><span class="line"></span><br><span class="line">$ git push origin dev</span><br><span class="line">Counting objects: 6, done.</span><br><span class="line">Delta compression using up to 4 threads.</span><br><span class="line">Compressing objects: 100% (4/4), done.</span><br><span class="line">Writing objects: 100% (6/6), 621 bytes | 621.00 KiB/s, done.</span><br><span class="line">Total 6 (delta 0), reused 0 (delta 0)</span><br><span class="line">To github.com:michaelliao/learngit.git</span><br><span class="line">   7a5e5dd..57c53ab  dev -&gt; dev</span><br></pre></td></tr></table></figure><p>因此，多人协作的工作模式通常是这样：</p><ol><li><p>首先，可以试图用<code>git push origin &lt;branch-name&gt;</code>推送自己的修改；</p></li><li><p>如果推送失败，则因为远程分支比你的本地更新，需要先用<code>git pull</code>试图合并；</p></li><li><p>如果合并有冲突，则解决冲突，并在本地提交；</p></li><li><p>没有冲突或者解决掉冲突后，再用<code>git push origin &lt;branch-name&gt;</code>推送就能成功！</p></li></ol><p>如果<code>git pull</code>提示<code>no tracking information</code>，则说明本地分支和远程分支的链接关系没有创建，用命令<code>git branch --set-upstream-to &lt;branch-name&gt; origin/&lt;branch-name&gt;</code>。</p><p>这就是多人协作的工作模式，一旦熟悉了，就非常简单。</p><h3 id="小结-8">小结</h3><ul><li><p>查看远程库信息，使用<code>git remote -v</code>；</p></li><li><p>本地新建的分支如果不推送到远程，对其他人就是不可见的；</p></li><li><p>从本地推送分支，使用<code>git push origin branch-name</code>，如果推送失败，先用<code>git pull</code>抓取远程的新提交；</p></li><li><p>在本地创建和远程分支对应的分支，使用<code>git checkout -b branch-name origin/branch-name</code>，本地和远程分支的名称最好一致；</p></li><li><p>建立本地分支和远程分支的关联，使用<code>git branch --set-upstream branch-name origin/branch-name</code>；</p></li><li><p>从远程抓取分支，使用<code>git pull</code>，如果有冲突，要先处理冲突。</p></li></ul><h4 id="8-Rebase">8.Rebase</h4><p>多人在同一个分支上协作时，很容易出现冲突。即使没有冲突，后push的童鞋不得不先pull，在本地合并，然后才能push成功。</p><p>每次合并再push后，分支变成了这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">$ git log --graph --pretty=oneline --abbrev-commit</span><br><span class="line">* d1be385 (HEAD -&gt; master, origin/master) init hello</span><br><span class="line">*   e5e69f1 Merge branch &#x27;dev&#x27;</span><br><span class="line">|\  </span><br><span class="line">| *   57c53ab (origin/dev, dev) fix env conflict</span><br><span class="line">| |\  </span><br><span class="line">| | * 7a5e5dd add env</span><br><span class="line">| * | 7bd91f1 add new env</span><br><span class="line">| |/  </span><br><span class="line">* |   12a631b merged bug fix 101</span><br><span class="line">|\ \  </span><br><span class="line">| * | 4c805e2 fix bug 101</span><br><span class="line">|/ /  </span><br><span class="line">* |   e1e9c68 merge with no-ff</span><br><span class="line">|\ \  </span><br><span class="line">| |/  </span><br><span class="line">| * f52c633 add merge</span><br><span class="line">|/  </span><br><span class="line">*   cf810e4 conflict fixed</span><br></pre></td></tr></table></figure><p>总之看上去很乱，有强迫症的童鞋会问：为什么Git的提交历史不能是一条干净的直线？</p><p>其实是可以做到的！</p><p>Git有一种称为<code>rebase</code>的操作，有人把它翻译成“变基”。</p><p>先不要随意展开想象。我们还是从实际问题出发，看看怎么把分叉的提交变成直线。</p><p>在和远程分支同步后，我们对<code>hello.py</code>这个文件做了两次提交。用<code>git log</code>命令看看：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ git log --graph --pretty=oneline --abbrev-commit</span><br><span class="line">* 582d922 (HEAD -&gt; master) add author</span><br><span class="line">* 8875536 add comment</span><br><span class="line">* d1be385 (origin/master) init hello</span><br><span class="line">*   e5e69f1 Merge branch &#x27;dev&#x27;</span><br><span class="line">|\  </span><br><span class="line">| *   57c53ab (origin/dev, dev) fix env conflict</span><br><span class="line">| |\  </span><br><span class="line">| | * 7a5e5dd add env</span><br><span class="line">| * | 7bd91f1 add new env</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>注意到Git用<code>(HEAD -&gt; master)</code>和<code>(origin/master)</code>标识出当前分支的HEAD和远程origin的位置分别是<code>582d922 add author</code>和<code>d1be385 init hello</code>，本地分支比远程分支快两个提交。</p><p>现在我们尝试推送本地分支：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin master</span><br><span class="line">To github.com:michaelliao/learngit.git</span><br><span class="line"> ! [rejected]        master -&gt; master (fetch first)</span><br><span class="line">error: failed to push some refs to &#x27;git@github.com:michaelliao/learngit.git&#x27;</span><br><span class="line">hint: Updates were rejected because the remote contains work that you do</span><br><span class="line">hint: not have locally. This is usually caused by another repository pushing</span><br><span class="line">hint: to the same ref. You may want to first integrate the remote changes</span><br><span class="line">hint: (e.g., &#x27;git pull ...&#x27;) before pushing again.</span><br><span class="line">hint: See the &#x27;Note about fast-forwards&#x27; in &#x27;git push --help&#x27; for details.</span><br></pre></td></tr></table></figure><p>很不幸，失败了，这说明有人先于我们推送了远程分支。按照经验，先pull一下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ git pull</span><br><span class="line">remote: Counting objects: 3, done.</span><br><span class="line">remote: Compressing objects: 100% (1/1), done.</span><br><span class="line">remote: Total 3 (delta 1), reused 3 (delta 1), pack-reused 0</span><br><span class="line">Unpacking objects: 100% (3/3), done.</span><br><span class="line">From github.com:michaelliao/learngit</span><br><span class="line">   d1be385..f005ed4  master     -&gt; origin/master</span><br><span class="line"> * [new tag]         v1.0       -&gt; v1.0</span><br><span class="line">Auto-merging hello.py</span><br><span class="line">Merge made by the &#x27;recursive&#x27; strategy.</span><br><span class="line"> hello.py | 1 +</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br></pre></td></tr></table></figure><p>再用<code>git status</code>看看状态：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is ahead of &#x27;origin/master&#x27; by 3 commits.</span><br><span class="line">  (use &quot;git push&quot; to publish your local commits)</span><br><span class="line"></span><br><span class="line">nothing to commit, working tree clean</span><br></pre></td></tr></table></figure><p>加上刚才合并的提交，现在我们本地分支比远程分支超前3个提交。</p><p>用<code>git log</code>看看：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git log --graph --pretty=oneline --abbrev-commit</span><br><span class="line">*   e0ea545 (HEAD -&gt; master) Merge branch &#x27;master&#x27; of github.com:michaelliao/learngit</span><br><span class="line">|\  </span><br><span class="line">| * f005ed4 (origin/master) set exit=1</span><br><span class="line">* | 582d922 add author</span><br><span class="line">* | 8875536 add comment</span><br><span class="line">|/  </span><br><span class="line">* d1be385 init hello</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>对强迫症童鞋来说，现在事情有点不对头，提交历史分叉了。如果现在把本地分支push到远程，有没有问题？</p><p>有！</p><p>什么问题？</p><p>不好看！</p><p>有没有解决方法？</p><p>有！</p><p>这个时候，rebase就派上了用场。我们输入命令<code>git rebase</code>试试：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ git rebase</span><br><span class="line">First, rewinding head to replay your work on top of it...</span><br><span class="line">Applying: add comment</span><br><span class="line">Using index info to reconstruct a base tree...</span><br><span class="line">M   hello.py</span><br><span class="line">Falling back to patching base and 3-way merge...</span><br><span class="line">Auto-merging hello.py</span><br><span class="line">Applying: add author</span><br><span class="line">Using index info to reconstruct a base tree...</span><br><span class="line">M   hello.py</span><br><span class="line">Falling back to patching base and 3-way merge...</span><br><span class="line">Auto-merging hello.py</span><br></pre></td></tr></table></figure><p>输出了一大堆操作，到底是啥效果？再用<code>git log</code>看看：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git log --graph --pretty=oneline --abbrev-commit</span><br><span class="line">* 7e61ed4 (HEAD -&gt; master) add author</span><br><span class="line">* 3611cfe add comment</span><br><span class="line">* f005ed4 (origin/master) set exit=1</span><br><span class="line">* d1be385 init hello</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>原本分叉的提交现在变成一条直线了！这种神奇的操作是怎么实现的？其实原理非常简单。我们注意观察，发现Git把我们本地的提交“挪动”了位置，放到了<code>f005ed4 (origin/master) set exit=1</code>之后，这样，整个提交历史就成了一条直线。rebase操作前后，最终的提交内容是一致的，但是，我们本地的commit修改内容已经变化了，它们的修改不再基于<code>d1be385 init hello</code>，而是基于<code>f005ed4 (origin/master) set exit=1</code>，但最后的提交<code>7e61ed4</code>内容是一致的。</p><p>这就是rebase操作的特点：把分叉的提交历史“整理”成一条直线，看上去更直观。缺点是本地的分叉提交已经被修改过了。</p><p>最后，通过push操作把本地分支推送到远程：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Mac:~/learngit michael$ git push origin master</span><br><span class="line">Counting objects: 6, done.</span><br><span class="line">Delta compression using up to 4 threads.</span><br><span class="line">Compressing objects: 100% (5/5), done.</span><br><span class="line">Writing objects: 100% (6/6), 576 bytes | 576.00 KiB/s, done.</span><br><span class="line">Total 6 (delta 2), reused 0 (delta 0)</span><br><span class="line">remote: Resolving deltas: 100% (2/2), completed with 1 local object.</span><br><span class="line">To github.com:michaelliao/learngit.git</span><br><span class="line">   f005ed4..7e61ed4  master -&gt; master</span><br></pre></td></tr></table></figure><p>再用<code>git log</code>看看效果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git log --graph --pretty=oneline --abbrev-commit</span><br><span class="line">* 7e61ed4 (HEAD -&gt; master, origin/master) add author</span><br><span class="line">* 3611cfe add comment</span><br><span class="line">* f005ed4 set exit=1</span><br><span class="line">* d1be385 init hello</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>远程分支的提交历史也是一条直线。</p><h3 id="小结-9">小结</h3><ul><li><p>rebase操作可以把本地未push的分叉提交历史整理成直线；</p></li><li><p>rebase的目的是使得我们在查看历史提交的变化时更容易，因为分叉的提交需要三方对比。</p></li></ul><h3 id="六-标签管理">六.标签管理</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">发布一个版本时，我们通常先在版本库中打一个标签（tag），这样，就唯一确定了打标签时刻的版本。将来无论什么时候，取某个标签的版本，就是把那个打标签的时刻的历史版本取出来。所以，标签也是版本库的一个快照。</span><br><span class="line"></span><br><span class="line">Git的标签虽然是版本库的快照，但其实它就是指向某个commit的指针（跟分支很像对不对？但是分支可以移动，标签不能移动），所以，创建和删除标签都是瞬间完成的。</span><br><span class="line"></span><br><span class="line">Git有commit，为什么还要引入tag？</span><br><span class="line"></span><br><span class="line">“请把上周一的那个版本打包发布，commit号是6a5819e...”</span><br><span class="line"></span><br><span class="line">“一串乱七八糟的数字不好找！”</span><br><span class="line"></span><br><span class="line">如果换一个办法：</span><br><span class="line"></span><br><span class="line">“请把上周一的那个版本打包发布，版本号是v1.2”</span><br><span class="line"></span><br><span class="line">“好的，按照tag v1.2查找commit就行！”</span><br><span class="line"></span><br><span class="line">所以，tag就是一个让人容易记住的有意义的名字，它跟某个commit绑在一起。</span><br></pre></td></tr></table></figure><h4 id="1-创建标签">1.创建标签</h4><p>在Git中打标签非常简单，首先，切换到需要打标签的分支上：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git branch</span><br><span class="line">* dev</span><br><span class="line">  master</span><br><span class="line">$ git checkout master</span><br><span class="line">Switched to branch &#x27;master&#x27;</span><br></pre></td></tr></table></figure><p>然后，敲命令git tag <name>就可以打一个新标签：</p><p>可以用命令git tag查看所有标签：</p><p>默认标签是打在最新提交的commit上的。有时候，如果忘了打标签，比如，现在已经是周五了，但应该在周一打的标签没有打，怎么办？</p><p>方法是找到历史提交的commit id，然后打上就可以了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ git log --pretty=oneline --abbrev-commit</span><br><span class="line">12a631b (HEAD -&gt; master, tag: v1.0, origin/master) merged bug fix 101</span><br><span class="line">4c805e2 fix bug 101</span><br><span class="line">e1e9c68 merge with no-ff</span><br><span class="line">f52c633 add merge</span><br><span class="line">cf810e4 conflict fixed</span><br><span class="line">5dc6824 &amp; simple</span><br><span class="line">14096d0 AND simple</span><br><span class="line">b17d20e branch test</span><br><span class="line">d46f35e remove test.txt</span><br><span class="line">b84166e add test.txt</span><br><span class="line">519219b git tracks changes</span><br><span class="line">e43a48b understand how stage works</span><br><span class="line">1094adb append GPL</span><br><span class="line">e475afc add distributed</span><br><span class="line">eaadf4e wrote a readme file</span><br></pre></td></tr></table></figure><p>比方说要对add merge这次提交打标签，它对应的commit id是f52c633，敲入命令：</p><p>再用命令git tag查看标签：</p><p>注意，标签不是按时间顺序列出，而是按字母排序的。可以用git show <tagname>查看标签信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git show v0.9</span><br><span class="line">commit f52c63349bc3c1593499807e5c8e972b82c8f286 (tag: v0.9)</span><br><span class="line">Author: Michael Liao &lt;askxuefeng@gmail.com&gt;</span><br><span class="line">Date:   Fri May 18 21:56:54 2018 +0800</span><br><span class="line"></span><br><span class="line">    add merge</span><br><span class="line"></span><br><span class="line">diff --git a/readme.txt b/readme.txt</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>可以看到，v0.9确实打在add merge这次提交上。</p><p>还可以创建带有说明的标签，用-a指定标签名，-m指定说明文字：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git tag -a v0.1 -m &quot;version 0.1 released&quot; 1094adb</span><br></pre></td></tr></table></figure><p>用命令git show <tagname>可以看到说明文字：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ git show v0.1</span><br><span class="line">tag v0.1</span><br><span class="line">Tagger: Michael Liao &lt;askxuefeng@gmail.com&gt;</span><br><span class="line">Date:   Fri May 18 22:48:43 2018 +0800</span><br><span class="line"></span><br><span class="line">version 0.1 released</span><br><span class="line"></span><br><span class="line">commit 1094adb7b9b3807259d8cb349e7df1d4d6477073 (tag: v0.1)</span><br><span class="line">Author: Michael Liao &lt;askxuefeng@gmail.com&gt;</span><br><span class="line">Date:   Fri May 18 21:06:15 2018 +0800</span><br><span class="line"></span><br><span class="line">    append GPL</span><br><span class="line"></span><br><span class="line">diff --git a/readme.txt b/readme.txt</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>注意：标签总是和某个commit挂钩。如果这个commit既出现在master分支，又出现在dev分支，那么在这两个分支上都可以看到这个标签。</p><h5 id="小结-10">小结</h5><p>命令<code>git tag &lt;tagname&gt;</code>用于新建一个标签，默认为HEAD，也可以指定一个commit id；</p><p>命令<code>git tag -a &lt;tagname&gt; -m &quot;blablabla...&quot;</code>可以指定标签信息；</p><p>命令<code>git tag</code>可以查看所有标签。</p><h4 id="2-操作标签">2.操作标签</h4><p>如果标签打错了，也可以删除：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git tag -d v0.1</span><br><span class="line">Deleted tag &#x27;v0.1&#x27; (was f15b0dd)</span><br></pre></td></tr></table></figure><p>因为创建的标签都只存储在本地，不会自动推送到远程。所以，打错的标签可以在本地安全删除。</p><p>如果要推送某个标签到远程，使用命令git push origin <tagname>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin v1.0</span><br><span class="line">Total 0 (delta 0), reused 0 (delta 0)</span><br><span class="line">To github.com:michaelliao/learngit.git</span><br><span class="line"> * [new tag]         v1.0 -&gt; v1.0</span><br></pre></td></tr></table></figure><p>或者，一次性推送全部尚未推送到远程的本地标签：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin --tags</span><br><span class="line">Total 0 (delta 0), reused 0 (delta 0)</span><br><span class="line">To github.com:michaelliao/learngit.git</span><br><span class="line"> * [new tag]         v0.9 -&gt; v0.9</span><br></pre></td></tr></table></figure><p>如果标签已经推送到远程，要删除远程标签就麻烦一点，先从本地删除：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git tag -d v0.9</span><br><span class="line">Deleted tag &#x27;v0.9&#x27; (was f52c633)</span><br></pre></td></tr></table></figure><p>然后，从远程删除。删除命令也是push，但是格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin :refs/tags/v0.9</span><br><span class="line">To github.com:michaelliao/learngit.git</span><br><span class="line"> - [deleted]         v0.9</span><br></pre></td></tr></table></figure><p>要看看是否真的从远程库删除了标签，可以登陆GitHub查看。</p><h5 id="小结-11">小结</h5><p>命令<code>git push origin &lt;tagname&gt;</code>可以推送一个本地标签；</p><p>命令<code>git push origin --tags</code>可以推送全部未推送过的本地标签；</p><p>命令<code>git tag -d &lt;tagname&gt;</code>可以删除一个本地标签；</p><p>命令<code>git push origin :refs/tags/&lt;tagname&gt;</code>可以删除一个远程标签。</p><h3 id="七-使用GitHub">七.使用GitHub</h3><p>我们一直用GitHub作为免费的远程仓库，如果是个人的开源项目，放到GitHub上是完全没有问题的。其实GitHub还是一个开源协作社区，通过GitHub，既可以让别人参与你的开源项目，也可以参与别人的开源项目。</p><p>在GitHub出现以前，开源项目开源容易，但让广大人民群众参与进来比较困难，因为要参与，就要提交代码，而给每个想提交代码的群众都开一个账号那是不现实的，因此，群众也仅限于报个bug，即使能改掉bug，也只能把diff文件用邮件发过去，很不方便。</p><p>但是在GitHub上，利用Git极其强大的克隆和分支功能，广大人民群众真正可以第一次自由参与各种开源项目了。</p><p>如何参与一个开源项目呢？比如人气极高的bootstrap项目，这是一个非常强大的CSS框架，你可以访问它的项目主页<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Ftwbs%2Fbootstrap">https://github.com/twbs/bootstrap</a>，点“Fork”就在自己的账号下克隆了一个bootstrap仓库，然后，从自己的账号下clone：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone git@github.com:michaelliao/bootstrap.git</span><br></pre></td></tr></table></figure><p>一定要从自己的账号下clone仓库，这样你才能推送修改。如果从bootstrap的作者的仓库地址<code>git@github.com:twbs/bootstrap.git</code>克隆，因为没有权限，你将不能推送修改。</p><p>Bootstrap的官方仓库<code>twbs/bootstrap</code>、你在GitHub上克隆的仓库<code>my/bootstrap</code>，以及你自己克隆到本地电脑的仓库，他们的关系就像下图显示的那样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">┌─ GitHub ────────────────────────────────────┐</span><br><span class="line">│                                             │</span><br><span class="line">│ ┌─────────────────┐     ┌─────────────────┐ │</span><br><span class="line">│ │ twbs/bootstrap  │────&gt;│  my/bootstrap   │ │</span><br><span class="line">│ └─────────────────┘     └─────────────────┘ │</span><br><span class="line">│                                  ▲          │</span><br><span class="line">└──────────────────────────────────┼──────────┘</span><br><span class="line">                                   ▼</span><br><span class="line">                          ┌─────────────────┐</span><br><span class="line">                          │ local/bootstrap │</span><br><span class="line">                          └─────────────────┘</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如果你想修复bootstrap的一个bug，或者新增一个功能，立刻就可以开始干活，干完后，往自己的仓库推送。</p><p>如果你希望bootstrap的官方库能接受你的修改，你就可以在GitHub上发起一个pull request。当然，对方是否接受你的pull request就不一定了。</p><p>如果你没能力修改bootstrap，但又想要试一把pull request，那就Fork一下我的仓库：<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2FZWP233%2Flearngit">https://github.com/ZWP233/learngit</a>，创建一个<code>your-github-id.txt</code>的文本文件，写点自己学习Git的心得，然后推送一个pull request给我，我会视心情而定是否接受。</p><h3 id="小结-12">小结</h3><ul><li><p>在GitHub上，可以任意Fork开源仓库；</p></li><li><p>自己拥有Fork后的仓库的读写权限；</p></li><li><p>可以推送pull request给官方仓库来贡献代码。</p></li></ul><h3 id="八-使用码云">八.使用码云</h3><p>使用GitHub时，国内的用户经常遇到的问题是访问速度太慢，有时候还会出现无法连接的情况（原因你懂的）。</p><p>如果我们希望体验Git飞一般的速度，可以使用国内的Git托管服务——<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgitee.com%2F">码云</a>（<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgitee.com%2F">gitee.com</a>）。</p><p>和GitHub相比，码云也提供免费的Git仓库。此外，还集成了代码质量检测、项目演示等功能。对于团队协作开发，码云还提供了项目管理、代码托管、文档管理的服务，5人以下小团队免费。</p><p>码云的免费版本也提供私有库功能，只是有5人的成员上限。</p><p>使用码云和使用GitHub类似，我们在码云上注册账号并登录后，需要先上传自己的SSH公钥。选择右上角用户头像 -&gt; 菜单“修改资料”，然后选择“SSH公钥”，填写一个便于识别的标题，然后把用户主目录下的<code>.ssh/id_rsa.pub</code>文件的内容粘贴进去;</p><p>点击“确定”即可完成并看到刚才添加的Key;</p><p>如果我们已经有了一个本地的git仓库（例如，一个名为learngit的本地库），如何把它关联到码云的远程库上呢？</p><p>首先，我们在码云上创建一个新的项目，选择右上角用户头像 -&gt; 菜单“控制面板”，然后点击“创建项目”;</p><p>项目名称最好与本地库保持一致：</p><p>然后，我们在本地库上使用命令<code>git remote add</code>把它和码云的远程库关联：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin git@gitee.com:liaoxuefeng/learngit.git</span><br></pre></td></tr></table></figure><p>之后，就可以正常地用<code>git push</code>和<code>git pull</code>推送了！</p><p>如果在使用命令<code>git remote add</code>时报错：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin git@gitee.com:liaoxuefeng/learngit.git</span><br><span class="line">fatal: remote origin already exists.</span><br></pre></td></tr></table></figure><p>这说明本地库已经关联了一个名叫<code>origin</code>的远程库，此时，可以先用<code>git remote -v</code>查看远程库信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git remote -v</span><br><span class="line">origin  git@github.com:michaelliao/learngit.git (fetch)</span><br><span class="line">origin  git@github.com:michaelliao/learngit.git (push)</span><br></pre></td></tr></table></figure><p>可以看到，本地库已经关联了<code>origin</code>的远程库，并且，该远程库指向GitHub。</p><p>我们可以删除已有的GitHub远程库：</p><p>再关联码云的远程库（注意路径中需要填写正确的用户名）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin git@gitee.com:liaoxuefeng/learngit.git</span><br></pre></td></tr></table></figure><p>此时，我们再查看远程库信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git remote -v</span><br><span class="line">origin  git@gitee.com:liaoxuefeng/learngit.git (fetch)</span><br><span class="line">origin  git@gitee.com:liaoxuefeng/learngit.git (push)</span><br></pre></td></tr></table></figure><p>现在可以看到，origin已经被关联到码云的远程库了。通过<code>git push</code>命令就可以把本地库推送到Gitee上。</p><p>有的小伙伴又要问了，一个本地库能不能既关联GitHub，又关联码云呢？</p><p>答案是肯定的，因为git本身是分布式版本控制系统，可以同步到另外一个远程库，当然也可以同步到另外两个远程库。</p><p>使用多个远程库时，我们要注意，git给远程库起的默认名称是<code>origin</code>，如果有多个远程库，我们需要用不同的名称来标识不同的远程库。</p><p>仍然以<code>learngit</code>本地库为例，我们先删除已关联的名为<code>origin</code>的远程库：</p><p>然后，先关联GitHub的远程库：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add github git@github.com:michaelliao/learngit.git</span><br></pre></td></tr></table></figure><p>注意，远程库的名称叫<code>github</code>，不叫<code>origin</code>了。</p><p>接着，再关联码云的远程库：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add gitee git@gitee.com:liaoxuefeng/learngit.git</span><br></pre></td></tr></table></figure><p>同样注意，远程库的名称叫<code>gitee</code>，不叫<code>origin</code>。</p><p>现在，我们用<code>git remote -v</code>查看远程库信息，可以看到两个远程库：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git remote -v</span><br><span class="line">gitee   git@gitee.com:liaoxuefeng/learngit.git (fetch)</span><br><span class="line">gitee   git@gitee.com:liaoxuefeng/learngit.git (push)</span><br><span class="line">github  git@github.com:michaelliao/learngit.git (fetch)</span><br><span class="line">github  git@github.com:michaelliao/learngit.git (push)</span><br></pre></td></tr></table></figure><p>如果要推送到GitHub，使用命令：</p><p>如果要推送到码云，使用命令：</p><p>这样一来，我们的本地库就可以同时与多个远程库互相同步：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">┌─────────┐ ┌─────────┐</span><br><span class="line">│ GitHub  │ │  Gitee  │</span><br><span class="line">└─────────┘ └─────────┘</span><br><span class="line">     ▲           ▲</span><br><span class="line">     └─────┬─────┘</span><br><span class="line">           │</span><br><span class="line">    ┌─────────────┐</span><br><span class="line">    │ Local Repo  │</span><br><span class="line">    └─────────────┘</span><br></pre></td></tr></table></figure><p>码云也同样提供了Pull request功能，可以让其他小伙伴参与到开源项目中来。你可以通过Fork我的仓库：<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgitee.com%2FZWP233%2Flearngit">https://gitee.com/ZWP233/learngit</a>，创建一个<code>your-gitee-id.txt</code>的文本文件， 写点自己学习Git的心得，然后推送一个pull request给我，这个仓库会在码云和GitHub做双向同步。</p><h3 id="九-自定义Git">九.自定义Git</h3><p>在安装Git一节中，我们已经配置了<code>user.name</code>和<code>user.email</code>，实际上，Git还有很多可配置项。</p><p>比如，让Git显示颜色，会让命令输出看起来更醒目：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global color.ui true</span><br></pre></td></tr></table></figure><p>这样，Git会适当地显示不同的颜色，比如<code>git status</code>命令;</p><p>文件名就会标上颜色。</p><p>我们在后面还会介绍如何更好地配置Git，以便让你的工作更高效。</p><h4 id="1-忽略特殊文件">1.忽略特殊文件</h4><p>有些时候，你必须把某些文件放到Git工作目录中，但又不能提交它们，比如保存了数据库密码的配置文件啦，等等，每次<code>git status</code>都会显示<code>Untracked files ...</code>，有强迫症的童鞋心里肯定不爽。</p><p>好在Git考虑到了大家的感受，这个问题解决起来也很简单，在Git工作区的根目录下创建一个特殊的<code>.gitignore</code>文件，然后把要忽略的文件名填进去，Git就会自动忽略这些文件。</p><p>不需要从头写<code>.gitignore</code>文件，GitHub已经为我们准备了各种配置文件，只需要组合一下就可以使用了。所有配置文件可以直接在线浏览：<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Fgithub%2Fgitignore">https://github.com/github/gitignore</a></p><p>忽略文件的原则是：</p><ol><li>忽略操作系统自动生成的文件，比如缩略图等；</li><li>忽略编译生成的中间文件、可执行文件等，也就是如果一个文件是通过另一个文件自动生成的，那自动生成的文件就没必要放进版本库，比如Java编译产生的<code>.class</code>文件；</li><li>忽略你自己的带有敏感信息的配置文件，比如存放口令的配置文件。</li></ol><p>举个例子：</p><p>假设你在Windows下进行Python开发，Windows会自动在有图片的目录下生成隐藏的缩略图文件，如果有自定义目录，目录下就会有<code>Desktop.ini</code>文件，因此你需要忽略Windows自动生成的垃圾文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># Windows:</span><br><span class="line">Thumbs.db</span><br><span class="line">ehthumbs.db</span><br><span class="line">Desktop.ini</span><br></pre></td></tr></table></figure><p>然后，继续忽略Python编译产生的<code>.pyc</code>、<code>.pyo</code>、<code>dist</code>等文件或目录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># Python:</span><br><span class="line">*.py[cod]</span><br><span class="line">*.so</span><br><span class="line">*.egg</span><br><span class="line">*.egg-info</span><br><span class="line">dist</span><br><span class="line">build</span><br></pre></td></tr></table></figure><p>加上你自己定义的文件，最终得到一个完整的<code>.gitignore</code>文件，内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># Windows:</span><br><span class="line">Thumbs.db</span><br><span class="line">ehthumbs.db</span><br><span class="line">Desktop.ini</span><br><span class="line"></span><br><span class="line"># Python:</span><br><span class="line">*.py[cod]</span><br><span class="line">*.so</span><br><span class="line">*.egg</span><br><span class="line">*.egg-info</span><br><span class="line">dist</span><br><span class="line">build</span><br><span class="line"></span><br><span class="line"># My configurations:</span><br><span class="line">db.ini</span><br><span class="line">deploy_key_rsa</span><br></pre></td></tr></table></figure><p>最后一步就是把<code>.gitignore</code>也提交到Git，就完成了！当然检验<code>.gitignore</code>的标准是<code>git status</code>命令是不是说<code>working directory clean</code>。</p><p>使用Windows的童鞋注意了，如果你在资源管理器里新建一个<code>.gitignore</code>文件，它会非常弱智地提示你必须输入文件名，但是在文本编辑器里“保存”或者“另存为”就可以把文件保存为<code>.gitignore</code>了。</p><p>有些时候，你想添加一个文件到Git，但发现添加不了，原因是这个文件被<code>.gitignore</code>忽略了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git add App.class</span><br><span class="line">The following paths are ignored by one of your .gitignore files:</span><br><span class="line">App.class</span><br><span class="line">Use -f if you really want to add them.</span><br></pre></td></tr></table></figure><p>如果你确实想添加该文件，可以用<code>-f</code>强制添加到Git：</p><p>或者你发现，可能是<code>.gitignore</code>写得有问题，需要找出来到底哪个规则写错了，可以用<code>git check-ignore</code>命令检查：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git check-ignore -v App.class</span><br><span class="line">.gitignore:3:*.class    App.class</span><br></pre></td></tr></table></figure><p>Git会告诉我们，<code>.gitignore</code>的第3行规则忽略了该文件，于是我们就可以知道应该修订哪个规则。</p><h5 id="小结-13">小结</h5><ul><li><p>忽略某些文件时，需要编写<code>.gitignore</code>；</p></li><li><p><code>.gitignore</code>文件本身要放到版本库里，并且可以对<code>.gitignore</code>做版本管理！</p></li></ul><h4 id="2-配置别名">2.配置别名</h4><p>有没有经常敲错命令？比如<code>git status</code>？<code>status</code>这个单词真心不好记。</p><p>如果敲<code>git st</code>就表示<code>git status</code>那就简单多了，当然这种偷懒的办法我们是极力赞成的。</p><p>我们只需要敲一行命令，告诉Git，以后<code>st</code>就表示<code>status</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global alias.st status</span><br></pre></td></tr></table></figure><p>好了，现在敲<code>git st</code>看看效果。</p><p>当然还有别的命令可以简写，很多人都用<code>co</code>表示<code>checkout</code>，<code>ci</code>表示<code>commit</code>，<code>br</code>表示<code>branch</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global alias.co checkout</span><br><span class="line">$ git config --global alias.ci commit</span><br><span class="line">$ git config --global alias.br branch</span><br></pre></td></tr></table></figure><p>以后提交就可以简写成：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git ci -m &quot;bala bala bala...&quot;</span><br></pre></td></tr></table></figure><p><code>--global</code>参数是全局参数，也就是这些命令在这台电脑的所有Git仓库下都有用。</p><p>在<code>撤销修改</code>一节中，我们知道，命令<code>git reset HEAD file</code>可以把暂存区的修改撤销掉（unstage），重新放回工作区。既然是一个unstage操作，就可以配置一个<code>unstage</code>别名：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global alias.unstage &#x27;reset HEAD&#x27;</span><br></pre></td></tr></table></figure><p>当你敲入命令：</p><p>实际上Git执行的是：</p><p>配置一个<code>git last</code>，让其显示最后一次提交信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global alias.last &#x27;log -1&#x27;</span><br></pre></td></tr></table></figure><p>这样，用<code>git last</code>就能显示最近一次的提交：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git last</span><br><span class="line">commit adca45d317e6d8a4b23f9811c3d7b7f0f180bfe2</span><br><span class="line">Merge: bd6ae48 291bea8</span><br><span class="line">Author: Michael Liao &lt;askxuefeng@gmail.com&gt;</span><br><span class="line">Date:   Thu Aug 22 22:49:22 2013 +0800</span><br><span class="line">    merge &amp; fix hello.py</span><br></pre></td></tr></table></figure><p>甚至还有人丧心病狂地把<code>lg</code>配置成了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global alias.lg &quot;log --color --graph --pretty=format:&#x27;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&#x27; --abbrev-commit&quot;</span><br></pre></td></tr></table></figure><p>为什么不早点告诉我？别激动，咱不是为了多记几个英文单词嘛！</p><h5 id="配置文件">配置文件</h5><p>配置Git的时候，加上<code>--global</code>是针对当前用户起作用的，如果不加，那只针对当前的仓库起作用。</p><p>配置文件放哪了？每个仓库的Git配置文件都放在<code>.git/config</code>文件中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ cat .git/config </span><br><span class="line">[core]</span><br><span class="line">    repositoryformatversion = 0</span><br><span class="line">    filemode = true</span><br><span class="line">    bare = false</span><br><span class="line">    logallrefupdates = true</span><br><span class="line">    ignorecase = true</span><br><span class="line">    precomposeunicode = true</span><br><span class="line">[remote &quot;origin&quot;]</span><br><span class="line">    url = git@github.com:michaelliao/learngit.git</span><br><span class="line">    fetch = +refs/heads/*:refs/remotes/origin/*</span><br><span class="line">[branch &quot;master&quot;]</span><br><span class="line">    remote = origin</span><br><span class="line">    merge = refs/heads/master</span><br><span class="line">[alias]</span><br><span class="line">    last = log -1</span><br></pre></td></tr></table></figure><p>别名就在<code>[alias]</code>后面，要删除别名，直接把对应的行删掉即可。</p><p>而当前用户的Git配置文件放在用户主目录下的一个隐藏文件<code>.gitconfig</code>中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ cat .gitconfig</span><br><span class="line">[alias]</span><br><span class="line">    co = checkout</span><br><span class="line">    ci = commit</span><br><span class="line">    br = branch</span><br><span class="line">    st = status</span><br><span class="line">[user]</span><br><span class="line">    name = Your Name</span><br><span class="line">    email = your@email.com</span><br></pre></td></tr></table></figure><p>配置别名也可以直接修改这个文件，如果改错了，可以删掉文件重新通过命令配置。</p><h5 id="小结-14">小结</h5><p>给Git配置好别名，就可以输入命令时偷个懒。我们鼓励偷懒。</p><h4 id="3-搭建Git服务器">3.搭建Git服务器</h4><p>在远程仓库一节中，我们讲了远程仓库实际上和本地仓库没啥不同，纯粹为了7x24小时开机并交换大家的修改。</p><p>GitHub就是一个免费托管开源代码的远程仓库。但是对于某些视源代码如生命的商业公司来说，既不想公开源代码，又舍不得给GitHub交保护费，那就只能自己搭建一台Git服务器作为私有仓库使用。</p><p>搭建Git服务器需要准备一台运行Linux的机器，强烈推荐用Ubuntu或Debian，这样，通过几条简单的<code>apt</code>命令就可以完成安装。</p><p>假设你已经有<code>sudo</code>权限的用户账号，下面，正式开始安装。</p><p>第一步，安装<code>git</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install git</span><br></pre></td></tr></table></figure><p>第二步，创建一个<code>git</code>用户，用来运行<code>git</code>服务：</p><p>第三步，创建证书登录：</p><p>收集所有需要登录的用户的公钥，就是他们自己的<code>id_rsa.pub</code>文件，把所有公钥导入到<code>/home/git/.ssh/authorized_keys</code>文件里，一行一个。</p><p>第四步，初始化Git仓库：</p><p>先选定一个目录作为Git仓库，假定是<code>/srv/sample.git</code>，在<code>/srv</code>目录下输入命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo git init --bare sample.git</span><br></pre></td></tr></table></figure><p>Git就会创建一个裸仓库，裸仓库没有工作区，因为服务器上的Git仓库纯粹是为了共享，所以不让用户直接登录到服务器上去改工作区，并且服务器上的Git仓库通常都以<code>.git</code>结尾。然后，把owner改为<code>git</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo chown -R git:git sample.git</span><br></pre></td></tr></table></figure><p>第五步，禁用shell登录：</p><p>出于安全考虑，第二步创建的git用户不允许登录shell，这可以通过编辑<code>/etc/passwd</code>文件完成。找到类似下面的一行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git:x:1001:1001:,,,:/home/git:/bin/bash</span><br></pre></td></tr></table></figure><p>改为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git:x:1001:1001:,,,:/home/git:/usr/bin/git-shell</span><br></pre></td></tr></table></figure><p>这样，<code>git</code>用户可以正常通过ssh使用git，但无法登录shell，因为我们为<code>git</code>用户指定的<code>git-shell</code>每次一登录就自动退出。</p><p>第六步，克隆远程仓库：</p><p>现在，可以通过<code>git clone</code>命令克隆远程仓库了，在各自的电脑上运行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git clone git@server:/srv/sample.git</span><br><span class="line">Cloning into &#x27;sample&#x27;...</span><br><span class="line">warning: You appear to have cloned an empty repository.</span><br></pre></td></tr></table></figure><p>剩下的推送就简单了。</p><h5 id="管理公钥">管理公钥</h5><p>如果团队很小，把每个人的公钥收集起来放到服务器的<code>/home/git/.ssh/authorized_keys</code>文件里就是可行的。如果团队有几百号人，就没法这么玩了，这时，可以用<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Fres0nat0r%2Fgitosis">Gitosis</a>来管理公钥。</p><p>这里我们不介绍怎么玩<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Fres0nat0r%2Fgitosis">Gitosis</a>了，几百号人的团队基本都在500强了，相信找个高水平的Linux管理员问题不大。</p><h6 id="管理权限">管理权限</h6><p>有很多不但视源代码如生命，而且视员工为窃贼的公司，会在版本控制系统里设置一套完善的权限控制，每个人是否有读写权限会精确到每个分支甚至每个目录下。因为Git是为Linux源代码托管而开发的，所以Git也继承了开源社区的精神，不支持权限控制。不过，因为Git支持钩子（hook），所以，可以在服务器端编写一系列脚本来控制提交等操作，达到权限控制的目的。<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Fsitaramc%2Fgitolite">Gitolite</a>就是这个工具。</p><p>这里我们也不介绍<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Fsitaramc%2Fgitolite">Gitolite</a>了，不要把有限的生命浪费到权限斗争中。</p><h5 id="小结-15">小结</h5><ul><li><p>搭建Git服务器非常简单，通常10分钟即可完成；</p></li><li><p>要方便管理公钥，用<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Fsitaramc%2Fgitolite">Gitosis</a>；</p></li><li><p>要像SVN那样变态地控制权限，用<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Fsitaramc%2Fgitolite">Gitolite</a>。</p></li></ul><p>git</p>]]></content>
      
      
      
        <tags>
            
            <tag> 教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Xcode版本管理工具</title>
      <link href="/post/43d69001.html"/>
      <url>/post/43d69001.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>这篇要来分享刚学习到的新套件，xcodes。 主要原因是因为手机突然更新了最新版本，XCode版本不能使用真机，于是更新XCode版本，但是更新完成打包出现各种问题，于是就要找到新版本的安装，但是在AppStore的Xcode都是最新版本，若是后续要找回旧版本相当困难，刚好之前在“weak self”的podcast有听到这个管理Xcode版本的套件，所以就先下载来尝试看看。顺便分享遭遇到的一些小</p></blockquote><hr><p>这篇要来分享刚学习到的新套件，xcodes。</p><p>主要原因是因为手机突然更新了最新版本，XCode版本不能使用真机，于是更新XCode版本，但是更新完成打包出现各种问题，于是就要找到新版本的安装，但是在AppStore的Xcode都是最新版本，若是后续要找回旧版本相当困难，刚好之前在“weak self”的podcast有听到这个管理Xcode版本的套件，所以就先下载来尝试看看。顺便分享遭遇到的一些小问题。</p><p>首先先找到xcodes的GitHub网址，如下。</p><div class="tag link"><a class="link-card" title="XcodesApp" href="https://github.com/RobotsAndPencils/XcodesApp"><div class="left"><img src="https://raw.githubusercontent.com/XcodesOrg/XcodesApp/9cf10125ca481159106f4434e033797a55b47bc2/icon.png"/></div><div class="right"><p class="text">XcodesApp</p><p class="url">https://github.com/RobotsAndPencils/XcodesApp</p></div></a></div><p>点选进去可以看到安装的方法</p><p><a href="http://zwp233.top/post/43d69001/1*T5IG6Rx9okjiHQpNyl0YXQ.png"><img src="http://zwp233.top/post/43d69001/1*T5IG6Rx9okjiHQpNyl0YXQ.png" alt=""></a></p><p>需要透过所谓的Homebrew来进行安装，而安装的指令是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install --cask xcodes</span><br></pre></td></tr></table></figure><p>而这个所谓brew也是一种套件安装的方式</p><p>所以要先安装brew后才能透过brew安装xcodes，点选上面的网址可以看到Homebrew的安装指令。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/bin/bash -c &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)&quot;</span><br></pre></td></tr></table></figure><p>打开Terminal后贴上上面指令后执行</p><p><a href="http://zwp233.top/post/43d69001/1*T5IG6Rx9okjiHQpNyl0YXQ.png"><img src="http://zwp233.top/post/43d69001/1*T5IG6Rx9okjiHQpNyl0YXQ.png" alt=""></a></p><p>接着就会请你输入帐号密码后安装，正常的状况下会安装完成。但是刚好我遭遇到一个小状况。安装后发现到没有安装完成，但是不要紧张，在终端机下方会告诉你失败的原因，我发现到Terminal会告诉你是因为有2个path没有安装到，下方也会很贴心的附上那两个path的指令，刚好我已经安装完所以错误已经看不到了。</p><p>把那两个指令安装下去Homebrew就算是安装完成，接着就可以装xcodes，透过github所提供的安装指令就会自己开始跑。</p><p>跑完之后就会出现在你的Mac里面了。</p><p><a href="http://zwp233.top/post/43d69001/1*1YD-Kl_bfJarLCv9bd_w_g.png"><img src="http://zwp233.top/post/43d69001/1*1YD-Kl_bfJarLCv9bd_w_g.png" alt=""></a></p><p>点开可以尝试选择要的版本安装，但是在安装时我跳出这个错误讯息。</p><p><a href="http://zwp233.top/post/43d69001/1*DOJgiE482-ZgSCln-A2AYw.png"><img src="http://zwp233.top/post/43d69001/1*DOJgiE482-ZgSCln-A2AYw.png" alt=""></a></p><p>这个时候点选上方的齿轮</p><p><a href="http://zwp233.top/post/43d69001/1*ooqeWY4JGvpgBK1M3jevZQ.png"><img src="http://zwp233.top/post/43d69001/1*ooqeWY4JGvpgBK1M3jevZQ.png" alt=""></a></p><p>点下Sign IN</p><p><a href="http://zwp233.top/post/43d69001/1*kC4Q2SIHHy4UIZpk4QJLQQ.png"><img src="http://zwp233.top/post/43d69001/1*kC4Q2SIHHy4UIZpk4QJLQQ.png" alt=""></a></p><p>输入开发Apple ID后就可以了。</p><p>这个时候就可以顺利透过xcodes安装所要的版本，终于知道为什么别人说开发Swift的Mac容量越大越好，毕竟一个版本通常都是1xGB起跳。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 工具 </tag>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS面试题</title>
      <link href="/post/6db1ba4f.html"/>
      <url>/post/6db1ba4f.html</url>
      
        <content type="html"><![CDATA[<h2 id="iOS2023年最新面试题（持续更新中）">iOS2023年最新面试题（持续更新中）</h2><h3 id="OC和Swift语言基础">OC和Swift语言基础</h3><h4 id="1、-synthesize和-dynamic分别有什么作用？">1、@synthesize和@dynamic分别有什么作用？</h4><ul><li>@property有两个对应的词，一个是 @synthesize，一个是 @dynamic。如果 @synthesize和 @dynamic都没写，那么默认的就是@syntheszie var = _var;</li><li>@synthesize 的语义是如果你没有手动实现 setter 方法和 getter 方法，那么编译器会自动为你加上这两个方法。</li><li>@dynamic 告诉编译器：属性的 setter 与 getter 方法由用户自己实现，不自动生成。（当然对于 readonly 的属性只需提供 getter 即可）。假如一个属性被声明为 @dynamic var，然后你没有提供 @setter方法和 @getter 方法，编译的时候没问题，但是当程序运行到 instance.var = someVar，由于缺 setter 方法会导致程序崩溃；或者当运行到 someVar = var 时，由于缺 getter 方法同样会导致崩溃。编译时没问题，运行时才执行相应的方法，这就是所谓的动态绑定。</li></ul><h4 id="2、Swift和OC的区别？">2、Swift和OC的区别？</h4><ul><li>快速、现代、安全、互动，而且明显优于 Objective-C 语言</li><li>可以使用现有的 Cocoa 和 Cocoa Touch 框架</li><li>Swift 取消了 Objective C 的指针/地址等不安全访问的使用</li><li>提供了类似 Java 的名字空间(namespace)、泛型 - (generic)var、运算对象重载（operator overloading</li><li>Swift 被简单的形容为 “没有 C 的 Objective-C”（Objective-C without the C）</li><li>为苹果开发工具带来了Xcode Playgrounds功能，该功能提供强大的互动效果，能让Swift 源代码在撰写过程中实时显示出其运行结果；</li><li>基于C和Objective-C，而却没有C的一些兼容约束；</li><li>采用了安全的编程模式；</li><li>舍弃 Objective C 早期应用 Smalltalk 的语法，保留了Smalltalk的动态特性，全面改为句点表示法</li><li>类型严谨 对比oc的动态绑定</li></ul><h4 id="3、Swift中struct和class的区别？">3、Swift中struct和class的区别？</h4><ul><li><strong>struct</strong><br>值类型，深拷贝，分配在栈上<br>没有析构函数<br>不能继承<br>不会发生内存泄漏，线程安全<br>实例方法修改属性时用mutating标记</li><li><strong>class</strong><br>引用类型，浅拷贝，分配在堆上<br>有析构函数<br>可以单继承<br>可以有单例<br>无需mutating标记<br>每一个成员变量都必须初始化</li></ul><ol><li>class 直接对属性赋值，也就是没有通过构造器赋值的，在创建对象对属性赋值只能是如下方式:</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class ClassPerson  &#123;</span><br><span class="line">    var name: String?</span><br><span class="line">    var age: Int?</span><br><span class="line">&#125;</span><br><span class="line">struct StructPerson &#123;</span><br><span class="line">    var name: String?</span><br><span class="line">    var age: Int?</span><br><span class="line">&#125;</span><br><span class="line">let p1 = ClassPerson()</span><br><span class="line">p1.name = &quot;123&quot;</span><br><span class="line">print(p1.name)</span><br><span class="line"></span><br><span class="line">var p2 = StructPerson(name: &quot;abc&quot;, age: 20)</span><br><span class="line">p2.name = &quot;123&quot;</span><br><span class="line">print(p2.name)</span><br></pre></td></tr></table></figure><p>原因： class 在初始化时不能直接把 property 放在默认的 constructor 的参数里，而是<strong>需要自己创建一个带参数的constructor</strong></p><ol start="2"><li>struct是值类型, class是引用类型</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class ClassPerson  &#123;</span><br><span class="line">    var name: String</span><br><span class="line">    var age: Int</span><br><span class="line">    init(name:String,age:Int) &#123;</span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">struct StructPerson &#123;</span><br><span class="line">    var name: String</span><br><span class="line">    var age: Int</span><br><span class="line">&#125;</span><br><span class="line">let p1 = ClassPerson(name: &quot;abc&quot;, age: 10)</span><br><span class="line">let secondP1 = p1</span><br><span class="line">secondP1.name = &quot;123&quot;</span><br><span class="line">print(p1.name)</span><br><span class="line"></span><br><span class="line">let p2 = StructPerson(name: &quot;abc&quot;, age: 20)</span><br><span class="line">var secondP2 = p2</span><br><span class="line">secondP2.name = &quot;123&quot;</span><br><span class="line">print(p2.name)</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/2752635-2743acc26e5d8a63.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/438/format/webp" alt=""></p><p>截屏2023-02-14 下午8.52.05.png</p><ol start="3"><li>在struct的成员函数中修改自己本身的值，应该在函数签名上加上mutating关键字,而class则没有此限制</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class ClassPerson  &#123;</span><br><span class="line">    var name: String</span><br><span class="line">    var age: Int</span><br><span class="line">    init(name:String,age:Int) &#123;</span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">   &#125;</span><br><span class="line">   func changeName()&#123;</span><br><span class="line">        self.name = self.name + &quot;name&quot;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">struct StructPerson &#123;</span><br><span class="line">    var name: String</span><br><span class="line">    var age: Int</span><br><span class="line">    mutating func changeName()&#123;</span><br><span class="line">        self.name = self.name + &quot;name&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let p1 = ClassPerson(name: &quot;abc&quot;, age: 10)</span><br><span class="line">print(p1.name)</span><br><span class="line">p1.changeName()</span><br><span class="line">print(p1.name)</span><br><span class="line">var p2 = StructPerson(name: &quot;abc&quot;, age: 20)</span><br><span class="line">print(p2.name)</span><br><span class="line">p2.changeName()</span><br><span class="line">print(p2.name)</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/2752635-6f0b530099847e8b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/380/format/webp" alt=""></p><p>截屏2023-02-14 下午8.46.42.png</p><ol start="4"><li>struct初始化为let的对象无法修改，修改会编译报错，而class没有此限制</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class ClassPerson  &#123;</span><br><span class="line">   var name: String?</span><br><span class="line">   var age: Int?</span><br><span class="line">   init(name:String,age:Int) &#123;</span><br><span class="line">     self.name = name</span><br><span class="line">     self.age = age</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">struct StructPerson &#123;</span><br><span class="line">   var name: String?</span><br><span class="line">   var age: Int?</span><br><span class="line">&#125;</span><br><span class="line">let p1 = ClassPerson(name: &quot;abc&quot;, age: 10)</span><br><span class="line">p1.name = &quot;123&quot;</span><br><span class="line">print(p1.name)</span><br><span class="line"></span><br><span class="line">let p2 = StructPerson(name: &quot;abc&quot;, age: 20)</span><br><span class="line">p2.name = &quot;123&quot;</span><br><span class="line">print(p2.name)</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/2752635-afe879196a617de4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt=""></p><p>截屏2023-02-14 下午8.40.40.png</p><ol start="5"><li>OC里面无法调用Swift里的struct，因为要在OC里调用Swift代码的话，对象需要继承自NSObject。</li><li>struct不能被序列化成NSData，不能归解档，class可以，因为归解档的类必须遵守NSCoding协议，而NSCoding只适用于继承自NSObject的类，struct不能遵守NSCoding协议。<br><strong>解决方案：<br>定义一个protocol，包含两个方法：<br>1.从结构体中得到一个NSDictionary对象<br>2.使用一个NSDictionary对象实例化结构体<br>NSDictionary可以使用NSKeyedArchiver进行序列化<br>好处：所有遵守该协议的结构体都可以被序列化</strong></li></ol><h4 id="4、KVC实现原理？">4、KVC实现原理？</h4><p>KVC，键-值编码，使用字符串直接访问对象的属性。<br>底层实现，当一个对象调用setValue方法时，方法内部会做以下操作：</p><ol><li>检查是否存在相应key的set方法，如果存在，就调用set方法</li><li>如果set方法不存在，就会查找与key相同名称并且带下划线的成员属性，如果有，则直接给成员属性赋值</li><li>如果没有找到_key，就会查找相同名称的属性key，如果有就直接赋值</li><li>如果还没找到，则调用<code>valueForUndefinedKey：</code>和<code>setValue：forUndefinedKey：</code>方法</li></ol><h4 id="5、KVO的实现原理？">5、KVO的实现原理？</h4><p><img src="https://upload-images.jianshu.io/upload_images/2752635-f60db70b7825c0a5.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt=""></p><p>kvo原理.jpg</p><ol><li>当给A类添加KVO的时候，runtime动态的生成了一个子类NSKVONotifying_A，让A类的isa指针指向NSKVONotifying_A类，重写class方法，隐藏对象真实类信息</li><li>重写监听属性的setter方法，在setter方法内部调用了Foundation 的 <code>_NSSetObjectValueAndNotify</code>函数</li><li>_NSSetObjectValueAndNotify函数内部<br>a) 首先会调用 <code>willChangeValueForKey</code><br>b) 然后给属性赋值<br>c) 最后调用<code>didChangeValueForKey</code><br>d) 最后调用 observer 的<code>observeValueForKeyPath</code>去告诉监听器属性值发生了改变 .</li><li>重写了dealloc做一些 KVO 内存释放</li></ol><h4 id="6、如何手动触发KVO方法？">6、如何手动触发KVO方法？</h4><ul><li>手动调用<code>willChangeValueForKey</code>和<code>didChangeValueForKey</code>方法</li><li>键值观察通知依赖于 NSObject 的两个方法: <code>willChangeValueForKey:</code>和 <code>didChangeValueForKey:</code>。在一个被观察属性发生改变之前， <code>willChangeValueForKey:</code>一定会被调用，这就会记录旧的值。而当改变发生后， <code>didChangeValueForKey :</code>会被调用，继而 <code>observeValueForKey:ofObject:change:context:</code>也会被调用。</li></ul><h4 id="7、为什么Block用copy关键字？">7、为什么Block用copy关键字？</h4><ul><li>Block在没有使用外部变量时，内存存在全局区，然而，当Block在使用外部变量的时候，内存是存在于栈区，当Block copy之后，是存在堆区的。存在于栈区的特点是对象随时有可能被销毁，一旦销毁在调用的时候，就会造成系统的崩溃。所以Block要用copy关键字。</li></ul><h4 id="8、-weak和assign的区别，什么场景下使用，代理为什么使用weak？">8、 weak和assign的区别，什么场景下使用，代理为什么使用weak？</h4><ul><li>weak是弱指针， 在对象被销毁的时候会把weak修饰的属性置为空，避免造成野指针，只能修饰对象类型。</li><li>assign对象被释放的时候不会指向nil，对象被释放了还是指向原来的地址。调用的话容易产生野指针。assign可以修对象和基本数据类型。</li><li>代理要使用weak，weak可以说是非持有关系，对象释放了就指向nil，什么时候释放是由外部来控制，可以用assign但是用assign的时需要对象被释放的时候，把delegate指向nil。</li></ul><h4 id="9、load和initialize的区别">9、load和initialize的区别</h4><ul><li>load方法的本质：直接执行函数指针，其实就是直接执行函数指针，不会执行消息发送objc_msgSend那一套流程。子类、分类的load方法不会覆盖父类的load方法。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">static void schedule_class_load(class_t *cls)</span><br><span class="line">&#123;</span><br><span class="line">    assert(isRealized(cls));  // _read_images should realize</span><br><span class="line">    if (cls-&gt;data-&gt;flags &amp; RW_LOADED) return;</span><br><span class="line">    //确保先将父类添加到全局列表里 （loadable_class）</span><br><span class="line">    class_t *supercls = getSuperclass(cls);</span><br><span class="line">    if (supercls) schedule_class_load(supercls);</span><br><span class="line">    //再将当前类添加到全局列表里 （loadable_class）</span><br><span class="line">    add_class_to_loadable_list((Class)cls);</span><br><span class="line">    changeInfo(cls, RW_LOADED, 0); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// Call all +loads for the detached list.</span><br><span class="line">    for (i = 0; i &lt; used; i++) &#123;</span><br><span class="line">        Class cls = classes[i].cls;</span><br><span class="line">        IMP load_method = classes[i].method;</span><br><span class="line">        if (!cls) continue; </span><br><span class="line">        if (PrintLoading) &#123;</span><br><span class="line">            _objc_inform(&quot;LOAD: +[%s load]\n&quot;, _class_getName(cls));</span><br><span class="line">        &#125;</span><br><span class="line">        (*load_method) ((id) cls, SEL_load);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li><p>场景1 ：子类、父类、分类都实现load方法，调用情况<br>答：SuperClass-&gt;SubClass-&gt;CategoryClass</p></li><li><p>场景2 ：子类、父类、分类中子类不实现load方法，调用情况<br>答：SuperClass-&gt;CategoryClass</p></li><li><p>场景3 ：子类、父类、分类1、分类2都实现load方法，调用情况<br>答：SuperClass-&gt;SubClass-&gt;Category1Class-&gt;Category2Class</p></li><li><p>initialize方法的本质<br>在类、或者子类，接收到第一条消息之前被执行（如初始化）<br>initialize方法最终通过objc_msgSend来执行<br>initialize方法在main函数之后调用<br>如果一直没有使用类，则initialize方法不会被调用<br>如果子类没有实现initialize方法，则会调用父类的initialize方法。</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">__private_extern__ void _class_initialize(Class cls)</span><br><span class="line">&#123;</span><br><span class="line">    Class supercls;</span><br><span class="line">    BOOL reallyInitialize = NO;</span><br><span class="line"></span><br><span class="line">    // Get the real class from the metaclass. The superclass chain </span><br><span class="line">    // hangs off the real class only.</span><br><span class="line">    cls = _class_getNonMetaClass(cls);</span><br><span class="line"></span><br><span class="line">    // Make sure super is done initializing BEFORE beginning to initialize cls.</span><br><span class="line">    // See note about deadlock above.</span><br><span class="line">    supercls = _class_getSuperclass(cls);</span><br><span class="line">    if (supercls  &amp;&amp;  !_class_isInitialized(supercls)) &#123;</span><br><span class="line">        _class_initialize(supercls);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // Try to atomically set CLS_INITIALIZING.</span><br><span class="line">    monitor_enter(&amp;classInitLock);</span><br><span class="line">    if (!_class_isInitialized(cls) &amp;&amp; !_class_isInitializing(cls)) &#123;</span><br><span class="line">        _class_setInitializing(cls);</span><br><span class="line">        reallyInitialize = YES;</span><br><span class="line">    &#125;</span><br><span class="line">    monitor_exit(&amp;classInitLock);</span><br><span class="line">    </span><br><span class="line">    if (reallyInitialize) &#123;</span><br><span class="line">        // We successfully set the CLS_INITIALIZING bit. Initialize the class.</span><br><span class="line">        </span><br><span class="line">        // Record that we&#x27;re initializing this class so we can message it.</span><br><span class="line">        _setThisThreadIsInitializingClass(cls);</span><br><span class="line">        </span><br><span class="line">        // Send the +initialize message.</span><br><span class="line">        // Note that +initialize is sent to the superclass (again) if </span><br><span class="line">        // this class doesn&#x27;t implement +initialize. 2157218</span><br><span class="line">        if (PrintInitializing) &#123;</span><br><span class="line">            _objc_inform(&quot;INITIALIZE: calling +[%s initialize]&quot;,</span><br><span class="line">                         _class_getName(cls));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ((void(*)(Class, SEL))objc_msgSend)(cls, SEL_initialize);</span><br><span class="line"></span><br><span class="line">        if (PrintInitializing) &#123;</span><br><span class="line">            _objc_inform(&quot;INITIALIZE: finished +[%s initialize]&quot;,</span><br><span class="line">                         _class_getName(cls));</span><br><span class="line">        &#125;        </span><br><span class="line">        </span><br><span class="line">        // Done initializing. </span><br><span class="line">        ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优先执行父类的initialize方法；通过_class_getSupercass取出父类，递归调用父类的initialize方法；initialize方法最终通过objc_msgSend来执行的。</p><ul><li>场景1 ：子类、父类都实现initialize方法，调用情况<br>答：SuperClass-&gt;SubClass</li><li>场景2 ：子类、父类中子类不实现initialize方法，调用情况<br>答：SuperClass-&gt;SuperClass（子类未实现，则会调用父类的initialize，导致父类调用多次）</li><li>场景3：子类、父类、子类分类都实现initialize方法，调用情况<br>答：SuperClass-&gt;CategoryClass（category中initialize方法覆盖其本类）</li><li>场景4：子类、父类、父类分类1、父类分类2都实现initialize方法，调用情况<br>答：CategoryClass-&gt;SubClass（category中initialize方法根据Compile Sources排序执行最后一个）</li></ul><p><strong>执行顺序</strong><br><strong>load</strong></p><p><img src="https://upload-images.jianshu.io/upload_images/2752635-5bb81894c906ac50.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/996/format/webp" alt=""></p><p>load.png</p><p>app启动自动加载所有load方法，load方法会在程序运行前加载一次。<br>1.先调用类的load，再调用分类的load<br>2.先编译的类，优先调用load，调用子类的load之前，会先调用父类的load<br>3.先编译的分类，优先调用load，顺序和Compile Sources中顺序一致</p><p><strong>initialize</strong></p><p><img src="https://upload-images.jianshu.io/upload_images/2752635-dceb1a8122903d4e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/943/format/webp" alt=""></p><p>initialize.png</p><p>initialize方法会在类或者子类在 第一次使用的时候调用，当有分类的时候会调用多次，如Son *s = [[Son alloc]init];<br>1.父类先于子类执行；（同load方法）<br>2.子类未实现，则会调用父类的initialize方法；<br>3.分类实现了initialize方法，则会覆盖类中的initialize方法（同category）；<br>4.存在多个分类，依赖Compile Sources中的顺序，执行最后一个分类的initialize方法（同category）；</p><p><strong>使用场景</strong><br>1.load通常用于Method Swizzle；<br>2.initialize可以用于初始化全局变量或静态变量；initialize方法可能被其分类中的initialize方法覆盖，导致无法调用。<br>**注意：**load和initialize方法内部使用了锁，因此他们是线程安全的。使用时避免阻塞线程，不要使用线程锁。</p><h4 id="10、如何理解copy-on-write？">10、如何理解copy-on-write？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">苹果建议当复制大的值类型数据的时候，使用写时复制技术，那什么是写时复制呢？我们现在看一段代码：</span><br><span class="line"></span><br><span class="line">值类型(比如:struct),在复制时,复制对象与原对象实际上在内存中指向同一个对象,当且仅当修改复制的对象时,才会在内存中创建一个新的对象</span><br><span class="line">为了提升性能，Struct, String、Array、Dictionary、Set采取了Copy On Write的技术</span><br><span class="line"></span><br><span class="line">比如仅当有“写”操作时，才会真正执行拷贝操作</span><br><span class="line"></span><br><span class="line">对于标准库值类型的赋值操作，Swift 能确保最佳性能，所有没必要为了保证最佳性能来避免赋值</span><br><span class="line">var array1: [Int] = [0, 1, 2, 3]</span><br><span class="line">var array2 = array1</span><br><span class="line"></span><br><span class="line">print(address: array1) //0x600000078de0</span><br><span class="line">print(address: array2) //0x600000078de0</span><br><span class="line"></span><br><span class="line">array2.append(4)</span><br><span class="line"></span><br><span class="line">print(address: array2) //0x6000000aa100</span><br><span class="line"></span><br><span class="line">我们看到当array2的值没有发生变化的时候，array1和array2指向同一个地址，但是当array2的发生变化时，array2指向地址也变了，很奇怪是吧。</span><br></pre></td></tr></table></figure><h3 id="UI">UI</h3><h4 id="1、UIView和CALayer的区别和联系？">1、UIView和CALayer的区别和联系？</h4><ul><li>UIView 继承 UIResponder，而 UIResponder 是响应者对象，可以对iOS 中的事件响应及传递，CALayer 没有继承自 UIResponder，所以 CALayer 不具备响应处理事件的能力。CALayer 是 QuartzCore 中的类，是一个比较底层的用来绘制内容的类，用来绘制UI</li><li>UIView 对 CALayer 封装属性，对 UIView 设置 frame、center、bounds 等位置信息时，其实都是UIView 对 CALayer 进一层封装，使得我们可以很方便地设置控件的位置；例如圆角、阴影等属性， UIView 就没有进一步封装，所以我们还是需要去设置 Layer 的属性来实现功能。</li><li>UIView 是 CALayer 的代理，UIView 持有一个 CALayer 的属性，并且是该属性的代理，用来提供一些 CALayer 行的数据，例如动画和绘制。</li></ul><h4 id="2、谈谈对UIResponder的理解？">2、谈谈对UIResponder的理解？</h4><p>UIResponder类是专门用来响应用户的操作处理各种事件的，包括触摸事件(Touch Events)、运动事件(Motion Events)、远程控制事件(Remote Control Events)。我们知道UIApplication、UIView、UIViewController这几个类是直接继承自UIResponder，所以这些类都可以响应事件。当然我们自定义的继承自UIView的View以及自定义的继承自UIViewController的控制器都可以响应事件。</p><ul><li>响应过程<br>iOS系统检测到手指触摸(Touch)操作时会将其打包成一个UIEvent对象，并放入当前活动Application的事件队列，单例的UIApplication会从事件队列中取出触摸事件并传递给单例的UIWindow来处理，UIWindow对象首先会使用<code>hitTest:withEvent:</code>方法寻找此次Touch操作初始点所在的视图(View)，即需要将触摸事件传递给其处理的视图(最合适来处理的控件)，这个过程称之为hit-test view。<br><strong>那么什么是最适合来处理事件的控件?</strong><br>1.自己能响应触摸事件<br>2.触摸点在自己身上<br>3.从后往前递归遍历子控件, 重复上两步<br>4.如果没有符合条件的子控件, 那么就自己最合适处理</li></ul><ol><li><code>hitTest:withEvent:</code>事件传递给控件的时候， 就会调用该方法，去寻找最合适的view并返回看可以响应的view</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event &#123;</span><br><span class="line">    // 1.如果控件不允许与用用户交互,那么返回nil</span><br><span class="line">    if (self.userInteractionEnabled == NO || self.alpha &lt;= 0.01 || self.hidden == YES)&#123;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    // 2\. 如果点击的点在不在当前控件中,返回nil</span><br><span class="line">    if (![self pointInside:point withEvent:event])&#123;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    // 3.从后往前遍历每一个子控件</span><br><span class="line">    for(int i = (int)self.subviews.count - 1 ; i &gt;= 0 ;i--)&#123;</span><br><span class="line">        // 3.1获取一个子控件</span><br><span class="line">        UIView *childView = self.subviews[i];</span><br><span class="line">        // 3.2当前触摸点的坐标转换为相对于子控件触摸点的坐标</span><br><span class="line">        CGPoint childP = [self convertPoint:point toView:childView];</span><br><span class="line">        // 3.3判断是否在在子控件中找到了更合适的子控件(递归循环)</span><br><span class="line">        UIView *fitView = [childView hitTest:childP withEvent:event];</span><br><span class="line">        // 3.4如果找到了就返回</span><br><span class="line">        if (fitView) &#123;</span><br><span class="line">            return fitView;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 4.没找到,表示没有比自己更合适的view,返回自己</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><code>pointInside:withEvent:</code>该方法判断触摸点是否在控件身上，是则返回YES，否则返回NO，point参数必须是方法调用者的坐标系.</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)pointInside:(CGPoint)point withEvent:(UIEvent *)event &#123;</span><br><span class="line">    return NO;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="3、loadView的作用？">3、loadView的作用？</h4><p>loadView方法会在每次访问UIViewController的view(比如controller.view、self.view)而且view为nil时会被调用，此方法主要用来负责创建UIViewController的view(重写loadView方法，并且不需要调用[super loadView])<br>[super loadView]执行流程：</p><ul><li>它会先去查找与UIViewController相关联的xib文件，通过加载xib文件来创建UIViewController的view，如果在初始化UIViewController指定了xib文件名，就会根据传入的xib文件名加载对应的xib文件，如果没有明显地传xib文件名，就会加载跟UIViewController同名的xib文件</li><li>如果没有找到相关联的xib文件，就会创建一个空白的UIView，然后赋值给UIViewController的view属性</li><li>综上，在需要自定义UIViewController的view时，可以通过重写loadView方法且不需要调用[super loadView]方法。</li></ul><h3 id="内存管理">内存管理</h3><h3 id="RunLoop">RunLoop</h3><h4 id="1、RunLoop-的本质是什么？">1、RunLoop 的本质是什么？</h4><p>“Run loops are part of thefundamental infrastructure associated withthreads. A run loop is an event processing loopthat you use to schedule work and coordinatethe receipt of incoming events. The purpose ofa runloop is to keep your thread busy whenthere is work to do and put your thread tosleep when there is none.”</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">typedef struct CF_BRIDGED_MUTABLE_TYPE(id) __CFRunLoop * CFRunLoopRef;</span><br><span class="line"></span><br><span class="line">struct __CFRunLoop &#123;</span><br><span class="line">    CFRuntimeBase _base;</span><br><span class="line">    pthread_mutex_t _lock;          /* locked for accessing mode list */</span><br><span class="line">    //mach_port</span><br><span class="line">    __CFPort _wakeUpPort;           // used for CFRunLoopWakeUp </span><br><span class="line">    Boolean _unused;</span><br><span class="line">    volatile _per_run_data *_perRunData;              // reset for runs of the run loop</span><br><span class="line">    pthread_t _pthread;</span><br><span class="line">    uint32_t _winthread;</span><br><span class="line">    CFMutableSetRef _commonModes;</span><br><span class="line">    CFMutableSetRef _commonModeItems;</span><br><span class="line">    CFRunLoopModeRef _currentMode;</span><br><span class="line">    CFMutableSetRef _modes;</span><br><span class="line">    struct _block_item *_blocks_head;</span><br><span class="line">    struct _block_item *_blocks_tail;</span><br><span class="line">    CFAbsoluteTime _runTime;</span><br><span class="line">    CFAbsoluteTime _sleepTime;</span><br><span class="line">    CFTypeRef _counterpart;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>1.NSRunLoop只是比CFRunLoop多了一层简单的OC封装，底层还是CFRunLoop，CFRunLoop本质是一个结构体，而NSRunLoop是一个NSObject对象。NSRunLoop存在于Foundation框架中，CFRunLoop是存在于CoreFoundation框架中的。NSRunLoop不是线程安全的，CFRunLoop时候线程安全的。</p><p>2.RunLoop是一个与线程相关的底层机制，用来接收事件和调度任务。runloop目的是让线程在有工作的时候保持忙碌，在没有工作的时候睡眠。</p><p>3.RunLoop是与线程相关的，它们的关系一一对应：一个线程只能对应一个RunLoop，即在某一时刻，一个线程只能运行在某一个RunLoop上。当运行一个应用程序的时候，系统会为应用程序的主线程创建一个RunLoop用来处理主线程上的事件，例如UI刷新和触屏事件。因此，开发者不需要为主线程显式地创建和运行一个RunLoop，而子线程需要显式地运行一个RunLoop，再将辅助线程放到RunLoop中运行，否则线程不会自动开启RunLoop。</p><h4 id="2、Runloop和线程是什么关系？">2、Runloop和线程是什么关系？</h4><p>线程和 RunLoop 之间是Key-value的对应关系，是保存在一个全局的 Dictionary 里，线程是key，RunLoop是value，而且是懒加载的。</p><h4 id="3、Runloop的底层数据结构是什么样的？有几种运行模式（mode）？每个运行模式下面的CFRunloopMode是哪些？他们分别是什么职责？">3、Runloop的底层数据结构是什么样的？有几种运行模式（mode）？每个运行模式下面的CFRunloopMode是哪些？他们分别是什么职责？</h4><ul><li><strong>Mode</strong>，运行模式</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">struct __CFRunLoopMode &#123;</span><br><span class="line">    CFRuntimeBase _base;</span><br><span class="line">    pthread_mutex_t _lock;  /* must have the run loop locked before locking this */</span><br><span class="line">    CFStringRef _name;     // mode名称</span><br><span class="line">    Boolean _stopped;      // mode是否被终止</span><br><span class="line">    char _padding[3];</span><br><span class="line">    // 几种事件，下面这四个字段，在苹果官方文档里面称为Item</span><br><span class="line">    // RunLoop中有个commomitems字段，里面就是保存的下面这些内容</span><br><span class="line">    CFMutableSetRef _sources0;</span><br><span class="line">    CFMutableSetRef _sources1;</span><br><span class="line">    CFMutableArrayRef _observers;</span><br><span class="line">    CFMutableArrayRef _timers;</span><br><span class="line">    CFMutableDictionaryRef _portToV1SourceMap;   //字典  key是mach_port_t，value是CFRunLoopSourceRef</span><br><span class="line">    __CFPortSet _portSet;    //保存所有需要监听的port，比如_wakeUpPort，_timerPort都保存在这个数组中</span><br><span class="line">    CFIndex _observerMask;</span><br><span class="line">#if USE_DISPATCH_SOURCE_FOR_TIMERS</span><br><span class="line">    dispatch_source_t _timerSource;</span><br><span class="line">    dispatch_queue_t _queue;</span><br><span class="line">    Boolean _timerFired; // set to true by the source when a timer has fired</span><br><span class="line">    Boolean _dispatchTimerArmed;</span><br><span class="line">#endif</span><br><span class="line">#if USE_MK_TIMER_TOO</span><br><span class="line">    mach_port_t _timerPort;</span><br><span class="line">    Boolean _mkTimerArmed;</span><br><span class="line">#endif</span><br><span class="line">#if DEPLOYMENT_TARGET_WINDOWS</span><br><span class="line">    DWORD _msgQMask;</span><br><span class="line">    void (*_msgPump)(void);</span><br><span class="line">#endif</span><br><span class="line">    uint64_t _timerSoftDeadline; /* TSR */</span><br><span class="line">    uint64_t _timerHardDeadline; /* TSR */</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol><li><p>模式（Mode）指的是一个包括输入源（Inputsource）、定时器（Timer）、观察者（Observer）的模型对象。简单点来说，模式就是用来存储runloop需要响应的事件，这些事件包括许多输入源、定时器和观察者。</p></li><li><p>系统默认注册5个Mode:<br>1.<strong>NSDefaultRunLoopMode：</strong> App的默认Mode,通常主线程是在这个Mode下运行<br>2.**UITrackingRunLoopMode：**界面跟踪Mode,用于ScrollView`追踪触摸滑动，保证界面滑动时不受其他Mode影响。<br>3.**NSRunLoopCommonModes：**并不是一个真的模式，它只是一个标记，如：被标记的 Timer可以在Default模式和UITracking下运行。<br>4.**UIInitializationRunLoopMode：**私有的mode，App启动的时候的状态，加载出第一个页面后，就转成了Default，通常用不到<br>5.**GSEventReceiveRunLoopMode：**系统的内部 Mode，通常用不到</p></li></ol><ul><li><strong>Source</strong>，输入源/事件源</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//CFRunLoop.h</span><br><span class="line">typedef struct __CFRunLoopSource *CFRunLoopSourceRef;</span><br><span class="line">//CFRunLoop.c</span><br><span class="line">struct __CFRunLoopSource&#123;</span><br><span class="line">    CFRuntimeBase _base;//</span><br><span class="line">    uint32_t _bits;</span><br><span class="line">    pthread_mutex_t lock;</span><br><span class="line">    CFIndex _order;  /*immutable*/</span><br><span class="line">    CFMutableBagRef _runLoops;</span><br><span class="line">    union&#123;</span><br><span class="line">        CFRunLoopSourceContext version0; /*immutable,except invalidation*/</span><br><span class="line">        CFRunLoopSourceContext1 version1; /*immutable,except invalidattion*/</span><br><span class="line">    &#125;_context;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>1.联合体的作用是共享存储空间，也就是说，version0和version1两个变量共享一段存储空间，一个__CFRunLoopSource结构体变量要么对应version0类型的事件源，要么对应version1类型的事件源。其中，version0和version1分别在源码中对应事件源Source0和Source1。</p><p>2.Source0对应需要手动触发的事件，对应官方文档Input Source中的Custom和performSelector:onThread事件源。</p><p>3.Source1表示基于端口触发的事件，对应官方文档Input Source中Port的事件源。</p><ul><li><strong>Timer</strong>，定时源</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">struct __CFRunLoopTimer &#123;</span><br><span class="line">    CFRuntimeBase _base;</span><br><span class="line">    uint16_t _bits;  //标记fire状态</span><br><span class="line">    pthread_mutex_t _lock;</span><br><span class="line">    CFRunLoopRef _runLoop;        //添加该timer的runloop</span><br><span class="line">    CFMutableSetRef _rlModes;     //存放所有 包含该timer的 mode的 modeName，意味着一个timer可能会在多个mode中存在</span><br><span class="line">    CFAbsoluteTime _nextFireDate;</span><br><span class="line">    CFTimeInterval _interval;     //理想时间间隔  /* immutable */</span><br><span class="line">    CFTimeInterval _tolerance;    //时间偏差      /* mutable */</span><br><span class="line">    uint64_t _fireTSR;          /* TSR units */</span><br><span class="line">    CFIndex _order;         /* immutable */</span><br><span class="line">    CFRunLoopTimerCallBack _callout;    /* immutable */</span><br><span class="line">    CFRunLoopTimerContext _context; /* immutable, except invalidation */</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>__CFRunLoopTimer是一个基于mk_timer实现的定时器，通过_callout回调实现定时执行任务。NSTimer其实是对CFRunLoopTimerRef的一个上层封装。</p><ul><li><strong>Observer</strong>，观察者</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">struct __CFRunLoopObserver &#123;</span><br><span class="line">    CFRuntimeBase _base;</span><br><span class="line">    pthread_mutex_t _lock;</span><br><span class="line">    CFRunLoopRef _runLoop;   //添加该Observer的RunLoop</span><br><span class="line">    CFIndex _rlCount;</span><br><span class="line">    CFOptionFlags _activities;      /* immutable */</span><br><span class="line">    CFIndex _order;         /* immutable */</span><br><span class="line">    CFRunLoopObserverCallBack _callout;     //设置回调函数，回调指针  /* immutable */</span><br><span class="line">    CFRunLoopObserverContext _context;  /* immutable, except invalidation */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>CFRunLoopObserver是观察者，可以观察RunLoop的各种状态，每个 Observer 都包含了一个回调（也就是上面的CFRunLoopObserverCallBack函数指针），当 RunLoop 的状态发生变化时，观察者就能通过回调接受到这个变化。</p><h4 id="4、Runloop-的监听状态有哪几种？">4、Runloop 的监听状态有哪几种？</h4><p>Entry-&gt;BeforeTimers-&gt;BeforeSources-&gt;BeforeWaiting(休眠)-&gt;AfterWaiting(唤醒)-&gt;Exit-&gt;AllActivities</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/* Run Loop Observer Activities */</span><br><span class="line">typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) &#123;</span><br><span class="line">    kCFRunLoopEntry = (1UL &lt;&lt; 0),                 // 即将进入Loop</span><br><span class="line">    kCFRunLoopBeforeTimers = (1UL &lt;&lt; 1),          // 即将处理Timer</span><br><span class="line">    kCFRunLoopBeforeSources = (1UL &lt;&lt; 2),         // 即将处理Source</span><br><span class="line">    kCFRunLoopBeforeWaiting = (1UL &lt;&lt; 5),         // 即将进入休眠</span><br><span class="line">    kCFRunLoopAfterWaiting = (1UL &lt;&lt; 6),          // 刚从休眠中唤醒</span><br><span class="line">    kCFRunLoopExit = (1UL &lt;&lt; 7),                  // 即将退出Loop</span><br><span class="line">    kCFRunLoopAllActivities = 0x0FFFFFFFU         // 所有状态</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>1）kCFRunLoopEntry表示刚进入runloop的时候。<br>2）kCFRunLoopBeforeTimers表示将要处理timer。<br>3）kCFRunLoopBeforeSources表示将要处理Source。<br>4）kCFRunLoopBeforeWaiting表示将要进入休眠状态。<br>5）kCFRunLoopAfterWaiting表示将要从休眠状态进入唤醒状态。<br>6）kCFRunLoopExit表示退出状态。<br>7）kCFRunLoopAllActivities表示所有1）～6）中的状态。</p><h4 id="5、Runloop-的工作流程？">5、Runloop 的工作流程？</h4><p><img src="https://upload-images.jianshu.io/upload_images/2752635-727254256ae06203.png" alt=""></p><p>Runloop 的工作流程.png</p><p>内部逻辑：</p><ol><li>通知 Observer 已经进入了 RunLoop</li><li>通知 Observer 即将处理 Timer</li><li>通知 Observer 即将处理非基于端口的输入源（即将处理 Source0）</li><li>处理那些准备好的非基于端口的输入源（处理 Source0）</li><li>如果基于端口的输入源准备就绪并等待处理，请立刻处理该事件。转到第 9 步（处理 Source1）</li><li>通知 Observer 线程即将休眠</li><li>将线程置于休眠状态，直到发生以下事件之一</li></ol><ul><li>事件到达基于端口的输入源（port-based input sources）(也就是 Source0)</li><li>Timer 到时间执行</li><li>外部手动唤醒</li><li>为 RunLoop 设定的时间超时</li></ul><ol start="8"><li>通知 Observer 线程刚被唤醒（还没处理事件）</li><li>处理待处理事件</li></ol><ul><li>如果是 Timer 事件，处理 Timer 并重新启动循环，跳到第 2 步</li><li>如果输入源被触发，处理该事件（文档上是 deliver the event）</li><li>如果 RunLoop 被手动唤醒但尚未超时，重新启动循环，跳到第 2 步</li></ul><h4 id="6、Runloop-有哪些应用？">6、Runloop 有哪些应用？</h4><p>滑动scrollview时候的mode切换，cell的图片下载 将多个耗时操作分开执行，在每次 RunLoop唤醒时去做一个耗时任务。</p><h4 id="7、Runloop的内核态和用户态？">7、Runloop的内核态和用户态？</h4><ul><li>用户态-&gt;内核态 没有消息需要处理时，休眠以避免资源占用；</li><li>内核态-&gt;用户态 有消息需要处理时，立刻被唤醒。</li></ul><h4 id="8、点击APP图标，从程序启动、运行、退出这个过程当中，系统都发生了什么？">8、点击APP图标，从程序启动、运行、退出这个过程当中，系统都发生了什么？</h4><ul><li>程序启动后，调用<code>main</code>函数后，会调用<code>UIApplicationmain</code>函数，此函数内部会启动主线程的RunLoop，经过一系列处理，最终主线程RunLoop处于休眠状态；</li><li>如果此时点击了屏幕，会产生一个mach_port，基于mach_port最终转成Source1，唤醒主线程，运行处理；</li><li>当把程序杀死后，RunLoop退出，并且发送通知给观察者。RunLoop退出后线程即刻销毁。</li></ul><h3 id="Runtime">Runtime</h3><h4 id="1、概念">1、概念</h4><ul><li>oc是一门动态语言，所谓动态语言就是在编译阶段无法确定调用的函数以及属性的类型，只有在运行阶段首次确定类型和调用的函数。</li><li>Runtime就是动态语言下核心的一个库，底层都会通过<code>objc_msgSend</code>来处理消息转发机制。也是因为拥有Runtime使得oc语言灵活性比较强，能够具有动态、动态绑定、动态解析的特性。</li></ul><ol><li><strong>objc_msgSend</strong></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/* Basic Messaging Primitives</span><br><span class="line">*</span><br><span class="line">* On some architectures, use objc_msgSend_stret for some struct return types.</span><br><span class="line">* On some architectures, use objc_msgSend_fpret for some float return types.</span><br><span class="line">* On some architectures, use objc_msgSend_fp2ret for some float return types.</span><br><span class="line">*</span><br><span class="line">* These functions must be cast to an appropriate function pointer type </span><br><span class="line">* before being called. </span><br><span class="line">*/</span><br></pre></td></tr></table></figure><p>这是官方的声明，这是个最基本的用于发送消息的函数。另外，这个函数并不能发送所有类型的消息，只能发送基本的消息。比如，在一些处理器上，我们必须使用<code>objc_msgSend_stret</code>来发送返回值类型为结构体的消息，使用<code>objc_msgSend_fpret</code>来发送返回值类型为浮点类型的消息，而又在一些处理器上，还得使用<code>objc_msgSend_fp2ret</code>来发送返回值类型为浮点类型的消息。要调用<code>objc_msgSend</code>函数，必须要将函数强制转换成合适的函数指针类型才能调用。<br>从<code>objc_msgSend</code>函数的声明来看，它应该是不带返回值的，但是我们在使用中却可以强制转换类型，以便接收返回值。另外，它的参数列表是可以任意多个的，前提也是要强制函数指针类型。<br>编译器会根据情况在<code>objc_msgSend</code>, <code>objc_msgSend_stret</code>, <code>objc_msgSendSuper</code>, 或 <code>objc_msgSendSuper_stret</code>四个方法中选择一个来调用。如果消息是传递给超类，那么会调用名字带有<code>”Super”</code>的函数；如果消息返回值是数据结构而不是简单值时，那么会调用名字带有<code>”stret”</code>的函数。</p><ol start="2"><li><strong>id</strong></li></ol><p><code>objc_msgSend</code>第一个参数类型为id，它是一个指向objc_object结构体的指针：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line">typedef struct objc_object *id;</span><br><span class="line"></span><br><span class="line">struct objc_object &#123;</span><br><span class="line">private:</span><br><span class="line">    isa_t isa;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">    // ISA() assumes this is NOT a tagged pointer object</span><br><span class="line">    Class ISA();</span><br><span class="line"></span><br><span class="line">    // rawISA() assumes this is NOT a tagged pointer object or a non pointer ISA</span><br><span class="line">    Class rawISA();</span><br><span class="line"></span><br><span class="line">    // getIsa() allows this to be a tagged pointer object</span><br><span class="line">    Class getIsa();</span><br><span class="line">    </span><br><span class="line">    uintptr_t isaBits() const;</span><br><span class="line"></span><br><span class="line">    // initIsa() should be used to init the isa of new objects only.</span><br><span class="line">    // If this object already has an isa, use changeIsa() for correctness.</span><br><span class="line">    // initInstanceIsa(): objects with no custom RR/AWZ</span><br><span class="line">    // initClassIsa(): class objects</span><br><span class="line">    // initProtocolIsa(): protocol objects</span><br><span class="line">    // initIsa(): other objects</span><br><span class="line">    void initIsa(Class cls /*nonpointer=false*/);</span><br><span class="line">    void initClassIsa(Class cls /*nonpointer=maybe*/);</span><br><span class="line">    void initProtocolIsa(Class cls /*nonpointer=maybe*/);</span><br><span class="line">    void initInstanceIsa(Class cls, bool hasCxxDtor);</span><br><span class="line"></span><br><span class="line">    // changeIsa() should be used to change the isa of existing objects.</span><br><span class="line">    // If this is a new object, use initIsa() for performance.</span><br><span class="line">    Class changeIsa(Class newCls);</span><br><span class="line"></span><br><span class="line">    bool hasNonpointerIsa();</span><br><span class="line">    bool isTaggedPointer();</span><br><span class="line">    bool isBasicTaggedPointer();</span><br><span class="line">    bool isExtTaggedPointer();</span><br><span class="line">    bool isClass();</span><br><span class="line"></span><br><span class="line">    // object may have associated objects?</span><br><span class="line">    bool hasAssociatedObjects();</span><br><span class="line">    void setHasAssociatedObjects();</span><br><span class="line"></span><br><span class="line">    // object may be weakly referenced?</span><br><span class="line">    bool isWeaklyReferenced();</span><br><span class="line">    void setWeaklyReferenced_nolock();</span><br><span class="line"></span><br><span class="line">    // object may have -.cxx_destruct implementation?</span><br><span class="line">    bool hasCxxDtor();</span><br><span class="line"></span><br><span class="line">    // Optimized calls to retain/release methods</span><br><span class="line">    id retain();</span><br><span class="line">    void release();</span><br><span class="line">    id autorelease();</span><br><span class="line"></span><br><span class="line">    // Implementations of retain/release methods</span><br><span class="line">    id rootRetain();</span><br><span class="line">    bool rootRelease();</span><br><span class="line">    id rootAutorelease();</span><br><span class="line">    bool rootTryRetain();</span><br><span class="line">    bool rootReleaseShouldDealloc();</span><br><span class="line">    uintptr_t rootRetainCount();</span><br><span class="line"></span><br><span class="line">    // Implementation of dealloc methods</span><br><span class="line">    bool rootIsDeallocating();</span><br><span class="line">    void clearDeallocating();</span><br><span class="line">    void rootDealloc();</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    void initIsa(Class newCls, bool nonpointer, bool hasCxxDtor);</span><br><span class="line"></span><br><span class="line">    // Slow paths for inline control</span><br><span class="line">    id rootAutorelease2();</span><br><span class="line">    uintptr_t overrelease_error();</span><br><span class="line"></span><br><span class="line">#if SUPPORT_NONPOINTER_ISA</span><br><span class="line">    // Unified retain count manipulation for nonpointer isa</span><br><span class="line">    id rootRetain(bool tryRetain, bool handleOverflow);</span><br><span class="line">    bool rootRelease(bool performDealloc, bool handleUnderflow);</span><br><span class="line">    id rootRetain_overflow(bool tryRetain);</span><br><span class="line">    uintptr_t rootRelease_underflow(bool performDealloc);</span><br><span class="line"></span><br><span class="line">    void clearDeallocating_slow();</span><br><span class="line"></span><br><span class="line">    // Side table retain count overflow for nonpointer isa</span><br><span class="line">    void sidetable_lock();</span><br><span class="line">    void sidetable_unlock();</span><br><span class="line"></span><br><span class="line">    void sidetable_moveExtraRC_nolock(size_t extra_rc, bool isDeallocating, bool weaklyReferenced);</span><br><span class="line">    bool sidetable_addExtraRC_nolock(size_t delta_rc);</span><br><span class="line">    size_t sidetable_subExtraRC_nolock(size_t delta_rc);</span><br><span class="line">    size_t sidetable_getExtraRC_nolock();</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    // Side-table-only retain count</span><br><span class="line">    bool sidetable_isDeallocating();</span><br><span class="line">    void sidetable_clearDeallocating();</span><br><span class="line"></span><br><span class="line">    bool sidetable_isWeaklyReferenced();</span><br><span class="line">    void sidetable_setWeaklyReferenced_nolock();</span><br><span class="line"></span><br><span class="line">    id sidetable_retain();</span><br><span class="line">    id sidetable_retain_slow(SideTable&amp; table);</span><br><span class="line"></span><br><span class="line">    uintptr_t sidetable_release(bool performDealloc = true);</span><br><span class="line">    uintptr_t sidetable_release_slow(SideTable&amp; table, bool performDealloc = true);</span><br><span class="line"></span><br><span class="line">    bool sidetable_tryRetain();</span><br><span class="line"></span><br><span class="line">    uintptr_t sidetable_retainCount();</span><br><span class="line">#if DEBUG</span><br><span class="line">    bool sidetable_present();</span><br><span class="line">#endif</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>objc_object</code>结构体包含一个isa指针，根据isa指针就可以找到对象所属的类。<br>注意:isa指针不总是指向实例对象所属的类，不能依靠它来确定类型，而是应该用class方法来确定实例对象的类。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">union isa_t &#123;</span><br><span class="line">    isa_t() &#123; &#125;</span><br><span class="line">    isa_t(uintptr_t value) : bits(value) &#123; &#125;</span><br><span class="line"></span><br><span class="line">    Class cls;</span><br><span class="line">    uintptr_t bits;</span><br><span class="line">#if defined(ISA_BITFIELD)</span><br><span class="line">    struct &#123;</span><br><span class="line">        ISA_BITFIELD;  // defined in isa.h</span><br><span class="line">    &#125;;</span><br><span class="line">#endif</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"># if __arm64__</span><br><span class="line">// ARM64 simulators have a larger address space, so use the ARM64e</span><br><span class="line">// scheme even when simulators build for ARM64-not-e.</span><br><span class="line">#   if __has_feature(ptrauth_calls) || TARGET_OS_SIMULATOR</span><br><span class="line">#     define ISA_MASK        0x007ffffffffffff8ULL</span><br><span class="line">#     define ISA_MAGIC_MASK  0x0000000000000001ULL</span><br><span class="line">#     define ISA_MAGIC_VALUE 0x0000000000000001ULL</span><br><span class="line">#     define ISA_HAS_CXX_DTOR_BIT 0</span><br><span class="line">#     define ISA_BITFIELD                                                      \</span><br><span class="line">        uintptr_t nonpointer        : 1;                                       \</span><br><span class="line">        uintptr_t has_assoc         : 1;                                       \</span><br><span class="line">        uintptr_t weakly_referenced : 1;                                       \</span><br><span class="line">        uintptr_t shiftcls_and_sig  : 52;                                      \</span><br><span class="line">        uintptr_t has_sidetable_rc  : 1;                                       \</span><br><span class="line">        uintptr_t extra_rc          : 8</span><br><span class="line">#     define ISA_HAS_INLINE_RC    1</span><br><span class="line">#     define RC_HAS_SIDETABLE_BIT 55</span><br><span class="line">#     define RC_ONE_BIT           (RC_HAS_SIDETABLE_BIT+1)</span><br><span class="line">#     define RC_ONE               (1ULL&lt;&lt;RC_ONE_BIT)</span><br><span class="line">#     define RC_HALF              (1ULL&lt;&lt;7)</span><br><span class="line">#   else</span><br><span class="line">#     define ISA_MASK        0x0000000ffffffff8ULL</span><br><span class="line">#     define ISA_MAGIC_MASK  0x000003f000000001ULL</span><br><span class="line">#     define ISA_MAGIC_VALUE 0x000001a000000001ULL</span><br><span class="line">#     define ISA_HAS_CXX_DTOR_BIT 1</span><br><span class="line">#     define ISA_BITFIELD                                                      \</span><br><span class="line">        uintptr_t nonpointer        : 1;                                       \</span><br><span class="line">        uintptr_t has_assoc         : 1;                                       \</span><br><span class="line">        uintptr_t has_cxx_dtor      : 1;                                       \</span><br><span class="line">        uintptr_t shiftcls          : 33; /*MACH_VM_MAX_ADDRESS 0x1000000000*/ \</span><br><span class="line">        uintptr_t magic             : 6;                                       \</span><br><span class="line">        uintptr_t weakly_referenced : 1;                                       \</span><br><span class="line">        uintptr_t unused            : 1;                                       \</span><br><span class="line">        uintptr_t has_sidetable_rc  : 1;                                       \</span><br><span class="line">        uintptr_t extra_rc          : 19</span><br><span class="line">#     define ISA_HAS_INLINE_RC    1</span><br><span class="line">#     define RC_HAS_SIDETABLE_BIT 44</span><br><span class="line">#     define RC_ONE_BIT           (RC_HAS_SIDETABLE_BIT+1)</span><br><span class="line">#     define RC_ONE               (1ULL&lt;&lt;RC_ONE_BIT)</span><br><span class="line">#     define RC_HALF              (1ULL&lt;&lt;18)</span><br><span class="line">#   endif</span><br></pre></td></tr></table></figure><p>所以在isa_t联合体中Class cls和uintptr_t bits是互斥的。<br>由 typedef unsigned long uintptr_t; 所知，bits占据8字节，共64位，64位中存储的即ISA_BITFIELD宏定义中的内容。</p><p>uintptr_t nonpointer : 1; 是否对isa指针开启优化。0:纯isa指针 1:不只类对象地址，还包括了类信息，对象对引用计数等。<br>uintptr_t has_assoc : 1; 关联对象标识位 0:没有 1:存在。<br>uintptr_t has_cxx_dtor : 1; 是否有c++或objc的析构函数 如果有则需要调用析构逻辑，如果没有则可以更快释放对象。<br>uintptr_t shiftcls : 33; 存储类指针的值，开启指针优化时，有33位用来存放类指针。<br>uintptr_t magic : 6; 用于调试器判断当前对象是真的对象还是未初始化的空间。<br>uintptr_t weakly_referenced : 1; 标志对象是否被指向或曾经指向一个ARC的弱变量，没有弱引用的对象可以更快的释放。<br>uintptr_t deallocating : 1; 标志对象是否正在释放内存。<br>uintptr_t has_sidetable_rc : 1; 当引用计数大于10时，则需要借助该变量存储进位。<br>uintptr_t extra_rc : 19 表示该对象的引用计数减1，如果引用计数为10，则extra_rc为9，如果引用计数大于10，则需要借助has_sidetable_rc。</p><ol start="3"><li><p><strong>SEL</strong><br>SEL其实是一个指向objc_selector结构体的指针：<code>typedef struct objc_selector *SEL</code>;<br><code>objc_msgSend</code>函数第二个参数类型为SEL，它是<code>selector</code>在Objc中的表示类型（Swift中是Selector类）。<br>其实它就是个映射到方法的C字符串，你可以用 Objc 编译器命令<code>@selector()</code>或者 Runtime 系统的<code>sel_registerName</code>函数来获得一个SEL类型的方法选择器。</p></li><li><p><strong>Class</strong></p></li></ol><p>Class其实是一个指向objc_class结构体的指针：<br><code>typedef struct objc_class *Class</code>;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">struct objc_class : objc_object &#123;</span><br><span class="line">    // Class ISA;</span><br><span class="line">    Class superclass;</span><br><span class="line">    cache_t cache;             // formerly cache pointer and vtable</span><br><span class="line">    class_data_bits_t bits;    // class_rw_t * plus custom rr/alloc flags</span><br><span class="line">    </span><br><span class="line">    class_rw_t *data() const &#123;</span><br><span class="line">        return bits.data();</span><br><span class="line">    &#125;</span><br><span class="line">    void setData(class_rw_t *newData) &#123;</span><br><span class="line">        bits.setData(newData);</span><br><span class="line">    &#125;</span><br><span class="line">    const class_ro_t *safe_ro() const &#123;</span><br><span class="line">        return bits.safe_ro();</span><br><span class="line">    &#125;</span><br><span class="line">    .....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">struct class_data_bits_t &#123;</span><br><span class="line">    friend objc_class;</span><br><span class="line">    class_rw_t* data() const &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">    void setData(class_rw_t *newData)</span><br><span class="line">    &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    const class_ro_t *safe_ro() const &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">struct cache_t &#123;</span><br><span class="line">    explicit_atomic&lt;uintptr_t&gt; _bucketsAndMaybeMask;</span><br><span class="line">    // _bucketsAndMaybeMask is a buckets_t pointer in the top 28 bits</span><br><span class="line">    union &#123;</span><br><span class="line">        // Note: _flags on ARM64 needs to line up with the unused bits of</span><br><span class="line">        // _originalPreoptCache because we access some flags (specifically</span><br><span class="line">        // FAST_CACHE_HAS_DEFAULT_CORE and FAST_CACHE_HAS_DEFAULT_AWZ) on</span><br><span class="line">        // unrealized classes with the assumption that they will start out</span><br><span class="line">        // as 0.</span><br><span class="line">        struct &#123;</span><br><span class="line">#if CACHE_MASK_STORAGE == CACHE_MASK_STORAGE_OUTLINED &amp;&amp; !__LP64__</span><br><span class="line">            // Outlined cache mask storage, 32-bit, we have mask and occupied.</span><br><span class="line">            explicit_atomic&lt;mask_t&gt;    _mask;</span><br><span class="line">            uint16_t                   _occupied;</span><br><span class="line">#elif CACHE_MASK_STORAGE == CACHE_MASK_STORAGE_OUTLINED &amp;&amp; __LP64__</span><br><span class="line">            // Outlined cache mask storage, 64-bit, we have mask, occupied, flags.</span><br><span class="line">            explicit_atomic&lt;mask_t&gt;    _mask;</span><br><span class="line">            uint16_t                   _occupied;</span><br><span class="line">            uint16_t                   _flags;</span><br><span class="line">#   define CACHE_T_HAS_FLAGS 1</span><br><span class="line">#elif __LP64__</span><br><span class="line">            // Inline cache mask storage, 64-bit, we have occupied, flags, and</span><br><span class="line">            // empty space to line up flags with originalPreoptCache.</span><br><span class="line">            //</span><br><span class="line">            // Note: the assembly code for objc_release_xN knows about the</span><br><span class="line">            // location of _flags and the</span><br><span class="line">            // FAST_CACHE_HAS_CUSTOM_DEALLOC_INITIATION flag within. Any changes</span><br><span class="line">            // must be applied there as well.</span><br><span class="line">            uint32_t                   _unused;</span><br><span class="line">            uint16_t                   _occupied;</span><br><span class="line">            uint16_t                   _flags;</span><br><span class="line">#   define CACHE_T_HAS_FLAGS 1</span><br><span class="line">#else</span><br><span class="line">            // Inline cache mask storage, 32-bit, we have occupied, flags.</span><br><span class="line">            uint16_t                   _occupied;</span><br><span class="line">            uint16_t                   _flags;</span><br><span class="line">#   define CACHE_T_HAS_FLAGS 1</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">        &#125;;</span><br><span class="line">        explicit_atomic&lt;preopt_cache_t *&gt; _originalPreoptCache;</span><br><span class="line">    &#125;;</span><br><span class="line">    ...</span><br><span class="line">public:</span><br><span class="line">    // The following four fields are public for objcdt&#x27;s use only.</span><br><span class="line">    // objcdt reaches into fields while the process is suspended</span><br><span class="line">    // hence doesn&#x27;t care for locks and pesky little details like this</span><br><span class="line">    // and can safely use these.</span><br><span class="line">    unsigned capacity() const;</span><br><span class="line">    struct bucket_t *buckets() const;</span><br><span class="line">    Class cls() const;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">struct bucket_t &#123;</span><br><span class="line">private:</span><br><span class="line">    // IMP-first is better for arm64e ptrauth and no worse for arm64.</span><br><span class="line">    // SEL-first is better for armv7* and i386 and x86_64.</span><br><span class="line">#if __arm64__</span><br><span class="line">    explicit_atomic&lt;uintptr_t&gt; _imp;</span><br><span class="line">    explicit_atomic&lt;SEL&gt; _sel;</span><br><span class="line">#else</span><br><span class="line">    explicit_atomic&lt;SEL&gt; _sel;</span><br><span class="line">    explicit_atomic&lt;uintptr_t&gt; _imp;</span><br><span class="line">#endif</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">struct class_rw_t &#123;</span><br><span class="line">    ...</span><br><span class="line">    explicit_atomic&lt;uintptr_t&gt; ro_or_rw_ext;</span><br><span class="line">    ...</span><br><span class="line">private:</span><br><span class="line">    using ro_or_rw_ext_t = objc::PointerUnion&lt;const class_ro_t, class_rw_ext_t, PTRAUTH_STR(&quot;class_ro_t&quot;), PTRAUTH_STR(&quot;class_rw_ext_t&quot;)&gt;;</span><br><span class="line">    const ro_or_rw_ext_t get_ro_or_rwe() const &#123;</span><br><span class="line">        return ro_or_rw_ext_t&#123;ro_or_rw_ext&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 设置ro</span><br><span class="line">    const class_ro_t *ro() const &#123;</span><br><span class="line">        auto v = get_ro_or_rwe();</span><br><span class="line">        if (slowpath(v.is&lt;class_rw_ext_t *&gt;())) &#123;</span><br><span class="line">            return v.get&lt;class_rw_ext_t *&gt;()-&gt;ro;</span><br><span class="line">        &#125;</span><br><span class="line">        return v.get&lt;const class_ro_t *&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    void set_ro(const class_ro_t *ro) &#123;</span><br><span class="line">        auto v = get_ro_or_rwe();</span><br><span class="line">        if (v.is&lt;class_rw_ext_t *&gt;()) &#123;</span><br><span class="line">            v.get&lt;class_rw_ext_t *&gt;(&amp;ro_or_rw_ext)-&gt;ro = ro;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            set_ro_or_rwe(ro);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 获取相关信息</span><br><span class="line">    const method_array_t methods() const &#123;</span><br><span class="line">        auto v = get_ro_or_rwe();</span><br><span class="line">        if (v.is&lt;class_rw_ext_t *&gt;()) &#123;</span><br><span class="line">            return v.get&lt;class_rw_ext_t *&gt;()-&gt;methods;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return method_array_t&#123;v.get&lt;const class_ro_t *&gt;()-&gt;baseMethods()&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    const property_array_t properties() const &#123;</span><br><span class="line">        auto v = get_ro_or_rwe();</span><br><span class="line">        if (v.is&lt;class_rw_ext_t *&gt;()) &#123;</span><br><span class="line">            return v.get&lt;class_rw_ext_t *&gt;()-&gt;properties;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return property_array_t&#123;v.get&lt;const class_ro_t *&gt;()-&gt;baseProperties&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    const protocol_array_t protocols() const &#123;</span><br><span class="line">        auto v = get_ro_or_rwe();</span><br><span class="line">        if (v.is&lt;class_rw_ext_t *&gt;()) &#123;</span><br><span class="line">            return v.get&lt;class_rw_ext_t *&gt;()-&gt;protocols;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return protocol_array_t&#123;v.get&lt;const class_ro_t *&gt;()-&gt;baseProtocols&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">struct class_rw_ext_t &#123;</span><br><span class="line">    const class_ro_t *ro;</span><br><span class="line">    method_array_t methods;</span><br><span class="line">    property_array_t properties;</span><br><span class="line">    protocol_array_t protocols;</span><br><span class="line">    char *demangledName;</span><br><span class="line">    uint32_t version;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">struct class_ro_t &#123;</span><br><span class="line">    uint32_t flags;</span><br><span class="line">    uint32_t instanceStart;</span><br><span class="line">    uint32_t instanceSize;</span><br><span class="line">#ifdef __LP64__</span><br><span class="line">    uint32_t reserved;</span><br><span class="line">#endif</span><br><span class="line">    const uint8_t * ivarLayout;</span><br><span class="line">    const char * name;</span><br><span class="line">    method_list_t * baseMethodList;</span><br><span class="line">    protocol_list_t * baseProtocols;</span><br><span class="line">    const ivar_list_t * ivars;</span><br><span class="line">    const uint8_t * weakIvarLayout;</span><br><span class="line">    property_list_t *baseProperties;</span><br><span class="line">    // This field exists only when RO_HAS_SWIFT_INITIALIZER is set.</span><br><span class="line">    _objc_swiftMetadataInitializer __ptrauth_objc_method_list_imp _swiftMetadataInitializer_NEVER_USE[0];</span><br><span class="line">    _objc_swiftMetadataInitializer swiftMetadataInitializer() const &#123;</span><br><span class="line">        if (flags &amp; RO_HAS_SWIFT_INITIALIZER) &#123;</span><br><span class="line">            return _swiftMetadataInitializer_NEVER_USE[0];</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return nil;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    method_list_t *baseMethods() const &#123;</span><br><span class="line">        return baseMethodList;</span><br><span class="line">    &#125;</span><br><span class="line">    class_ro_t *duplicate() const &#123;</span><br><span class="line">        if (flags &amp; RO_HAS_SWIFT_INITIALIZER) &#123;</span><br><span class="line">            size_t size = sizeof(*this) + sizeof(_swiftMetadataInitializer_NEVER_USE[0]);</span><br><span class="line">            class_ro_t *ro = (class_ro_t *)memdup(this, size);</span><br><span class="line">            ro-&gt;_swiftMetadataInitializer_NEVER_USE[0] = this-&gt;_swiftMetadataInitializer_NEVER_USE[0];</span><br><span class="line">            return ro;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            size_t size = sizeof(*this);</span><br><span class="line">            class_ro_t *ro = (class_ro_t *)memdup(this, size);</span><br><span class="line">            return ro;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Class本身是运行时加载的，在运行时会被改变，所以本身Class就是属于脏内存。那么如果想要获取Class的干净内存，也就是编译时确定的数据结构包括方法列表、成员变量等的，该怎么办？这其实就是class_ro_t的作用。因为class_ro_t是只读，意味着class_ro_t是从mach-o读取类的数据之后，就不会被改变。那如果我们想在运行时修改类的信息，比如添加方法，比如加载category怎么办呢？那这时候就有一个与之对应的class_rw_t结构，class_rw_t是运行时存储类的信息，可读可写的，可以在运行时修改。说到这里，好像还漏掉一个结构class_rw_ext_t，这个东西又是干什么用的呢？存在的意义是什么？其实还是跟运行时有关。实际上在我们的app运行中，需要运行时修改的类是非少的，据统计平均大概就10%左右。那也就是说大部分只需要读取class_ro_t中的数据就够了，少部分才需要修改。因此才会有class_rw_ext_t这个扩展的结构体。class_rw_ext_t的作用是这样的：当我们需要修改类结构时，比如添加方法、加载category等时，class_rw_t回去开辟一个额外的空间rwe（class_rw_ext_t），用于存储新的方法和class_ro_t中的方法等信息。这样做的目的有一个好处就是，对于绝大部分类是不需要这个开辟class_rw_ext_t这个结构体，节省内存。</p><h4 id="2、Runtime-如何实现-weak-属性？">2、Runtime 如何实现 weak 属性？</h4><p>weak 此特质表明该属性定义了一种「非拥有关系」(nonowning relationship)。为这种属性设置新值时，设置方法既不持有新值（新指向的对象），也不释放旧值（原来指向的对象）。</p><p>Runtime 对注册的类，会进行内存布局，维护一个 hash 表，这是一个全局表，表中是用 weak 指向的对象内存地址作为 key，用所有指向该对象的weak指针表作为 value。当此对象的引用计数为 0 的时候会调用<code>dealloc</code>，假如该对象内存地址是 a，那么就会以 a 为 key，在这个 weak 表中搜索，找到所有以 a 为键的 weak 对象，从而设置为 nil。</p><p>Runtime 如何实现 weak 属性具体流程大致分为 3 步：</p><ol><li>初始化时：runtime 会调用<code>objc_initWeak()</code>函数，初始化一个新的 weak 指针指向对象的地址。</li><li>添加引用时：<code>objc_initWeak()</code>函数会调用<code>objc_storeWeak()</code>函数，<code>objc_storeWeak()</code>的作用是更新指针指向**（指针可能原来指向着其他对象，这时候需要将该 weak 指针与旧对象解除绑定，会调用到<code>weak_unregister_no_lock</code>）**，如果指针指向的新对象非空，则创建对应的弱引用表，将 weak 指针与新对象进行绑定，会调用到<code>weak_register_no_lock</code>。在这个过程中，为了防止多线程中竞争冲突，会有一些锁的操作。</li><li>释放时：调用<code>clearDeallocating()</code>函数，该函数首先根据对象地址获取所有 weak 指针地址的数组，然后遍历这个数组把其中的数据设为 nil，最后把这个 entry 从 weak 表中删除，最后清理对象的记录。</li></ol><h4 id="3、Runtime具体应用">3、Runtime具体应用</h4><ol><li>利用关联对象（AssociatedObject）给分类添加属性</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objc_setAssociatedObject(&lt;#id object#&gt;, &lt;#const void *key#&gt;, &lt;#id value#&gt;, &lt;#objc_AssociationPolicy policy#&gt;)</span><br></pre></td></tr></table></figure><ul><li>第一个参数: id object : 需要传入的是 : 对象的主分支</li><li>第二个参数: const void *key : 是一个 static 类型的关键字,这里根据开发者自身来定义就行</li><li>第三个参数: id value : 传入的是: 对象的子分支</li><li>第四个参数: objc_AssociationPolicy policy :是当前关联对象的类型 strong,weak,copy (枚举类型:开发者可以点进去看)</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objc_getAssociatedObject(&lt;#id object#&gt;, &lt;#const void *key#&gt;)就相对来说容易理解一点了</span><br></pre></td></tr></table></figure><ul><li>第一个参数 : id object : 需要传入的是 : 对象的主分支</li><li>第二个参数 : const void *key : 是一个 static 类型的关键字,这里根据开发者自身来定义就行</li></ul><ol start="2"><li>遍历类的所有成员变量（修改textfield的占位文字颜色、字典转模型、自动归档解档）</li><li>交换方法实现，在方法上增加额外功能（交换系统的方法）</li></ol><ul><li>有这样一个场景，出于某些需求，我们需要跟踪记录APP中按钮的点击次数和频率等数据，怎么解决？当然通过继承按钮类或者通过类别实现是一个办法，但是带来其他问题比如别人不一定会去实例化你写的子类，或者其他类别也实现了点击方法导致不确定会调用哪一个，runtime可以这样解决：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">@implementation UIButton (Hook)</span><br><span class="line"></span><br><span class="line">+ (void)load &#123;</span><br><span class="line"></span><br><span class="line">    static dispatch_once_t onceToken;</span><br><span class="line">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line"></span><br><span class="line">        Class selfClass = [self class];</span><br><span class="line"></span><br><span class="line">        SEL oriSEL = @selector(sendAction:to:forEvent:);</span><br><span class="line">        Method oriMethod = class_getInstanceMethod(selfClass, oriSEL);</span><br><span class="line"></span><br><span class="line">        SEL cusSEL = @selector(mySendAction:to:forEvent:);</span><br><span class="line">        Method cusMethod = class_getInstanceMethod(selfClass, cusSEL);</span><br><span class="line"></span><br><span class="line">        BOOL addSucc = class_addMethod(selfClass, oriSEL, method_getImplementation(cusMethod), method_getTypeEncoding(cusMethod));</span><br><span class="line">        if (addSucc) &#123;</span><br><span class="line">            class_replaceMethod(selfClass, cusSEL, method_getImplementation(oriMethod), method_getTypeEncoding(oriMethod));</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            method_exchangeImplementations(oriMethod, cusMethod);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)mySendAction:(SEL)action to:(id)target forEvent:(UIEvent *)event &#123;</span><br><span class="line">    [CountTool addClickCount];</span><br><span class="line">    [self mySendAction:action to:target forEvent:event];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><ol start="4"><li>利用消息转发机制解决方法找不到的异常问题</li><li>动态变量控制<br>在程序中，xiaowen的age是20，后来被runtime变成10</li></ol><ul><li><p>动态获取xiaowen类中的所有属性[包括私有]<br>Ivar *ivar = class_copyIvarList([self.xiaowen class], &amp;count);</p></li><li><p>遍历属性找到对应name字段<br>const char *varName = ivar_getName(var);</p></li><li><p>修改对应的字段值成20<br>object_setIvar(self.xiaowen, var, @“20”);</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (void)changeAge &#123;</span><br><span class="line">     unsigned int count = 0;</span><br><span class="line">     Ivar *ivar = class_copyIvarList([self.xiaowen class], &amp;count);</span><br><span class="line">     for (int i = 0; i&lt;count; i++) &#123;</span><br><span class="line">         Ivar var = ivar[i];</span><br><span class="line">         const char *varName = ivar_getName(var);</span><br><span class="line">         NSString *name = [NSString stringWithUTF8String:varName];</span><br><span class="line">         if ([name isEqualToString:@&quot;_age&quot;]) &#123;</span><br><span class="line">             object_setIvar(self.xiaowen, var, @&quot;20&quot;);</span><br><span class="line">             break;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     NSLog(@&quot;age is %@&quot;,self.xiaowen.age);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><ol start="6"><li>动态添加方法</li></ol><ul><li>动态给Person类中添加study方法：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (void)addMethod &#123;</span><br><span class="line">    class_addMethod([self.xiaowen class], @selector(study), (IMP)studyImp, &quot;v@:&quot;);</span><br><span class="line">    if ([self.xiaowen respondsToSelector:@selector(study)]) &#123;</span><br><span class="line">        [self.xiaowen performSelector:@selector(study)];</span><br><span class="line">    &#125; else&#123;</span><br><span class="line">        NSLog(@&quot;Sorry,I don&#x27;t know&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void studyImp(id self,SEL _cmd) &#123;</span><br><span class="line">    NSLog(@&quot;i am from beijing&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(IMP)studyImp 意思是studyImp的地址指针;<br>“v@:” 意思是，v代表无返回值void，如果是i则代表int；@代表 id self; : 代表 SEL _cmd;<br>“v@:@@” 意思是，两个参数的没有返回值。</p><ol start="7"><li>KVC 字典转模型</li></ol><ul><li>先实现最外层的属性转换</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// 创建对应模型对象</span><br><span class="line"> id objc = [[self alloc] init];</span><br><span class="line"></span><br><span class="line"> unsigned int count = 0;</span><br><span class="line"></span><br><span class="line"> // 1.获取成员属性数组</span><br><span class="line"> Ivar *ivarList = class_copyIvarList(self, &amp;count);</span><br><span class="line"></span><br><span class="line"> // 2.遍历所有的成员属性名,一个一个去字典中取出对应的value给模型属性赋值</span><br><span class="line"> for (int i = 0; i &lt; count; i++) &#123;</span><br><span class="line"></span><br><span class="line">     // 2.1 获取成员属性</span><br><span class="line">     Ivar ivar = ivarList[i];</span><br><span class="line"></span><br><span class="line">     // 2.2 获取成员属性名 C -&gt; OC 字符串</span><br><span class="line">     NSString *ivarName = [NSString stringWithUTF8String:ivar_getName(ivar)];</span><br><span class="line"></span><br><span class="line">     // 2.3 _成员属性名 =&gt; 字典key</span><br><span class="line">     NSString *key = [ivarName substringFromIndex:1];</span><br><span class="line"></span><br><span class="line">     // 2.4 去字典中取出对应value给模型属性赋值</span><br><span class="line">     id value = dict[key];</span><br><span class="line"></span><br><span class="line">     // 获取成员属性类型</span><br><span class="line">     NSString *ivarType = [NSString stringWithUTF8String:ivar_getTypeEncoding(ivar)];</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><ul><li>内层数组，字典的转换</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">if ([value isKindOfClass:[NSDictionary class]] &amp;&amp; ![ivarType containsString:@&quot;NS&quot;]) &#123; </span><br><span class="line">       //  是字典对象,并且属性名对应类型是自定义类型</span><br><span class="line">      // 处理类型字符串 @\&quot;User\&quot; -&gt; User</span><br><span class="line">      ivarType = [ivarType stringByReplacingOccurrencesOfString:@&quot;@&quot; withString:@&quot;&quot;];</span><br><span class="line">      ivarType = [ivarType stringByReplacingOccurrencesOfString:@&quot;\&quot;&quot; withString:@&quot;&quot;];</span><br><span class="line">      // 自定义对象,并且值是字典</span><br><span class="line">      // value:user字典 -&gt; User模型</span><br><span class="line">      // 获取模型(user)类对象</span><br><span class="line">      Class modalClass = NSClassFromString(ivarType);</span><br><span class="line"></span><br><span class="line">      // 字典转模型</span><br><span class="line">      if (modalClass) &#123;</span><br><span class="line">          // 字典转模型 user</span><br><span class="line">          value = [modalClass objectWithDict:value];</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  if ([value isKindOfClass:[NSArray class]]) &#123;</span><br><span class="line">      // 判断对应类有没有实现字典数组转模型数组的协议</span><br><span class="line">      if ([self respondsToSelector:@selector(arrayContainModelClass)]) &#123;</span><br><span class="line"></span><br><span class="line">          // 转换成id类型，就能调用任何对象的方法</span><br><span class="line">          id idSelf = self;</span><br><span class="line"></span><br><span class="line">          // 获取数组中字典对应的模型</span><br><span class="line">          NSString *type =  [idSelf arrayContainModelClass][key];</span><br><span class="line"></span><br><span class="line">          // 生成模型</span><br><span class="line">          Class classModel = NSClassFromString(type);</span><br><span class="line">          NSMutableArray *arrM = [NSMutableArray array];</span><br><span class="line">          // 遍历字典数组，生成模型数组</span><br><span class="line">          for (NSDictionary *dict in value) &#123;</span><br><span class="line">              // 字典转模型</span><br><span class="line">              id model =  [classModel objectWithDict:dict];</span><br><span class="line">              [arrM addObject:model];</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          // 把模型数组赋值给value</span><br><span class="line">          value = arrM;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><ol start="8"><li>动态的添加对象的成员变量和方法</li><li>实现NSCoding的自动归档和解档，我们把encodeWithCoder 和 initWithCoder这两个方法抽成宏</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;Person.h&quot;</span><br><span class="line">#import &lt;objc/runtime.h&gt;</span><br><span class="line"></span><br><span class="line">#define encodeRuntime(A) \</span><br><span class="line">\</span><br><span class="line">unsigned int count = 0;\</span><br><span class="line">Ivar *ivars = class_copyIvarList([A class], &amp;count);\</span><br><span class="line">for (int i = 0; i&lt;count; i++) &#123;\</span><br><span class="line">Ivar ivar = ivars[i];\</span><br><span class="line">const char *name = ivar_getName(ivar);\</span><br><span class="line">NSString *key = [NSString stringWithUTF8String:name];\</span><br><span class="line">id value = [self valueForKey:key];\</span><br><span class="line">[encoder encodeObject:value forKey:key];\</span><br><span class="line">&#125;\</span><br><span class="line">free(ivars);\</span><br><span class="line">\</span><br><span class="line"></span><br><span class="line">#define initCoderRuntime(A) \</span><br><span class="line">\</span><br><span class="line">if (self = [super init]) &#123;\</span><br><span class="line">unsigned int count = 0;\</span><br><span class="line">Ivar *ivars = class_copyIvarList([A class], &amp;count);\</span><br><span class="line">for (int i = 0; i&lt;count; i++) &#123;\</span><br><span class="line">Ivar ivar = ivars[i];\</span><br><span class="line">const char *name = ivar_getName(ivar);\</span><br><span class="line">NSString *key = [NSString stringWithUTF8String:name];\</span><br><span class="line">id value = [decoder decodeObjectForKey:key];\</span><br><span class="line">[self setValue:value forKey:key];\</span><br><span class="line">&#125;\</span><br><span class="line">free(ivars);\</span><br><span class="line">&#125;\</span><br><span class="line">return self;\</span><br><span class="line">\</span><br><span class="line"></span><br><span class="line">@implementation Person</span><br><span class="line"></span><br><span class="line">- (void)encodeWithCoder:(NSCoder *)encoder &#123;</span><br><span class="line">    encodeRuntime(Person)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (id)initWithCoder:(NSCoder *)decoder &#123;</span><br><span class="line">    initCoderRuntime(Person)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><h4 id="4、Runtime方法调用流程？">4、Runtime方法调用流程？</h4><p>1、当调用对象方法的时候，会通过obj_object的isa指针找对对应的归属类。<br>2、从归属类（obj_class）类中的cache中寻找对应的相等的sel方法编号。<br>3、如果没有找到，继续obj_class中的method_list中查找，如果找到写入cache中。<br>4、如果没有到找到，会一直找到它的元类上。<br>5、如果元类也没有的话，会调用消息动态解析方法<code>+resovleInstanceMethod:</code>和<code>+resloveClassMethod:</code>的方法，查看是否存在绑定的方法。<br>6、如果没有绑定方法，会调用消息转发方法<code>-forwardingTargetForSelector:</code>的方法。查看是否存在转发对象。<br>7、如果没有存在消息转发对象，会调用<code>-methodSignatureForSelector:</code>的方法，查看是否有方法签名返回类型和参数类型。<br>8、不存在签名方法和类型，就会来到<code>-doseNotRecognizeSelector:</code>方法内部程序crash提示无法识别选择器unrecognized selector sent to instance。<br>9、存在签名的方法，就是继续执行<code>-forwardInvocation:</code>寻找IMP，没有找到IMP，就会来到<code>-doseNotRecognizeSelector:</code>方法内部程序crash提示无法识别选择器unrecognized selector sent to instance。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">@implementation Person</span><br><span class="line">- (BOOL)respondsToSelector:(SEL)aSelector &#123;</span><br><span class="line">    bool a= [super respondsToSelector:aSelector];</span><br><span class="line">    return a;</span><br><span class="line">&#125;</span><br><span class="line">//如果方法没有实现，默认返回false</span><br><span class="line">//如果返回false，就会走消息转发</span><br><span class="line">+ (BOOL)resolveInstanceMethod:(SEL)sel &#123;</span><br><span class="line">    bool a = [super resolveInstanceMethod:sel];</span><br><span class="line">    return a;</span><br><span class="line">&#125;</span><br><span class="line">//默认返回空</span><br><span class="line">//又被称为快速消息转发。</span><br><span class="line">// 如果为空，走慢速消息转发，继续转发消息</span><br><span class="line">- (id)forwardingTargetForSelector:(SEL)aSelector &#123;</span><br><span class="line">    id a = [super forwardingTargetForSelector:aSelector];</span><br><span class="line">    return a;</span><br><span class="line">&#125;</span><br><span class="line">// 默认一般普通方法是返回空的。</span><br><span class="line">// 如果是协议方法，没有实现，不会反回空。</span><br><span class="line">//反回空，到这里就会崩溃了</span><br><span class="line">//如果这里返回了签名，会再次调用resolveInstanceMethod:(SEL)sel判断是否实现</span><br><span class="line">//如果仍然没有实现，就会走到fowardInvocation:</span><br><span class="line">- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector &#123;</span><br><span class="line">    NSMethodSignature *a = [super methodSignatureForSelector:aSelector];</span><br><span class="line">    return a;</span><br><span class="line">&#125;</span><br><span class="line">//默认实现是崩溃</span><br><span class="line">//并且不能用try-catch捕获</span><br><span class="line">- (void)forwardInvocation:(NSInvocation *)anInvocation &#123;</span><br><span class="line">    [super forwardInvocation:anInvocation];</span><br><span class="line">    NSLog(@&quot;&quot;);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><h4 id="5、Runtime的方法交换的流程？">5、Runtime的方法交换的流程？</h4><p>1、方法交换要放在<code>+(viod)load</code>中处理。<br>2、在load中首先使用<code>class_addMethod</code>的方法添加新方法。<br>3、添加成功后，使用<code>class_replaceMethod</code>替换原来的方法。<br>4、如果添加失败的话，则说明已经有添加成功。直接使用<code>class_exchangeMethod</code>的方法替换。<br>5、在交换方法时候，使用<code>dispach_one</code>的方法。<br>6、在新方法中调用新方法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">使用注意要点：</span><br><span class="line">1、使用load时候，切记不要做初始化和大开销大内存逻辑。因为程序顺序是，父类-&gt;当前类-&gt;分类-&gt;mian</span><br><span class="line">2、使用的时候如果方法相同是不会覆盖原来的方法，会放在置顶，所以一般不会调用到原来的方法。</span><br><span class="line">3、在新方法中调用新方法。</span><br></pre></td></tr></table></figure><h4 id="6、常见方法？">6、常见方法？</h4><ul><li>获取属性列表</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">objc_property_t *propertyList = class_copyPropertyList([self class], &amp;count);</span><br><span class="line">for (unsigned int i=0; i&lt;count; i++) &#123;</span><br><span class="line">    const char *propertyName = property_getName(propertyList[i]);</span><br><span class="line">    NSLog(@&quot;property----&gt;%@&quot;, [NSString stringWithUTF8String:propertyName]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>获取方法列表</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Method *methodList = class_copyMethodList([self class], &amp;count);</span><br><span class="line">for (unsigned int i; i&lt;count; i++) &#123;</span><br><span class="line">    Method method = methodList[i];</span><br><span class="line">    NSLog(@&quot;Method----&gt;%@&quot;, NSStringFromSelector(method_getName(method)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>获取成员变量列表</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Ivar *ivarList = class_copyIvarList([self class], &amp;count);</span><br><span class="line">for (unsigned int i; i&lt;count; i++) &#123;</span><br><span class="line">    Ivar myIvar = ivarList[i];</span><br><span class="line">    const char *ivarName = ivar_getName(myIvar);</span><br><span class="line">    NSLog(@&quot;Ivar----&gt;%@&quot;, [NSString stringWithUTF8String:ivarName]);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><ul><li>获取协议列表</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">__unsafe_unretained Protocol **protocolList = class_copyProtocolList([self class], &amp;count);</span><br><span class="line">for (unsigned int i; i&lt;count; i++) &#123;</span><br><span class="line">    Protocol *myProtocal = protocolList[i];</span><br><span class="line">    const char *protocolName = protocol_getName(myProtocal);</span><br><span class="line">    NSLog(@&quot;protocol----&gt;%@&quot;, [NSString stringWithUTF8String:protocolName]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="计算机网络">计算机网络</h3><h4 id="1、网络七层协议">1、网络七层协议</h4><ul><li><strong>应用层：</strong><br>1.用户接口、应用程序；<br>2.Application典型设备：网关；<br>3.典型协议、标准和应用：TELNET、FTP、HTTP</li><li><strong>表示层：</strong><br>1.数据表示、压缩和加密presentation<br>2.典型设备：网关<br>3.典型协议、标准和应用：ASCLL、PICT、TIFF、JPEG|MPEG<br>4.表示层相当于一个东西的表示，表示的一些协议，比如图片、声音和视频MPEG。</li><li><strong>会话层：</strong><br>1.会话的建立和结束；<br>2.典型设备：网关；<br>3.典型协议、标准和应用：RPC、SQL、NFS、X WINDOWS、ASP</li><li><strong>传输层：</strong><br>1.主要功能：端到端控制Transport；<br>2.典型设备：网关；<br>3.典型协议、标准和应用：TCP、UDP、SPX</li><li><strong>网络层：</strong><br>1.主要功能：路由、寻址Network；<br>2.典型设备：路由器；<br>3.典型协议、标准和应用：IP、IPX、APPLETALK、ICMP；</li><li><strong>数据链路层：</strong><br>1.主要功能：保证无差错的疏忽链路的data link；<br>2.典型设备：交换机、网桥、网卡；<br>3.典型协议、标准和应用：802.2、802.3ATM、HDLC、FRAME RELAY；</li><li><strong>物理层：</strong><br>1.主要功能：传输比特流Physical；<br>2.典型设备：集线器、中继器<br>3.典型协议、标准和应用：V.35、EIA/TIA-232.</li></ul><h4 id="2、Http-和-Https-的区别？Https为什么更加安全？">2、Http 和 Https 的区别？Https为什么更加安全？</h4><ul><li><strong>区别</strong><br>1.HTTPS 需要向机构申请 CA 证书，极少免费。<br>2.HTTP 属于明文传输，HTTPS基于 SSL 进行加密传输。<br>3.HTTP 端口号为 80，HTTPS 端口号为 443 。<br>4.HTTPS 是加密传输，有身份验证的环节，更加安全。</li><li><strong>安全</strong><br>SSL(安全套接层) TLS(传输层安全)<br>以上两者在传输层之上，对网络连接进行加密处理，保障数据的完整性，更加的安全。</li></ul><h4 id="3、HTTPS的连接建立流程？">3、HTTPS的连接建立流程？</h4><ul><li>服务器端的公钥和私钥，用来进行非对称加密</li><li>客户端生成的随机密钥，用来进行对称加密</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/2752635-bbc482d077daa839.jpg" alt=""></p><p>http建立连接过程.jpg</p><p>如上图，HTTPS连接过程大致可分为八步:</p><ol><li><p>客户端访问HTTPS连接。<br>客户端会把安全协议版本号、客户端支持的加密算法列表、随机数C发给服务端。</p></li><li><p>服务端发送证书给客户端</p></li></ol><ul><li><p>服务端接收密钥算法配件后，会和自己支持的加密算法列表进行比对，如果不符合，则断开连接。否则，服务端会在该算法列表中，选择一种对称算法（如AES）、一种公钥算法（如具有特定秘钥长度的RSA）和一种MAC算法发给客户端。</p></li><li><p>服务器端有一个密钥对，即公钥和私钥，是用来进行非对称加密使用的，服务器端保存着私钥，不能将其泄露，公钥可以发送给任何人。</p></li><li><p>在发送加密算法的同时还会把数字证书和随机数S发送给客户端</p></li></ul><ol start="3"><li><p>客户端验证server证书<br>会对server公钥进行检查，验证其合法性，如果发现发现公钥有问题，那么HTTPS传输就无法继续。</p></li><li><p>客户端组装会话秘钥<br>如果公钥合格，那么客户端会用服务器公钥来生成一个前主秘钥(Pre-Master Secret，PMS)，并通过该前主秘钥和随机数C、S来组装成会话秘钥</p></li><li><p>客户端将前主秘钥加密发送给服务端<br>是通过服务端的公钥来对前主秘钥进行非对称加密，发送给服务端</p></li><li><p>服务端通过私钥解密得到前主秘钥<br>服务端接收到加密信息后，用私钥解密得到主秘钥。</p></li><li><p>服务端组装会话秘钥<br>服务端通过前主秘钥和随机数C、S来组装会话秘钥。<br>至此，服务端和客户端都已经知道了用于此次会话的主秘钥。</p></li><li><p>数据传输<br>客户端收到服务器发送来的密文，用客户端密钥对其进行对称解密，得到服务器发送的数据。<br>同理，服务端收到客户端发送来的密文，用服务端密钥对其进行对称解密，得到客户端发送的数据。</p></li></ol><h4 id="4、解释一下三次握手和四次挥手？">4、解释一下三次握手和四次挥手？</h4><ul><li><p><strong>三次握手</strong><br>1.由客户端向服务端发送 SYN 同步报文。<br>2.当服务端收到 SYN 同步报文之后，会返回给客户端 SYN 同步报文和 ACK 确认报文。<br>3.客户端会向服务端发送 ACK 确认报文，此时客户端和服务端的连接正式建立。</p></li><li><p><strong>建立连接</strong><br>1.这个时候客户端就可以通过 Http 请求报文，向服务端发送请求<br>2.服务端接收到客户端的请求之后，向客户端回复 Http 响应报文。</p></li><li><p><strong>四次挥手</strong><br>1.先由客户端向服务端发送 FIN 结束报文。<br>2.服务端会返回给客户端 ACK 确认报文 。此时，由客户端发起的断开连接已经完成。<br>3.服务端会发送给客户端 FIN 结束报文 和 ACK 确认报文。<br>4.客户端会返回 ACK 确认报文到服务端，至此，由服务端方向的断开连接已经完成。</p></li></ul><h4 id="5、TCP-和-UDP的区别？">5、TCP 和 UDP的区别？</h4><ul><li>**TCP：**面向连接、传输可靠(保证数据正确性,保证数据顺序)、用于传输大量数据(流模式)、速度慢，建立连接需要开销较多(时间，系统资源)。</li><li>**UDP：**面向非连接、传输不可靠、用于传输少量数据(数据包模式)、速度快。</li></ul><h4 id="多线程">多线程</h4><h4 id="1、进程与线程">1、进程与线程</h4><ul><li><p><strong>进程：</strong><br>1.进程是一个具有一定独立功能的程序关于某次数据集合的一次运行活动，它是操作系统分配资源的基本单元.<br>2.进程是指在系统中正在运行的一个应用程序，就是一段程序的执行过程,我们可以理解为手机上的一个app.<br>3.每个进程之间是独立的，每个进程均运行在其专用且受保护的内存空间内，拥有独立运行所需的全部资源</p></li><li><p><strong>线程：</strong><br>1.程序执行流的最小单元，线程是进程中的一个实体.<br>2.一个进程要想执行任务,必须至少有一条线程.应用程序启动的时候，系统会默认开启一条线程,也就是主线程</p></li><li><p><strong>进程和线程的关系</strong><br>1.线程是进程的执行单元，进程的所有任务都在线程中执行<br>2.线程是 CPU 分配资源和调度的最小单位<br>3.一个程序可以对应多个进程(多进程),一个进程中可有多个线程,但至少要有一条线程<br>4.同一个进程内的线程共享进程资源</p></li></ul><h4 id="2、什么是多线程？">2、什么是多线程？</h4><ul><li>多线程的实现原理：事实上，同一时间内单核的CPU只能执行一个线程，多线程是CPU快速的在多个线程之间进行切换（调度），造成了多个线程同时执行的假象。</li><li>如果是多核CPU就真的可以同时处理多个线程了。</li><li>多线程的目的是为了同步完成多项任务，通过提高系统的资源利用率来提高系统的效率。</li></ul><h4 id="3、多线程的优点和缺点？">3、多线程的优点和缺点？</h4><ul><li><p><strong>优点:</strong><br>能适当提高程序的执行效率<br>能适当提高资源利用率（CPU、内存利用率）</p></li><li><p><strong>缺点:</strong></p></li></ul><ol><li>开启线程需要占用一定的内存空间（默认情况下，主线程占用1M，子线程占用512KB），如果开启大量的线程，会占用大量的内存空间，降低程序的性能</li><li>线程越多，CPU在调度线程上的开销就越大</li><li>程序设计更加复杂：比如线程之间的通信、多线程的数据共享</li></ol><h4 id="4、多线程的并行和并发有什么区别？">4、多线程的<strong>并行</strong>和<strong>并发</strong>有什么区别？</h4><ul><li>**并行：**充分利用计算机的多核，在多个线程上同步进行</li><li>**并发：**在一条线程上通过快速切换，让人感觉在同步进行</li></ul><h4 id="5、iOS中实现多线程的几种方案，各自有什么特点？">5、iOS中实现多线程的几种方案，各自有什么特点？</h4><ul><li>NSThread 面向对象的，需要程序员手动创建线程，但不需要手动销毁。子线程间通信很难。</li><li>GCD C语言，充分利用了设备的多核，自动管理线程生命周期。比NSOperation效率更高。</li><li>NSOperation 基于GCD封装，更加面向对象，比GCD多了一些功能。</li></ul><h4 id="6、多个网络请求完成后执行下一步？">6、多个网络请求完成后执行下一步？</h4><p><strong>使用GCD的dispatch_group_t</strong></p><p>创建一个dispatch_group_t</p><p>每次网络请求前先<code>dispatch_group_enter</code>,请求回调后再<code>dispatch_group_leave</code>，enter和leave必须配合使用，有几次enter就要有几次leave，否则group会一直存在。</p><p>当所有enter的block都leave后，会执行<code>dispatch_group_notify</code>的block。</p><p>栅栏函数中传入的参数队列必须是由 <code>dispatch_queue_create</code> 方法创建的队列，否则，与 <code>dispatch_async</code> 无异，起不到“栅栏”的作用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">NSString *str = @&quot;http://xxxx.com/&quot;;</span><br><span class="line">NSURL *url = [NSURL URLWithString:str];</span><br><span class="line">NSURLRequest *request = [NSURLRequest requestWithURL:url];</span><br><span class="line">NSURLSession *session = [NSURLSession sharedSession];</span><br><span class="line"></span><br><span class="line">dispatch_group_t downloadGroup = dispatch_group_create();</span><br><span class="line">for (int i=0; i&lt;10; i++) &#123;</span><br><span class="line">    dispatch_group_enter(downloadGroup);</span><br><span class="line"></span><br><span class="line">    NSURLSessionDataTask *task = [session dataTaskWithRequest:request completionHandler:^(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error) &#123;</span><br><span class="line">        NSLog(@&quot;%d---%d&quot;,i,i);</span><br><span class="line">        dispatch_group_leave(downloadGroup);</span><br><span class="line">    &#125;];</span><br><span class="line">    [task resume];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dispatch_group_notify(downloadGroup, dispatch_get_main_queue(), ^&#123;</span><br><span class="line">    NSLog(@&quot;end&quot;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>使用GCD的信号量dispatch_semaphore_t</strong></p><p>dispatch_semaphore信号量为基于计数器的一种多线程同步机制。如果semaphore计数大于等于1，计数-1，返回，程序继续运行。如果计数为0，则等待。<code>dispatch_semaphore_signal(semaphore)</code>为计数+1操作,<code>dispatch_semaphore_wait(sema, DISPATCH_TIME_FOREVER)</code>为设置等待时间，这里设置的等待时间是一直等待。</p><p>创建semaphore为0，等待，等10个网络请求都完成了，dispatch_semaphore_signal(semaphore)为计数+1，然后计数-1返回</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">NSString *str = @&quot;http://xxxx.com/&quot;;</span><br><span class="line">NSURL *url = [NSURL URLWithString:str];</span><br><span class="line">NSURLRequest *request = [NSURLRequest requestWithURL:url];</span><br><span class="line">NSURLSession *session = [NSURLSession sharedSession];</span><br><span class="line"></span><br><span class="line">dispatch_semaphore_t sem = dispatch_semaphore_create(0);</span><br><span class="line">for (int i=0; i&lt;10; i++) &#123;</span><br><span class="line"></span><br><span class="line">    NSURLSessionDataTask *task = [session dataTaskWithRequest:request completionHandler:^(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error) &#123;</span><br><span class="line">        NSLog(@&quot;%d---%d&quot;,i,i);</span><br><span class="line">        count++;</span><br><span class="line">        if (count==10) &#123;</span><br><span class="line">            dispatch_semaphore_signal(sem);</span><br><span class="line">            count = 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">    [task resume];</span><br><span class="line">&#125;</span><br><span class="line">dispatch_semaphore_wait(sem, DISPATCH_TIME_FOREVER);</span><br><span class="line"></span><br><span class="line">dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">    NSLog(@&quot;end&quot;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="7、多个网络请求顺序执行后执行下一步？">7、多个网络请求顺序执行后执行下一步？</h4><p><strong>使用信号量semaphore</strong></p><p>每一次遍历，都让其<code>dispatch_semaphore_wait(sem, DISPATCH_TIME_FOREVER)</code>，这个时候线程会等待，阻塞当前线程，直到<code>dispatch_semaphore_signal(sem)</code>调用之后</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">NSString *str = @&quot;http://www.jianshu.com/p/6930f335adba&quot;;</span><br><span class="line">NSURL *url = [NSURL URLWithString:str];</span><br><span class="line">NSURLRequest *request = [NSURLRequest requestWithURL:url];</span><br><span class="line">NSURLSession *session = [NSURLSession sharedSession];</span><br><span class="line"></span><br><span class="line">dispatch_semaphore_t sem = dispatch_semaphore_create(0);</span><br><span class="line">for (int i=0; i&lt;10; i++) &#123;</span><br><span class="line"></span><br><span class="line">    NSURLSessionDataTask *task = [session dataTaskWithRequest:request completionHandler:^(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error) &#123;</span><br><span class="line"></span><br><span class="line">        NSLog(@&quot;%d---%d&quot;,i,i);</span><br><span class="line">        dispatch_semaphore_signal(sem);</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    [task resume];</span><br><span class="line">    dispatch_semaphore_wait(sem, DISPATCH_TIME_FOREVER);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">    NSLog(@&quot;end&quot;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="8、异步操作两组数据时-执行完第一组之后-才能执行第二组？">8、异步操作两组数据时, 执行完第一组之后, 才能执行第二组？</h4><p>这里使用dispatch_barrier_async栅栏方法即可实现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t queue = dispatch_queue_create(&quot;test&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line"></span><br><span class="line">dispatch_async(queue, ^&#123;</span><br><span class="line">    NSLog(@&quot;第一次任务的主线程为: %@&quot;, [NSThread currentThread]);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">dispatch_async(queue, ^&#123;</span><br><span class="line">    NSLog(@&quot;第二次任务的主线程为: %@&quot;, [NSThread currentThread]);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">dispatch_barrier_async(queue, ^&#123;</span><br><span class="line">    NSLog(@&quot;第一次任务, 第二次任务执行完毕, 继续执行&quot;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">dispatch_async(queue, ^&#123;</span><br><span class="line">    NSLog(@&quot;第三次任务的主线程为: %@&quot;, [NSThread currentThread]);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">dispatch_async(queue, ^&#123;</span><br><span class="line">    NSLog(@&quot;第四次任务的主线程为: %@&quot;, [NSThread currentThread]);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="9、多线程中的死锁？">9、多线程中的死锁？</h4><p>死锁是由于多个线程（进程）在执行过程中，因为争夺资源而造成的互相等待现象，你可以理解为卡主了。产生死锁的必要条件有四个：</p><ul><li>**互斥条件：**指进程对所分配到的资源进行排它性使用，即在一段时间内某资源只由一个进程占用。如果此时还有其它进程请求资源，则请求者只能等待，直至占有资源的进程用毕释放。</li><li>**请求和保持条件：**指进程已经保持至少一个资源，但又提出了新的资源请求，而该资源已被其它进程占有，此时请求进程阻塞，但又对自己已获得的其它资源保持不放。</li><li>**不可剥夺条件：**指进程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完时由自己释放。</li><li>**环路等待条件：**指在发生死锁时，必然存在一个进程——资源的环形链，即进程集合{P0，P1，P2，···，Pn}中的P0正在等待一个P1占用的资源；P1正在等待P2占用的资源，……，Pn正在等待已被P0占用的资源。</li></ul><p>最常见的就是 <strong>同步函数 + 主队列</strong> 的组合，本质是队列阻塞。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">dispatch_sync(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">    NSLog(@&quot;2&quot;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;1&quot;);</span><br><span class="line">// 什么也不会打印，直接报错</span><br></pre></td></tr></table></figure><h4 id="10、GCD执行原理？">10、GCD执行原理？</h4><ul><li>GCD有一个底层线程池，这个池中存放的是一个个的线程。之所以称为“池”，很容易理解出这个“池”中的线程是可以重用的，当一段时间后这个线程没有被调用的话，这个线程就会被销毁。注意：开多少条线程是由底层线程池决定的（线程建议控制再3~5条），池是系统自动来维护，不需要我们程序员来维护，我们只关心的是向队列中添加任务，队列调度即可。</li><li>如果队列中存放的是同步任务，则任务出队后，底层线程池中会提供一条线程供这个任务执行，任务执行完毕后这条线程再回到线程池。这样队列中的任务反复调度，因为是同步的，所以当我们用currentThread打印的时候，就是同一条线程。</li><li>如果队列中存放的是异步的任务，（注意异步可以开线程），当任务出队后，底层线程池会提供一个线程供任务执行，因为是异步执行，队列中的任务不需等待当前任务执行完毕就可以调度下一个任务，这时底层线程池中会再次提供一个线程供第二个任务执行，执行完毕后再回到底层线程池中。</li><li>这样就对线程完成一个复用，而不需要每一个任务执行都开启新的线程，也就从而节约的系统的开销，提高了效率。在iOS7.0的时候，使用GCD系统通常只能开5-8条线程，iOS8.0以后，系统可以开启很多条线程，但是实在开发应用中，建议开启线程条数：3-5条最为合理。</li></ul><h3 id="项目架构">项目架构</h3><h4 id="1、MVC、MVVM模式">1、MVC、MVVM模式</h4><h5 id="MVC（Model、View、Controller）">MVC（Model、View、Controller）</h5><p>MVC是比较直观的架构模式，最核心的就是通过Controller层来进行调控<br>Model和View永远不能相互通信，只能通过Controller传递<br>Controller可以直接与Model对话（读写调用Model），Model通过Notification和KVO机制与Controller间接通信<br>Controller可以直接与View对话，通过IBoutlet直接操作View，IBoutlet直接对应View的控件（例如创建一个Button：需声明一个 IBOutlet UIButton * btn），View通过action向Controller报告时间的发生(用户点击了按钮)。Controller是View的直接数据源</p><ul><li><strong>优点:</strong> 对于混乱的项目组织方式，有了一个明确的组织方式。通过Controller来掌控全局，同时将View展示和Model的变化分开</li><li><strong>缺点:</strong> 愈发笨重的Controller，随着业务逻辑的增加，大量的代码放进Controller，导致Controller越来越臃肿，堆积成千上万行代码，后期维护起来费时费力</li></ul><h5 id="MVVM（Model、Controller-View、ViewModel）">MVVM（Model、Controller/View、ViewModel）</h5><p>在MVVM中，View和ViewController联系在一起，我们把它们视为一个组件，View和ViewController都不能直接引用model，而是引用是视图模型即ViewModel。 ViewModel是一个用来放置用户输入验证逻辑、视图显示逻辑、网络请求等业务逻辑的地方，这样的设计模式，会轻微增加代码量，但是会减少代码的复杂性</p><ul><li><strong>优点:</strong> View可以独立于Model的变化和修改，一个ViewModel可以绑定到不同的View上，降低耦合，增加重用</li><li><strong>缺点:</strong> 过于简单的项目不适用、大型的项目视图状态较多时构建和维护成本太大<br>合理的运用架构模式有利于项目、团队开发工作，不同的设计模式，只是让不同的场景有了更多的选择方案。根据项目场景和开发需求，选择最合适的解决方案。</li></ul><h3 id="调试技巧">调试技巧</h3><h4 id="1、LLDB常用的调试命令？">1、LLDB常用的调试命令？</h4><p>**po：**print object的缩写，表示显示对象的文本描述，如果对象不存在则打印nil。<br>**p：**可以用来打印基本数据类型。<br>**call：**执行一段代码 如：call NSLog(@“%@”, @“yang”)<br>**expr：**动态执行指定表达式<br>**bt：**打印当前线程堆栈信息 （bt all 打印所有线程堆栈信息）<br>**image：**常用来寻找栈地址对应代码位置 如：image lookup --address 0xxxx</p><h4 id="2、断点调试？">2、断点调试？</h4><p><strong>条件断点</strong><br>打上断点之后，对断点进行编辑，设置相应过滤条件。下面简单的介绍一下条件设置：</p><ol><li>Condition：返回一个布尔值，当布尔值为真触发断点，一般里面我们可以写一个表达式。</li><li>Ignore：忽略前N次断点，到N+1次再触发断点。</li><li>Action：断点触发事件，分为六种：</li></ol><ul><li>AppleScript：执行脚本。</li><li>Capture GPU Frame：用于OpenGL ES调试，捕获断点处GPU当前绘制帧。</li><li>Debugger Command：和控制台中输入LLDB调试命令一致。</li><li>Log Message：输出自定义格式信息至控制台。</li><li>Shell Command：接收命令文件及相应参数列表，Shell Command是异步执行的，只有勾选“Wait until done”才会等待Shell命令执行完在执行调试。</li><li>Sound：断点触发时播放声音。</li><li>Options(Automatically continue after evaluating actions选项)：选中后，表示断点不会终止程序的运行。</li></ul><p><strong>异常断点</strong><br>异常断点可以快速定位不满足特定条件的异常，比如常见的数组越界，这时候很难通过异常信息定位到错误所在位置。这个时候异常断点就可以发挥作用了。<br>Exception：可以选择抛出异常对象类型：OC或C++。<br>Break：选择断点接收的抛出异常来源是Throw还是Catch语句。</p><p><strong>符号断点</strong><br>符号断点的创建方式和异常断点一样一样的，在符号断点中可以指定要中断执行的方法：<br>Symbol:[类名 方法名]可以执行到指定类的指定方法中开始断点。</p><h4 id="3、iOS-常见的崩溃类型有哪些？">3、iOS 常见的崩溃类型有哪些？</h4><ul><li>unrecognized selector crash</li><li>KVO crash</li><li>NSNotification crash</li><li>NSTimer crash</li><li>Container crash</li><li>NSString crash</li><li>Bad Access crash （野指针）</li><li>UI not on Main Thread Crash</li></ul><h3 id="性能优化">性能优化</h3><h4 id="1、造成tableView卡顿的原因有哪些？">1、造成tableView卡顿的原因有哪些？</h4><ol><li>最常用的就是cell的重用， 注册重用标识符</li></ol><ul><li>如果不重用cell时，每当一个cell显示到屏幕上时，就会重新创建一个新的cell</li><li>如果重用cell，为cell创建一个ID，每当需要显示cell 的时候，都会先去缓冲池中寻找可循环利用的cell，如果没有再重新创建cell</li></ul><ol start="2"><li>避免cell的重新布局</li></ol><ul><li>cell的布局填充等操作比较耗时，一般创建时就布局好</li></ul><ol start="3"><li>提前计算并缓存cell的属性及内容</li></ol><ul><li>当我们创建cell的数据源方法时，编译器并不是先创建cell 再定cell的高度</li><li>而是先根据内容一次确定每一个cell的高度，高度确定后，再创建要显示的cell，滚动时，每当cell进入凭虚都会计算高度，提前估算高度告诉编译器，编译器知道高度后，紧接着就会创建cell，这时再调用高度的具体计算方法，这样可以方式浪费时间去计算显示以外的cell</li></ul><ol start="4"><li>减少cell中控件的数量</li></ol><ul><li>尽量使cell得布局大致相同，不同风格的cell可以使用不用的重用标识符，初始化时添加控件，</li><li>不适用的可以先隐藏</li></ul><ol start="5"><li>不要使用ClearColor，无背景色，透明度也不要设置为0</li></ol><ul><li>渲染耗时比较长</li></ul><ol start="6"><li>使用局部更新</li></ol><ul><li>如果只是更新某组的话，使用reloadSection进行局部更</li></ul><ol start="7"><li>加载网络数据，下载图片，使用异步加载，并缓存</li><li>少使用addView 给cell动态添加view</li><li>按需加载cell，cell滚动很快时，只加载范围内的cell</li><li>不要实现无用的代理方法，tableView只遵守两个协议</li><li>缓存行高：estimatedHeightForRow不能和HeightForRow里面的layoutIfNeed同时存在，这两者同时存在才会出现“窜动”的bug。所以我的建议是：只要是固定行高就写预估行高来减少行高调用次数提升性能。如果是动态行高就不要写预估方法了，用一个行高的缓存字典来减少代码的调用次数即可</li><li>不要做多余的绘制工作。在实现drawRect:的时候，它的rect参数就是需要绘制的区域，这个区域之外的不需要进行绘制。例如上例中，就可以用CGRectIntersectsRect、CGRectIntersection或CGRectContainsRect判断是否需要绘制image和text，然后再调用绘制方法。</li><li>预渲染图像。当新的图像出现时，仍然会有短暂的停顿现象。解决的办法就是在bitmap context里先将其画一遍，导出成UIImage对象，然后再绘制到屏幕；</li><li>使用正确的数据结构来存储数据。</li></ol><h4 id="2、如何提升-tableview-的流畅度？">2、如何提升 tableview 的流畅度？</h4><p>本质上是降低 CPU、GPU 的工作，从这两个大的方面去提升性能。<br>**CPU：**对象的创建和销毁、对象属性的调整、布局计算、文本的计算和排版、图片的格式转换和解码、图像的绘制<br>**GPU：**纹理的渲染</p><ol><li>卡顿优化在 CPU 层面</li></ol><ul><li>尽量用轻量级的对象，比如用不到事件处理的地方，可以考虑使用 CALayer 取代 UIView</li><li>不要频繁地调用 UIView 的相关属性，比如 frame、bounds、transform 等属性，尽量减少不必要的修改</li><li>尽量提前计算好布局，在有需要时一次性调整对应的属性，不要多次修改属性</li><li>Autolayout 会比直接设置 frame 消耗更多的 CPU 资源</li><li>图片的 size 最好刚好跟 UIImageView 的 size 保持一致</li><li>控制一下线程的最大并发数量</li><li>尽量把耗时的操作放到子线程</li><li>文本处理（尺寸计算、绘制）</li><li>图片处理（解码、绘制）</li></ul><ol start="2"><li>卡顿优化在 GPU层面</li></ol><ul><li>尽量避免短时间内大量图片的显示，尽可能将多张图片合成一张进行显示</li><li>GPU能处理的最大纹理尺寸是 4096x4096，一旦超过这个尺寸，就会占用 CPU 资源进行处理，所以纹理尽量不要超过这个尺寸</li><li>尽量减少视图数量和层次</li><li>减少透明的视图（alpha&lt;1），不透明的就设置 opaque 为 YES</li><li>尽量避免出现离屏渲染</li></ul><h4 id="3、iOS-保持界面流畅的技巧？">3、iOS 保持界面流畅的技巧？</h4><ol><li>预排版，提前计算</li></ol><ul><li>在接收到服务端返回的数据后，尽量将 CoreText 排版的结果、单个控件的高度、cell 整体的高度提前计算好，将其存储在模型的属性中。需要使用时，直接从模型中往外取，避免了计算的过程。</li><li>尽量少用 UILabel，可以使用 CALayer 。避免使用 AutoLayout 的自动布局技术，采取纯代码的方式</li></ul><ol start="2"><li>预渲染，提前绘制</li></ol><ul><li>例如圆形的图标可以提前在，在接收到网络返回数据时，在后台线程进行处理，直接存储在模型数据里，回到主线程后直接调用就可以了</li><li>避免使用 CALayer 的 Border、corner、shadow、mask 等技术，这些都会触发离屏渲染。</li></ul><ol start="3"><li>异步绘制</li><li>全局并发线程</li><li>高效的图片异步加载</li></ol><h4 id="4、APP启动时间应从哪些方面优化？">4、APP启动时间应从哪些方面优化？</h4><p>App启动时间可以通过xcode提供的工具来度量，在Xcode的Product-&gt;Scheme–&gt;Edit Scheme-&gt;Run-&gt;Auguments中，将环境变量DYLD_PRINT_STATISTICS设为YES，优化需以下方面入手</p><ol><li>dylib loading time</li></ol><ul><li>核心思想是减少dylibs的引用</li><li>合并现有的dylibs（最好是6个以内）</li><li>使用静态库</li></ul><ol start="2"><li>rebase/binding time</li></ol><ul><li>核心思想是减少DATA块内的指针</li><li>减少Object C元数据量，减少Objc类数量，减少实例变量和函数（与面向对象设计思想冲突）</li><li>减少c++虚函数</li><li>多使用Swift结构体（推荐使用swift）</li></ul><ol start="3"><li>ObjC setup time</li></ol><ul><li>核心思想同上，这部分内容基本上在上一阶段优化过后就不会太过耗时</li><li>initializer time</li></ul><ol start="4"><li>使用initialize替代load方法</li></ol><ul><li>减少使用c/c++的attribute((constructor))；推荐使用<code>dispatch_once() pthread_once() std:once()</code>等方法</li><li>推荐使用swift</li><li>不要在初始化中调用<code>dlopen()</code>方法，因为加载过程是单线程，无锁，如果调用dlopen则会变成多线程，会开启锁的消耗，同时有可能死锁</li><li>不要在初始化中创建线程</li></ul>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>佛山游记（五一）</title>
      <link href="/post/78b31bc4.html"/>
      <url>/post/78b31bc4.html</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="bf4c07551df3883c82bd0c7dd484186b718a4538c24ee695d1d61c43595895d9">9f655c097aaa501991a75078022f8ca8d1fd244d788f423bbfca3f0a8dd151ab83d3ea71abaa32a8ca0054c199e2a4d8d31490f2539b4bf0c7aaa3f2d39cd8412acf9d94b0324087cc4fe41d87e266b8766b5ff3ad107f84886c1f19c511382af9930955a03654e2860231441d87ec8917b1e7d453cba8ef6d34ad36f8984152c96e1e0355410e063407755388f538b24df2304d1a8b9ce0a1fc6cf7855fd3b09ec66c821c02bb55b20023372cb0f7cc255f303299b417016bc49dc3ce2be5f4f411c99736ef23eaef2a837ec273abd56add84704e1844fa3437344592a3a9676849a045cc26878257a04eda345e965bd305cb28e8f7d8d854ca780bace5bcde7c31a79248b138b40ad1d2222dcdc49c5a1b7f481fefa8d28ce134baaf3f872d48573f4b0d731aa0907831da270652c6c13ca04a16e38cab649429128a343d22871e7358abb8177dd721f11fdb6746e97c287b94505981f69a2fef7b78474e91daec6aa43197b24e95b7f0ff47232d939b470a1f7998eae4c437b3d054af2f16ddc578f44d21f989d67b8d7c84f35eae91e20ea703d84f38c02d53809a0071a2e28967d5e38561145ac38b0a515eb7261554700b36d993bba5b4b24f5b9bc6e8ad6a26c02a5dba73f37ec95a3307326bdba47b5b78585fd29a8728af574440d1d3e9762cfa74d0238d90a14fe25d5ab4d71aefdadb1cda875c4709b046bcaea84631ba085aac2d255bbcaf2a1ba03b1f3fb2ed4044b86ed8bf6a802cec6ba91f4224e778a2c75d83284f4e3dbac4d1bda4c61bfcc601ceb3085c5296b0856c4b456b8a02927fa2593e3ff4dee81eccde20336a04c25e90cc6e42a156b704cfdc8fe69c8a1add039054f315bf8d8d893cade92dc08a011daa78a9e975ae57ec503817a99a98644494ab1b4b35f9edff4f1db4f75a0925491188ee0ae99f869e8c28decbbe63e920dd1ace54a1f8f4197b6615e6212c3349f5563f8237ade63f214e9df6bd8bfb9064dd2709d9362d848b22b7dbc3ca1075360f593e05daeefd86ece1a37546a599d998448cb91e8091d51a045dea3bd2f82785a2d3f1700f41866e417993e7d82642e7ce3c423b9bcfaee9252e3d06dd4e5a2fd9315dd9ef1cf7faa4c1fdf955c087110344fab5c2aa1dbdc113a034620920cf18f8c00689dbc7fa55d9b4ebddf5f1063290e2b32411785d139f9f0a7505d9b3e58bc2d00d1255d3446d26461a0a4bdabf03289bbf66673b45818154faf9b41f6e0ffbbb526b518aaddfcdf02049fd13ed172d91147a5a0c05c7cb5f554ce01eb8718197c686a7bfe5202b3d360bfb560d63224a9055bdbccfbfb2b2d56f7ab4bde0d649c3581d72451723e2ca44a5ae8612241b3ec05af492ddc067561b5a3b51829e7df97af7d10f2a9bee88516c395fbfce56d9b0713fd517387da3b1677d2f0c342430479466886db7005acff40c06c70dd48a16220feb39269ced9cb6c1ac0a38a63625ba0a1215247b745229110ae5890b86ec5a63a94f03aff24dcd541557d619f0d1aa10b6441575cbe1e91e2f4143868571efd442dac4a1154f0211ec29f85144ce2cbdc85d3aa53a19d276d46998398f9ade306c3c3288088e030e04fd1eb71407815c8ae34443b5fa09c3b6b04a7eb7233dd261d03124200741a79f8431a5b46a443c878b9a343bda731b0f8aa972311940455769ebe2f6598055818273786883355d982b638eb5beac513dfc50897dcf1f3a838aa2409c485b30b98ab67878d1c3150db940b4df44e49c049ae2474d235ef27fc1c0c0773982bbf27e7388618ae58b071677ae9d3a1955cabcfb599b41cfc724e749a435300bf73eddbae23af93e068de7c18f59bef4bf0bfd636054be65f363276f9015cb81762e91c14a1e86c2fefecdcbb083515b7b35419f864fffdcc743391a68b6038ea8229ffdc90f1982efa41cf8b8ef67385fa3c20e7c3703639b42c96ee40954a7a5e9a587dbb058a62298ab94ffb918630fd61f5856a941c1ac5c25cf7a1262a8c6fbb9424c18e3bcce14a70bdb6eb2beccba7e88dc9af38d938fb2219177d7b28c08f7f93e462439363590176536901232cb83be0907c2070a9df21f6ac23f6d7354c198ec3be77645ed4c23aacd65fbb6a2c4d09a75075f2f0eeed3c7d657db5f875b38834ef9b6ae52f52d3eae0f7123c8b70cb013bba99aa86f9df2aa9dc065df4078fa4793fc3bc158c29027c288692b5daf106839e8c8e096e4191379b07b2bbbe0b1c5be3b2a68c181222b4173051b2887511b3a26b69ba33c83f454a4eff4237ed2f4d0be8e036267170ac64761ef734fdd4e7b695423e6903b61ec272556f033dd6fad9fa7c4cd0038d1bb5febbe607e662dabb8f44aba9de9b856015d42b392aaf3e272dfc862da79e35ba4c87cb687c5577c2dde192c37552f56529c0c8a8851292b2380fd9a4b05b2581978098158a78756fe2447bdb5183a38a40a55d02f6f8fa49f0111d8545358d96e258024cba616763928a7b4084c2884f4315cb8c86832447a22e2109f6633f2684a2ac6471c534c04e8b2e1828735ba2fee827d259aa5d13115f16b2813cbb6f81b57dbc8be652701fa5c1da612c4e6f542f1b71f7b1bc49751eef426803ad007d10d0117db90918601d419f6ef6d527ec2e6486422319ceb996cf75ab1201818d77bf8fd29a765657005a3457251ef1c6224f02d6c1073f82e9a6815f41101a2a2b2abab1408e112c90bf842267a6687694a2158e800ef4a777886123b3f18eab6173f25574b4a976d487bf8a23146854c325cb5b0d3bb1d15db843a9e4fd5dbed14b8c1209982896f4e7356f35498e0498349b155b564348bb74f17fd4dd67f962e8f8421457936b3f30c9a5d3a9249897982fe5f7a8afeaff549681065596d730d6b0ec8c9ba11a2780bdbb03cb9f52c7d254337def257e74942cadb4a179316ee1410a841f2789050ccc8f54315290006edb02491e501dd8df9dc74dfc436073516eb3745ec3d1761a49696c019cad19bf318fb32b37c9b01ffce12356463dd08e2e6af19b1240c8b9924ec321228debb2e24f77f2557633f98ab66833e0198d7bfdbadebeb7294fcb2f977c64caa179b6edaee1bcbb9e52875d8178b14fee499af52f2b4dc0fcc2064af9cc265196436dc215501b91ac56aef70e5d5b50ce6f8cc3d96286d0697aee95560b2496d4b837a7124c158c14064d79390aa4fd1a3b9a5c5f6cb209c4dedf68f2e56e478a0056b6a56d917e0621013025680b8ec6ad09c7f3ba3d8d12cb29c8eab08ddeffc8696cd457d9d1802a399948efd520f3fd7d7fbcac6bffac8ce022ceed5dbce9cc7bcff1fb3ac3b6099d93ed507b7ad80323e337f21d096dc98f61d57c222db883ed67fdaa4a1626b6ed60c98fff7431d7e1db0c816e727d64e7ba975d54d7c6b52e14d6a8d1c423503e2b0bf8e8ac012451a6a740d8241be64efa77d05c9a31b8896913d0f470c3449825d558dacfaf724f6203b133a60efbfc74ecd1d226d4a440f24706aaba273855e7a0d11c8880fde098ab0cbfd26db4f82291e4ddb77b434a03ac5aee5093b97d6084b0d61335fbf6b3053cfda089487af72a484f2028f1ccec70946895f967c9418ebe13805b062538d6f0e36b74e0f3a63653044935c4f95ee6648b2d4644716fa48d77824061f7232ed7a2ce460545b737594bf1eb4283ce656be7a7e247987236e23a9a09b09e1ff4c12eab4a87f171af58cc96a80ce84721dd9307e2719d75a89453e2544ab11e54ed259348b7e91939c1a4488ffe51dedce01ceba865932056a425cfc7ed9898a8e2fc516da66ba0884a67f328c229ec592c9e9e8ad63e734f29c27a9ccf972cf2cb148a3b20e705e2cdd214587b6055ffd260577cf6c8132deeded18288eba5ea95e7ce030ade6ab547b4260438a2e05e9e3a981514b8c81c3ba269d7e39f886cf884eff3c6f70f7952a4144b3d3ef767ea8d328ce557b6dd68e30a3cdc74ca468905964d2bef5ad55fc9c6dfa1e018f6fde6c8676c9694d096ee036dab46c66a8e5de2a789951832c55ef6f297d4216ad1cb4b6212488ca8d8ffd26d282fd011c7b01e3f2c49975bf657fc8f7f361424912fe9a8de961b6c7e4a2d9d0d5d8f2abe3137f839fca83e7a0b79c3524cc45e6732402622fa3233475e2a300fece3da1350daedd61244dc11750c4e45aaab9da3800a4bf88d4fa32741557b751bc99391f436a50dcb4ab9ee87c350c838f703c51845ba75463dd396bc5ed449e8342e102354a460b5489c51d957b385d893ab8cc99b802aa106686490da30f457c6bc1e8bd748d793e8b870569a9fb957329ac96c1f9b70c261b3d19170019449b37690f7fbafda541128288cb2059b43bf42c5b4bfee75a96f1162c6a0aa36fbf73bbc87c8ec02d52564bdcc688bb2bcbed369358a8ebff4edfa371cd357f3daec236701fae4a412d4aad4cea23fa9e130b6d241fddbdacf86067ae1ed12f3db0e17caff81bbf38005b2d5dd70f3958d388be9d223ef23aedc21180b48f1d7726aa38799e5afe6675480251bf8f0ea9a58984b76734410f8bfd883f9730659db7c995ba2977cafdc39a86d012afcf9beba7a2767c5f9f5be1780255b3a8f1c68efac0fd3ef4cc05832f071ef854b6007ad8032d986faed7e194b5dc889a984d381229286307e6dd17e789b617e88448fed98d3b2093922c2cdd733a8b047fbb23e3672e8eb4ae403188f1e33ad80e89c082b97f9455fc1ec73bba512c03e77406ba9acfb990c91f2549ec9eb1c9e9b99e145cd9d1f47a872ffb5f8f6825260e9fa1ec975375440973b4b115a86cbb315a573ff6d47d7e8da12d909e12500f11422e7b442eb4f91e366b990f5bbdaf7bb429dcd3a1259bf5e045c627d815d12bc4188064cbaeed727a8a3bc7b961e63bd91d400e7191cd275ee8d3bd24592cc4fd50b74cec40e21b46c9688760e0231169719fe97cb3f7419da955720576c14d33da969806198d8273098950121086b54ec9f1d912ac2b996550dca85626bd688ad7183dae650e9d831e802a42b387a5c2104e92c3d04e5885a963d2a3bc18b9c52f376a1a1ebc96a5cda64ef97ca8be891c3a1f8ced009886fff0a4130a6446fe8273e1210f5aae189543e57132ce1daa8f7ca288e4ee5f942fe4912b135c0a3165cecd30943ac318bdd3cde1af15f45202c0ad1c29f7a15848464c65ea992c353b2cd10106261b3c3484248cb697a567df28abbdd83383e25ccbfab219e3a4da685492d47cf7078296f021167e4e0838e3c80c38bd90d52dfb68d853d5083b575a552605f1a4657e7bb4eec1d815023126d307bfea7f28d127777cd779ce7ebc9b4baad90692f6a8e9c690f6cb06b655e6c08681c86b0fa47f1cbe4c6aeb44b1693122ecf4377389f4cb3baa35418cd21ed800071038ecbecdf86712835e8b57e21cf617c90b266b6a666bb5503cf093c74a98bf599583e287c0d240a7acdd00824f4d1f50260a4e919363fea30b72f669edf4a2642cfb4ab8a737c7cbfcc351a8b7ab49a4e83c80505f35b747a198a18b548ff3bef388481812ea8c9ab191ac79d2a17e7b50ee06e51d6afa3fe92b40ffa679d53ef0bac00512d84c36f316aa80c66c940c8cd82b0a5a881fc1a27dfdfbf44d484433f6c698b9d1b6f9e783c3d011d7094c804cd5855b94713c2e1254761a3a493f2622153df2dea45008b76e60c47409a821f3ce818ea404148988249229d819ae08caa4579b03f60095247da302da99f33a7dc45e5011c5d57b993556159e1f666d0f2ef15562c7822331f23c080ed1b73d71c7d01227addfb214628aa7e18ee03bc1f50455119151e91bdd11c6c14658daf276c930a4cb558b0dcc75d95bd9cfb4f5a5d36d0f742e8f26ce00e68b22a5cfc8da154e3dd14621789b738bf77ef2e9cca8787007c77c37c0e0a7cda970676a94a068960ad61991776fdb849bd5c3da20318511021d20cb23ee8c74d9d9237068712ba1062c22c70a04168d4f7cb2a76ce2f633081158378574c62ce6ee9c10b9a02c45f7251cfc6031dc407b09f273e81e26f10684ba011caa4de95ffdde3eea523a66050744132e7dbb2f0ab3192bf739c2c5d3460ece942291180cbbcbc7fb47b294c51d3fb3d81d7602418fd83bd23583a08095f6411fb0c2bb73ae894bbea903cdcf09359ae3a0c1f48c8c87dc00d490504ce5a9615823bc0435584b6b1cc1f2b39bc6804b9086246259741f2b74d34260dd2b4592505be2214b53915e061265d07d56d11887b00077bd856761bc977bed1ffa8f7f48dd310b2cb063cf63eddf3d87a9d5b1c25982edb4443fa4f91a44bdcb3fab8e17aacdfd0fe359d3ce929e3f8b3c64dac5c5e0388db637453d318a395bf62ce4a382ab1e38986a8c98ec6e6cff69c65c33dcebe869b3e30edc3246771f2ec1daf14547ef7af8265d9658ba0f1fb6b92fc4b69c23e1ec46aa2752858fd841535b8734ff993b9223ca8914bd762aec3894ba8e75268b8c83a172395c0830000386c56426dba4e937fed55176643b7002a1acf1494e1e8b47555f98916dfffcd837f64d1ceb14fadd4226069d4b1195b8252dd0b791dd7b36a596c56435127f5367445035280df435474015c14fbca362a1aa8669a8d484f63d2fcd0658976e385c646197bb8779dab33864ff589001654a4dd10efab52d367e0af765cd52a5416bf5abc151126af9e3add2ce0a2196aa89d637a2c4924aafaf08dc72c8897f690a6df0a695c4fb438694f2757cb67a6c155a5b5959cf0a7567cffb509c8faf27cc414258b410061c46a6674db4557b3fe6db15c9565e8c8f4d247a936b8af0b3a540fdc3f70f24fb22c59c6468737a924b7c928aa18a75fa6d0b60f32ab427cf175725f918d4f1b12b70f1729cccb17eaae9ea776a39c2293991698f714840de48103e3bd2448f1f3e113e85579161bc4b473e0c21148c3302ec1ba5ccee31968c695affa915b803b517f280189f62ed0703ffb1e174b1e9cacef13b1f9ddc45f17e1d992cb5be852ff00dfebff9a181311fee6f395a97846db24eda82691162d7c5d10d3ebb0e0fc54a4664359fd472624af6bb33a999a4b434eacc36b3e25386acb4c35cf76449d9d64dd10f76301312709ee7495cddb6da3bca2f6f75e4543b97ed465ce6d6d3c6caf54d2b686088e339fc86468475ec853a4e9d745e7fc1049123e5ff0690950bc40e7eb99f2f1607adecbe52110f8d5bcf2b6f63d6e6cb6338a83870d0e5cf2ed37f4e24a8b07bc9061140a4a446d51975424073fe548bd9b1ca6f7b457fe3c0161bb6f198393de6c2b092eee614610f63e5c32390b0673b2b9cdfec0f1657fd7491cbc1d666bf4289eeacfd49bea815ea1ca82250fdbd29fe35c3abc3b6566204c91ff983862cf6d12365727d74312d050a5020426445c9aad6af724ae133aa181c6b875c59ded2b64353a10c775fad7a9a621d16ebd82494c7c9687ff87334279085d1d435d9e28bf3dbb57ffdb1ca78f27077905eaf8a6f96d95c686c249cf905b004e86fa3f311394d34574fd9303fdf007b62d57a9608e4eaff891aff70b1ae199dee4fed967103906e39deaf6ae4013002dba9d62912aa82bdb083f97c03af75a971c91a98a98da5d5acf38af3d6087c437d787f89a953caa75b755dda3a6016d9791fedd961cfd0012ea631ee31e3f15400055b825231a9fb0d05b81d68aac2caae10d10948bc0f70a0c62e181c1c0068dc005792928d180957c196197cd7182364d8da0415a4aeb9ef5fbaf776cbedbcba35ff29b19666c9a3940579179a3ab51eac50945293707bc81d28db50d93fad758eab7adefa0457c732c1111cd0bd28607de002401de1b62c52f06004c85e93452a6b1ecf55b56be93838182e5d9dd8c56c3254940d752cc1ea18fff7ca2ec8a8d5809858baccce3f8fdaffcb3f08426d53d5c41600f2e5ed3e3273435342bbbf2114a945fddd161825ca64e3dcea62f8bce79f3201ca1db4f214c51f2683f43bbb97cbbea9280704e9ee1636de92b84cd28216ffde75b08bbbb4a6f379fd1da880d0e900a95f30b5f1ac5ca5dcf8ade600943c386b6b5fc2c9eac26ecdb4b8495fe0d0d380a745ec01bce509677fa523f48f306a492146c49ff798fba0dd4938296021674b80b97224abcd7444ed31cddfa8b2b25ac05781bfa61e26281e6ec37c2a07dbb1d5e84f8125e6eba8a5a832e5091b10d31ef2b8c2db396e191913737d6e9d00048b60642cf7ec9b7acadc6cbbe109e5ecc2f1659665539fcf36fd8a65abe3834ec7c2e10c5fa7622bf4cfeaee6f3a36960977bc7367ae6840137b51d0b4bd8108f957ea829c1cbf3db47e80e0ce99fec749305a5a4c5a4c4f7c81e86b7c00c206e34b326cb714affd02a5d32b2adc701fdcf84f0dde64ad6ced250b78189516cc2b739dd2c9213bf78d3e49c7a3c5f163ba48a18f911971300e76c1f8c1c1e3c682853d49c80f5304048c79d78965ce9e9e312f7b4d7edd65cdf11c7dd4410b10fc24e41b0823fa48e2e521e945e89f35063dc931e15bded0fc9bcd06890e090f13b2973687a69e6f3eb85e20c529870b67830f9b67d996145636e7224ca43cf0165836fab95c03b4821ebbcaaf7a2b03c3a5a878a19a97f84c57d6437212f7fee3abfcd951f0da3203ff8b528bb5db79f408e5dd90ae58f670fe4a541b2f7f8121dd4a72a46224b55a6c2f3c9371778d907267b3971e6da4fa4d53a0e1c81fd97373e2ad86e23a9b30246f927cc8dd5dbe1eae3e8dec62866e093116935bd704bd3279f18d21d2bf136b287af2bfba34edcb4b4c24014520aec9e270e3b078de20722e8fa9033d1d0ed5894a30f7147f190860666e81fbc9fd154a5966bc542aceceb99540a37c832ca4aa346db65e10a438569067844240bdcd494c1f7995475fd14bffc1d1deb1668bfd8580d9a8156b7cf2ece498a0430cff52c79f675ba61b581f2c617d7e296939cd663f4c9eca7015f65dc32c56cc98c957e0c79d41dc20e223e2d2fb8b16bda58755717624ea04e4954ac303c746a668a3d672a2e3ca19bef456294add1c3eb12384ecf0ad24cd91fcb25b6b24b0fef9c78d3d00a3e6adfdae07076ebb3d7e6b7765fac320d966ce84419240b78dba5ba4eb6b0aa8660d2ded4b5a65354323fd24abbc7d823fd13796e61301a8ddfaad4348eeb468ebbd0b030e5e78a9a6a94eb874f3c2edfe0e58fa5adabd5565dc08f0554c79184052d0e80db884327bf3ab52fc823153446f0114a1fa8e06c82a8c47b24f8b90a3890a0d17823d79c390d07780008fbc4e5b3d3c7145799a7724986b55cdf98675b549906cacf5290af0074468724178df3d6c22d165420d3c53cfe16f9ecbab194220decc8b5883aed1ec3c6693fe9705ab58dc97469a934ced142881d1e35dc6e9675679490e86e663045e9dbd0453b7f7b7ecfcd54a36e2a66ed5956354088bb331e3b41bd259c08b755ef248a16a58e232c1eedac054e08923721a84e290e3b85d893815215969b0456ba99fb2a7c7bd759159d0a3cbef76b413b5c72918821d1a3bb2cd6efe6cec5deb404c938232c83429c6a6d095a5984ccbd487f37376433ef1c07891005b2d39b00714aa8c9982f18c7e769b97745000f8d5294b28fa0fc6f9905beaf6276ad1f4ffd69a1e13c4904189369a982eb69321cb82537e3bbc7689fde241135c1cfe08898469106bca25df70c6d8a958b9c4b112265a9fd1c6b8c1a26ff56e2e0cccf9a203f0ddaf613cd2aace8f8b81f8db171e95f1cb967718f02b9877d87a5af26e3a9df69f6c87baa4891113b793221daba63cf452e32a561ef516e189290c00853ee09177f8fe50fdbd179654383594932ca45a153bb03a4209911109fe7b7d644c6be61f1aa9044def229d6e0404cf07a9e2df51687398ec1d7ffea3764dcf6e148ea52ce484de12178363941711a41a24e4874b6bd4b50a512fa86e51cb6ad4fa83fd543583a3ac0f30dffa5b41857b02f3f890e3fc6029a96292fc7c3e61292e87430b7e3745922b49a278b1839420470612d878ec2f779d48605d090be6b84eba5836ffee4c99e8db03a677c64268fdecfaffd2ef7b362a8790a7b7189d3c227dadba57b59926549f6bdec75fd9adeb625c456136526eeecc6f5acefefcd05df9a9648e84351ece6c221f23ba3ae93141f560e654ee1c246770f442a45f657ace9269be12ab3d180d57ce9a257686449367efd2e9a178b60b96b5558c254abcb3f6204e846db6171c7e0d0d038cbc34b5ed13df36cdc1ccdbd04cd5dc728f3fb8fa0b66f70fbabd7d4c270a0022dfce4fb87613cf7b8d7170c1e81ea3d5397143b29ad971a96808f7ed2273c6d0822e01f28a70fe6263cc16587f626bf144c7ec9cef9f58ee89a65e0ccdb5e2edce0d6d19d634d99843a9f1ecbdf442416f84b454344f8b31b46c69bd46c66cd10738c3a3d0ae4b3ac15712c31e92b2d6bfde3737077ad7e57ecf8abc6a1e42f7f7a08bb364b84a6b74d370e4e0e5e927f17d433268905ba5af18e65de395304074cbae4f2768b13c0051c4c63f50b28e5513cb741c16424e915f3197057344e73e76af3ba28e8ee82fd4069c9ab4ae321cd311f1bd8731ddbbec8dfc5c4b58ca0f5c5033e6e430c05fb798dd0adcac9f0cd472951dd8e7e4a6aaf3d9e181f5a57ad861b224ff9c1318b9c8f4c4cef63d62bf3611551c702db05aea540215c1a5674330eb919b4ec868376df110925feb9ee242e87650144b8e1e9bf8e4a62729e8182bda9c7d7ff3ebbdd93dbcf6580eb9d8240ae0a066b99279716d6bf784d4cd97378feb7f7e2a4677d9e4819c904c38ac2801f44050d6914120427d79ef2e01de0feb9ae0b7c920aedc321055bb8b692eddd438cf57c646a12a90b13dbd5afa2471d2d30939a41f51cbe72dbdb042b818fbf54ab6a590285fb2fb81f6b1c7d01a98ccb52706d17c719cd02c9368a6588e6705dbe0a684347d6d3c8bf71e93feb63011924b8f66b4b9f29741de0cad5add9e46600219df068029304012123103274b2598e3710ce237eb1ea9e2144ed41dc91e946aefb4abf0e94eae8558270c1a651081ac80e55b221121ce129f6c2df8e8ac39e11a88795590d6008875ea448f36e61f85172f12b3e066622104a9dd185768d30347b1c87a3db0f696713d70c4668d1db41af7b365177587543b7c9c5358cae9eff34a8b457a99167d547e1f82eaf7c5d8084aabf8a7f4243855db2f06c86d5ac23fe6a5e321f0171196e26dfed2568422d841d63714b6d20a543a0d8499384487eee3c5bec0c3106e905eeeeead88fd86b06c4af5b0ce17e163ab3336ad358be1e53e7e98863dee20e5bd9fba36660ebe535a79f1b4cb00150ed57c244a35f539761bc98ab6eee4b442e867608d8f3aad415aeae67a027297b08a9a1e0ef53f87fc38d87663a8b72781d8230883a4ebd120b6cbc1a58d8591b2ee24006b050f87e54b61bd0ce70470e3c52f357db9de94056f68866246a243c7e8a6b1310a5d196b5fdd168f1521476e0ef6d5af822c14040084b7219c4f68b51abd61260406868851048d48fd4103d51e71548a5abb62fd18275999fbdbca3c4b45002662b10cd813d4f57878e9bd58780113d4e42825fb6c2f9fddd92fe0716c72a3966732652e86daae7d3c0ed039caede6b09f73aef13ab1b7adcff021961fa9fab5c6ae50ab7e7cf5c941b371dcb6b5d6b5661f123efcbbc46037a352ff0c273d588387e046560f946b181f886f20b1b11f45a8edac4d64d9d17b27a36dee633e3969bf9888f498c4963e0a2a5bea90522efc9d1abb5a5bca1c310e71d52a09b6a42c44c67f2da677e839e2db87a9bd20609dd389aaa3b87a3c5baa8bf198ca45fcf82f9549303b8e14cce3e44b81259e255b7e2f19f022fa1ab3d3e195aa4ce20335aae68491dde63f0868479ae295c13f2441ef230b207df742e9c733d5ac8542c37f1854a86935564e7d089c16ed45a1d1900effccc6cc474c7fe7c740b1bd12f87683ca99a79924e725ebcba52064ca2796e1f4497c5e80a994c7e751502d7f5cfade0aaf027e3470cebab6300f07323ee97f61886b5078693d721785f7b262e009db6976516095b0a2848618d4d11f88fec36b55d5acc87d1663438564f41292fbf1426c05862f6461e7bf17ec5cd6bd907e59ff82b30f29a39e0a60c48dfb26af667d39e66847bcf12a9e9b01b440e7fa6b8b767d6e6de965c2caf6ee2e6283368ad7c5d1b06957eb7034ab638cd676c81102942777f5753951709ee973afd444272a32a3797fe60344103096f0147510659c00db50a4e701aff20ec496f30c870e86c1193aa1d5427f10ec27b0cd3569a701b834b7b5a34cda4c855636de2f070f18bdd9500e7d101b1f95fb1bf303317ab3f95bb3fc13bf862fd23c54f022634c2ed293a79a97cee3b569f9b3dcf9fff6d7dc668f54e0bfc2b4a39d50eb750b1be3634365801be0e55b3dbc4bb6ae03933d0fe552005391e57b02aced5ab2852242aa302a44bb05ab51c75c40502f57e339d7fb5970d623c4b907fad445daa53420b0431516bd005acfdf5ed5c54d1f76b64e998e8fe5526ac14d9371fd277c0e5c0cb1b29068a940ebe0af9fd6bac85dac376d1af025478e91a637f7c70f025c39c36841cd326f0d63f214049fe09b32bb2b6ea00bea3dacf450282b9c8b874147a6d5fb76b0d3e303316239d5dcddf6a02ce7efecea67d01f39029be823ada0d05ca8b6ac477d58fc860dbd971e543381e4ce90478fc88cc6312af97e9009105a1717068652bb4df892878396bd92c883952f71d3b337b2ed21f9ebc1ec8cabbbc966f39a81a5a3664eebf028927cc478a588c0ae212c3eb432c25a638f31ac24213f0a3bacb551b6968d495e027c5dfb1ed328e61b25abb9b0d92cbe8f445e647e8e81fcf569951847e89f1ca173c8d207d4f7edb1d52c2485324146b4a668a2f6bfee5a076bee3749b9fcee6812fd5a7c120d34fd8b63cc827572afe187e8e0d1054f0bab3149197096cafaafeddbbc972d0f06681ed55e75857b706bcc896f2bcd8795f2b794eee95389c5c4f43d00825d7007f140dc2b591d8eb8a5746082d5e7c4b310a754e037b2a8c16a005bf62ea2e0ac26b599a5940209593866c82be0f9f1c5ad03636784df9a1e071639d12d22c0979b9c85b3433f7e38480f597b8a612587b8eded0aae87f414180fce22beb043656aca63cfe24ab8d5b0bd55c9da691b493a157f949c910ac45603f3c1e0be8ad2d655f5540ad0097bcfcf80d55d12f49e5c267bab53b7efa338a7fcb2f696b845cac0c90e5c8d3de3717ecdd280221bc938d651416fabdc1f990a78f84e8f96735d5bed5f6165aa11edae05d03c3b4c6cfdd9bd08e66c8c05eda027b53c055c9c7c7caf2b3e615fde5a350a337b2379d376a72bdef5de5c1e0e3ae30f0ff98bddc6ab6f1c993fa691baec348bec06df0f4c6d788303726cc14699aa7659e0388ed6a74ac930f5792477e5137c69e61def3e712a0ee15c28ca717f3a4292c302737217d333fa5932cb1046cb5cb6b6aa0a20deeeb3c0968cfed58c441c1ab565b2e61edc8d5e8280b869811bd4caacb8de0f53cad9b6275a838e1ee1f596907ddc5670b830b5794ef2290f8544609a9fc4f550dc01e273874fbc8f119467c6357230ab55b9ca786b631ac404cb0c054306fb38db4dcc0742ee57d2fb7ddcf0447608eec236de44bcc6e077338f86b4a8ddeb8fec9baf7a5435668907dcb2ecd2e91a14161ffdaf58112b121c6071104b5d59194bae26fe3d25ed8b68afd257dfc74b31e0e604b7562c46f6c22f73160cead3cb95e266d8dfc11f5905649e0a5194b361857d2b100fe4a6b0bb4dbdfa544ff28f07b75aa7d3ac9329465a3c27dd05d52783253b4eee600bbb595117f2e62ba5d4bab1ff666456caa4f8f285c26ebbfe61c60f11a7ad07a15f65f8bf262d85470ae51869dc4a820ab89d58187c907acf7046e5035b52a75e7e98ebde57a3a4b1658dc7b3957e851a3fff413b988a6af69862a048e1ae25361316dd0c59f99f34694cb6fc39d54927c4921cb1ab0360d18f564e6a0dca5baa81ee2597d4df8aabc05e8fc2a042e11c9cd07d25e04c67706637f5fa2e51dce1d6819eae8cc06b2c5e893a1ff6ef67738fac812d9fa1aa3fb9025447faa866b66f317f795d0c28a5daec091b31fdb482fc55576a7f94fc648c3b90e2068fe4744617d8efc6412d8c049e3b157099db164e1854d8c4291c6c640ea3ec4178d2e61ce5ed7f6d6a1e6a6f1e2f274921f95864d6759125c4cb383a2bdfcfddf95ccdc996bddd8f8fd526575e0d7446b5a7b80a9fbbf2c4a9ba96a1dd8afe1b7a8242b86bf658f6e7db94e80e2fba0f5b6e929e968d64be6bec718bbf77b4ed4877e52049a7dd9343bb29605e63f127475d7f8931aff38cbb53f0d51aca4c13feccdc831042de3af36780f8f3178dc793a241dbbcf11d2581ecd9e24e248683dcf78a596b977df0f97941a9c39230809dd9747e7000a42c41546aa842fed201754c23c91efe7bd67d92bd495173a510d142a1f62c7e54202f8696a5469b750382eb6ee034a5cf9b357bf6b9ab5ccf3cecd2586c36f0facc613674a84311ffd5b8f5ef9b976053d1be26024ccc3c0c7df12827b13bbdc23ecd475df6dcb20bcf83107703b233d3ce8abd4051c7166cb8616b0dcf3150b272c30ed3f206498dae61342f7f81f5a426cdf6303ddea7405ff722f1ce726d0f053ccd7c7626b6d0405d178fed40ab48cb40f3c82ac4606eb717908fb35caf6d60e320b387242273e86e4090c3d7b8985d7f56f2302ad2c3f41762fe06cad5c33d0da8ef7a2e34a077ebf4d2a62b0bfd94a03a1fa90250dcfac605984334da688f86ac824d5fd0fb54576eee12c3bde560d864501ccb1e13467cb7a6de0937ee5a1a773e091dd62988fc92d647714b3398ce5d8fc37299d6e4b7c1829000d98cf97a05089c20e807eb2775ebd8cc09d396cc4fe3772e0d85ebad8c58aa52561b49f8e89a82b36e0e235734240182441ccfa179b8150a7af80a34dd56e417fc36e3edc291911c5b1694a40bb8ee2b3f3a2b3867a8964e988fc02255f98f87610da4e0f7988516621f725a38ed5a778cf81fb8c7f62df96a7b58fbbbb38f24c19889f0c0a1f3d38e2ed731942f7aab0057c0a1de2817e6a2efd727699ee23342280d20237f2f0a338b136b3bd5e4431125e578b6a27aef4be1086fce1306bee99f2af79a655bcd546c6268846036e686b658d011cdb09c95e91be032193685adbb4384c5f96f4c7e0c898bb9bacbbf3fba1532d9f0221456719fbf4362aa7bc4948d4f7bbcd802ef8dbd207b1633444be2782ee19666372b87357c23a4f9332fa29d00fb4c94aad838725e73b259724c027973c5322f6d7a3b1b8b8f12d38ab224d033e817f5ff65242545085b347a7530ef5fbb45df5396cadfe305802c054a9d97c962acc18eb7e1817467903c42293b7001c75fb710b809ae155d8f5f96bb149c97219ba046f22873f52fc20bc2b3e06ca0010c68deaa39276cc5d22180219e9177bcc20eaf70ec8b8949b70a64e0d034b154fd60de3ac2ff75780e263a08242cc42de8b4327404a26f725a2f2e1b132cac05ab4ae6962e9383177587b98372b774f084dafdd89c523ace387d822ac9471680a0349820ff5c1b60c547c9be9af57cda4801754f0aeae4d3032a2d2bd3235cd2815f4c9080bd0a2a95a7bc26b2d6db0705121a16331a38dfec5dafffc8959c5e4bce874b779c32b1feefb5f3ddc40a4273f45d9bddeb523f0d5d2d116b528873f72c0b0aa86207b41ffbc16523d0df20b789bbb2d1ba16b1b63d530c9058f97b2f40be058fc1b9fea31a5ee37c59914e2d058da51166f676ae80c3ff2127fcac628feda67b6e873e43f7b11ee9bdc656370049750c9bbed5c5b4c168e87990a46fa1d7df6d125d108b92ea92f564c19e6171b13b8e571942e2992252715879432e82f4803017ee1bfef40c0001ca425b</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-xray">      <input class="hbe hbe-input-field hbe-input-field-xray" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-xray" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-xray">您好, 这里需要密码.</span>      </label>      <svg class="hbe hbe-graphic hbe-graphic-xray" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">        <path d="M0,56.5c0,0,298.666,0,399.333,0C448.336,56.5,513.994,46,597,46c77.327,0,135,10.5,200.999,10.5c95.996,0,402.001,0,402.001,0"></path>        <path d="M0,2.5c0,0,298.666,0,399.333,0C448.336,2.5,513.994,13,597,13c77.327,0,135-10.5,200.999-10.5c95.996,0,402.001,0,402.001,0"></path>      </svg>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      
        <tags>
            
            <tag> 游记加密 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>马来游记</title>
      <link href="/post/1bff4ac0.html"/>
      <url>/post/1bff4ac0.html</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="2976c149a70e63849721efc12409e8a65f8416ec081768efc49ace01bc8c72fe">9f655c097aaa501991a75078022f8ca82cd841140fe3926df905060bd8a9319e49d12c43d6109d28273f2076d9f333dfdc63031e095748d24db5b5d52509e8fb0a357ed7e0620445431f920117c53b3db289af1f8fbba13a7e546eef40919b3f8f79e9904b7c2a405bc580d1aa72d9d9e629f020899778cc4e4db25aeb1bf2059b08dbf0cdae10a5ead2bd5feff28ed556839c5b798b070ceeb4f648fc17a74ed0863ca80001d4a87e1c7b469dff1d2b6ab51f85e3c189ebdb388c422851bfc28539ef563a24e3bb11088f41fc8fc76e50e17453a3dd2e0cd8944fcc27c6f47d8e037b4c0b318b5b379838047f700cee5dc32a09f422f82d9cadd03f44b5ce8d687ad436f10ebda1f733ea8cbcb23a9c056659bea5a262e6cafd9701414de544cba3508c998eb45f1f7d5af3eb72e6f2b33aba3f005dc91b88ed5cbd3959c3ed8d3f6e270a9b25bdfb7d8516b8864426d3fd29d6819aad1280ef4da29f21c81f00c127e4b75011a79b9f3e3aa688f51ec54ef07d598623a5c93108bd88d1e0f3f6dbe975769829c43261e59c7f8b53f2ed13c28ec76e50eb247908df4b265f1d722f229bc786e03c3ac4042e9cf348773a96491006dabd177b039eb717abdf50f478b150ef41843f967cb9551a6ad92e77f955d8c20787bf74fec418cc314841f686f7e5ae24c2e97c674a6c642e58e9d17418b0970d877c55330dcd23dbf8c74093b4409010772d468a40116eb539ff9db18ed5f82444ce84779d54171d02a551e853929cafcf73ed605ad87e6782878a48d0572cbb815677ce11b18a935e219b24c5a3f2b8b8c33d2eba9405417c96fa5ddb0948c9e53015416eb40b85e7b56e3a054e078913d704907f9fcade8323bf17ac2249165786464ed87f6e7b7c77ced79715f0028a5c2c5e85a5eabf73472efa371ead5f5a2d7ace2faad95bbc9b72e5018821fe29e8bd088ad3b9e540c161ca38e7a60af026c77e4d444695c8354b200b4faefec8a322153c4c7e74e5bb4c64287a6a21823270ba598a1efe8ff772dd3af27cec8663aeaaef561a73816f9b79d5bcff7034b626db2ea907bdd8d0feb2beefc3b7c7d62cb27ce293fe76ff9ecf8ce26ca26fdd3162b7691efd91388df886e97c168f74c3b7c1654ad293a81f5d8e566bc2764e6134a73dff4c3751883e09c5be867837e2d010a20e42397dd945bfc2fd61018b15470d5da7995851f3b542f338625125b89c95412c6efb1a030de23efcca97f667c07008b69475b08d3bacde93bb7b4c19332401ce6da516d0748fbd8bac736741edcacffae2e645f3b3310e45584de655e0033f14b99d2f5dba697a5fb650dab915132554d5069e0fee1b799f28ee1b0756bca4cc9040e6f6ed71ff5fefad7417a2cec1fdb476e5b04c69514bbc29dd16dc4953a3fc2347b85ded61c1c5cfaf77b2f17ded6225c358e02e2ec1dcddfa3510b4ff1696242a6389be59ab12cf686e114266eb9507aad41554f4ba84dea68a04067098b0c5e3c31b98aa11b874e03bf147433bcd07d901ee848afc4746d36a7f8cc9e80bdf2c0b4b9d8f8267f27e9d037e74fbdadadbe0244b6dbb635334d2f5cbf774bad220aade68e11d75a3f6ba38c89d1b444536b958638b89f5885a836a06456d058ddc12c806f06f4e63523f5559296006008e634daa170c83dda43b430f3567612907fb2bb993f0d2c9178258567518077593db644119b633121bfd5c0b2695d6dc8952757e6f0cbdb50e365f4fbd16dd0c2045515c7d4fcef6f749847d438aa0abcde816a63c7a6cb8014870505284be4430d8d88b4e9430be46fc710462e0ab7eb92547c06f6a2825824e5039591071f8eae5f2442b3dce9d97b48f81d3723e229dc8d9ebe3f154b8eb8339f82f19cb209408340c1d33c894a353763722c7aab92cedee3dcf6144150adf0374d7f5db61417bd4b5951e4e267cf3e5c6776fc6dedf79cdc02898bba0124e0854f9f3378751b4e88a3b2fdb9cf13dafbe842175a3bd225bde0944c386039ad7a30e098f70a60963d9cfab11d19d0188fa081bc764e96ac9efabe9fa395d9d2110d987350d56ce7f4ab925458ec1776fc75724047fa64016976e8767c698f88592b95c4facf50ae356a5807799644fe85a062404e42d2a14c734f5898131447c034c7779b5444edcef95f9bf2644d50290efa9dd0ece1b1fa71318ce0d0e44363944e7939542c74a556ae09e3a83177e95230d34dfc9c81a2dd9cd4307f202d14746e10e490a5fd4485f665b78b4e3cec34674f9c69d4651b8fc030bb082bba4f56f9dd1094da64ffda19bcb7953a995b671bfa28697ab7764a649b02def420bd8fcd6cc6fcc278aa97afe289c44be1390620ae99410dd3690a72a5ef637dde9d49aa52c7ca7c941748990d75cb0696197e986ad97600039ccbca284f791ef72fc2603fffa36a9cf925a490eb22c56f0308066bd845d8028b6b206468585d6f223b3986cbd9cc3f421d5d55ae5f3d7193c59923572c65a095ce26f657e69f9ada46a9d9d9d5e923560387822fac9cdf8c48c86eb97b6b48cee4d0fbecaa3a1a4ace3fbc1bea66f28e1b71e8cf4b862f73fd00e2bbca9c454037536a475503936e31fc0113f4560c7c2612d38c76d37a9539da498b2c2007c386471fccd0765c87791ff66deda8cf2514c9848d69fdfba9519810beed5be26579eb515debbddfcf93c2e9b800fe709f6b560665f9c008db20a80541e21693868230607321df1dacab910e964fae80cf6c9e6798a1702313bdbf07644d752ba7f36703f2f06131aa848fb2b60e07350b3ec934363e5228d92aadf484a263a4ef59e0bd78629fac2b5843a253085c73b439f7a41871f9a3789f467b92b795820500ed2093cb5eebd572a68a871d625a91c5fe980e27676276172a98117224d0bbc9015855775154c298117321391c4abf93646585f9b757465e592e208f90e803c4877b31a9f4d801eed80ebb6edb84d68555b7e9c6fec49266a26afb9b3ffea46f993dffaf14c8fffb4190ad5a71370cf8981080378932483fcfcd131f34065f05201bc8ba30169415d1fecf1857a74c5d1e8fbf533baf718e26daee0e7556187100b787a44f136a34dfe716a2a0f9e8e478f696090bf666b292f16281be062267fb081485c9f85a3f33b2d8e0da4a164312fa1fb519ac2470ed7b350f708ebe1191fbaf0e40fd10ed7478e055e5c986a5415a775e15107ad6e97a199edaec97ccf893d0977ae3a069c01011586ecc019ce318e89b68df65b82615477a2cd8dd0f17f1e4173cc1ef6e6422f6f505153fc146dd09521a468c104cfc9ea0fe3b7529852bba6167a8b37afe95171029ab5b1470f307881a3563325a804cade5e107f2c415555680c9c7c173b7a6a8cf5decafc5b635bf60f7ab5c2a65af2a7893c0b81f110d3b4a2dc5ebd749f52eee530df14096a20756c68f02cfac243872bdf776d4ca89f8654f254206298f1556d0b5e5494869c8bd4e36157507516594a68a164c43a9a09c35a74fae11d04baa215f7af502c1c879c80c7e4f5c5090faa6336a2429c0b4d8f60587b4c91f210987502e3305b0c37e9aacc7a76d101db83bcd7920282fc51f6a6f82c761e700d4c64f0f71927cffd40014924d3a44666ab51cbb2a187a9247cfc3a418286aed466cd09ed60e330ad34306889c2d92a1a2fbaff401eaeb7a9ae71a239d365686b8ab02baddfa444a7b864bd2d19e596c2de330db476d1fd6b3105d41eba4eff17a30c4ebfc1d3eafea51089d89a7b7f03077c3a7137e5766765d5624f64505f2076a4c4ec305ffab57e9dd7cff970797d3b24ab180e0c79212e6ba9962dd3041e551e9cf42232603491c1ba1442d6ae7f2fae7c1399bf1d31648f2a88aeb124caa00e6927c6384f7d557814783e58c29bb5629b9ecee740ed85008abb094ffbbda638a662153fe584405d2a0988a591e41c5c889bbe8b7ed75a1eb9498891f24c7049fb68301e62a2cb5e8cbb80c7e5dd3e6e6eddc5cd19e82e5499f305767c2a4ad12db578a66d9fa13ffef0c3ccd85e84ce36f6fb60e167d4c363a7e1f60797f49475ee800458bbda022fa6a1e8f9f5c8bac40120d1d5d06fa27102a1802cc44b45f04a3b16e7aebed1227d365298e74f4e697d787557637187f8586707771d1c6032ebee2ab7d5ed6cb4c25898f7a31add2c9be708ae14b031b9489520433fdb46bcf987213bf86cd61de6489f7617f7c4bc872e456f0c8ec2e2a6355340c2dc4c9386ee4c7f10976a5a43fea538bdb36b91f0b41018b527a10ddcbbc83abe074ec05088a38578e452d27a8d4d11b5f35444d1c6b37db729a89f47a333ba754024e69c3a4f7135fab88d3167f11aed406280e8970492202d57e7027b1c164821c034f10bdf2c089434f5ae224bbd5ffbc9f6bb890c18cfc0c4a6f69aad511d09e092a1c2f8b1174826c0e56593812641f7d5632406251697ce73e25cb44b637af52115e7d1b4b20206c7ad779d7c68d0109cb5de0ff53b0d9dc687759e13a46a82cbb1ee97c00e7e7a2ec74d91b283f2d93062ca985500025ff2b908626ae02e190261d465b41269a2fee5c0e0700c8c89d67d34d1c5f1ecef7dd657ffc71ccae2cafeee70bc1cd87b294868f8e200622e3e5ceefcfa3e680c39f4a961ebff96d42759b96f6388be74759418682f981b6a42f65970298ffdb50ac745e0b605fd5d67a91f0ab07726f7b830e6a70004f9a94542051e374a2303643f44516d9ce2a0d446393acf1cad93fe3a4839a29020789d5a85d7267c2c0035f920560a559973532c75f04df6ad852c88cc34633c57b06726aa700edb75cff1bd45fea25c23ebea8a10a445dec6551d99ac3a32f3a71543599b84bb554c5b0f5504f791ab82fa5619a404a5cd5589f2ff80d32a96550b22dcd453bf67f2b467af7443f7adf669c72e11c368b1aa18082866dcaa77a60a4113433389ba88d34c3a2b07c10653c2791267fc2f5b669fc8ae953b12f28efcbc47ac255f6775547a04c3a965422f0d9903381530f1e2d902286e487ac4c0193d420d190a08fdb808539fe1c77e6aa789ce301efb30756550e976cabaab0899c7b4e23c0c83d16743a8aafcc7728fcde8b7c441ac93085047edb48e6fdadfe87234ea1b888974b26288503b8e6811c3a8829a3c3f68f54f1c476505c1293a209345333bb3ae72452b42f2d38f23a0f79976b9ec5a5dcba50a7ab131bbeff75b61172ec90b4b2300ffb66b68ae51bf16e1294890693e0e4e65abcd6131f5e16041ddf4d2f8ca45367b3f3177d49162479879a64327b379e1db357a30e844c2fb063605c337f1371c4679f6cbd6e310c050818f01955b378a651ac4ca0df1c8abe9d60727fd8ca63691ff8f49a25274641ac63334f9674eddae0dc1276cda689fdd516704f8030d08f491d4e774f48463a6de7d2d2a6100f5736252ad9995f048d2905982a8caaf9ce197a5616b61f62c342b46db33137213cdfe5fa1bbc90fe9fda9a6254b91e745f1dc67f009aac938665f0a3e969a37763c09748e70e5c0a7d2f2fab7fab5f5d33cdba984ea18ba498b610080fd0e5dcc9edf1d50c3d6021d171a838a80f62ada8bd1f3c9cba8718a586ea2912709db4cc4934a98a3d025e11fde2951af7a5416a9e2d4376ebc74e932d115c3592d1acfe551801dcaff8e4fc313a47fd3b4c9576ae95fe8c37bd32603f2bf0787511ec7533faaa05cc9ba6ff2fe6fb7e1670b70cdf8ce79857cc76531d7130aff577a1d38683982e39b4b18eb64e7d1b9cb7079001880e541e219e2ea89653c503bda4e742334c2453024ded73fa958b23c6f2c2bc48ec07cb4cd9f5a5606a38a9a30783e5a4e047902fa0273d93c43ca6af5823239356ec84e27ed42cdd1c1f2a8f053339c90f7dafef615d2c6a4882cc7ca857f9f8da4a0dedb9880e58bd19b5353d8bddacb041c3476c604b98302dfcb9f84a0952b7596700b4ed690e2a61dcd92b320732fe31815130cf0e9d58465bed1864246b5c686d15746bfb4424fe67ddabac62608eeaa1dcccf5ccee2528adf95cdc0335577f1c85fda70d97f1b89e5959c629ed529279412cbf139ea94dad829af81717f5e360b03f9e856e6c13493d06cda50b7a401d6897452969fdd07dc641530e293c0aa93c451b1ef677a437e41ffb5aaecab73e5671e4d1f8d9633c19cbc7c1fa66f8d28094ad58a590f87758980d9b29526ea2bd687aa7e79cd730e3c399f6389757015c1b370eb4298e0ae64cbe05ab96cc3a20f9b815d15b4e24d8ca13ebd5a492d0d9dc9668dee78817073c9a6cddf461cdd63292071eae66060ddaf03807d12e44c9fad5d72577cd3a732ef58b8037bd109e6de18d575d509045b166fc380dbaeeeab852256ddac9c193cadc89cfe2747fdfa5a98ba53ba433013ae5a4a172cf7908a3f84545db4da5e209276ca8943956da879b1417d77b1ab0d4f62b327a6ee479be8899221588492391832bd3b1961a8f84e4e7280d09f58b5c74148471164036b9a43f7c4b05b7855cd568bca88f4bd1bffedb6fd4f9230e5e8d91e5a41dfab74a33429f84c759363fa9fb5c440b4efa46b38392223f74c07b200d586fe6b107097a408e4cf75b85ce7f4617b4d101f8bf43b60c71460a556dc4aa79c62639c31fdd0d7e6089d35672b6a7c2d1120274f6f26fc2b6669e424a54b25741615b95716362c609f80c35a14fa61625b6e6cb6c42b82b89c6f9d9b5bef60dc8d7fefd59d3256f74bbe83329efc47990a015585fe0738c5a8b12d2c0260db1d6f5109862c45124cd3ebefbf7fd6952970de14f9781419a714ff69bcde0c656464152c3f40e46162f5c21a3207625b9dbc08d463cc63fd3ca3f5998f3a4767047b6dd1b988e2382cbfb968c147b1679eeb70aec66d48df3ad8ec91f734465a726870caceee82d741722839bcd2822cd3f663a09e222c0898d4dd587f73c18b4d44bda4452f87a5a57cc5773a2ccff3721292e121dd76bbc11649ede49b998bc88246593ed6a044655af3d03a197a34660ff6921084b21193c9bd80be9138ef4eb59557bf58d7e0cb34313f7fb4b3f2decfdd04d2e2127a7c5521f3513e05001327c1fb0e41278a90cf8e089d2317dcdf6ab0d933ca217eb32ac97671337c14456f95d0d95171ad784ff95bc9b421d343f49e526ace2f2e0ccf1d19811e25bdb822010ac0c1cda8eae609e456157af1295ec4052cda2b13b553fab68a3b7599d522f49d796c26c102c6415ebaa18d2c9bcc62d1ae4c31f8e3b6a28b2598e56d8708776fbf2a474ab08cbd6b05fd75e671c4ab12c54ca89b1e1d75bdd698fb9be42ac2f02d7fd242b5d8aec110c5a49776ba6349ea906803c36e7ec56a39f9b2f12a6e785c24586cdd6002e755e0eaf0d620d8c056c04932ec3ac5953be9d98a8aca38916b9d6447ced30db956eb8d707f34ece1bfc71eb06127ee9a01b4aadc9128c87b36214ee09dc76b971a49b1b9e2712234e92e403d6c14e71f2221bf3c7186caf0c6b3f102ff9bc4691107fc24ce1f04f27e8d5af3b391b3559019c0270ceed5e061ed1c9a7058d147aef49c37e9d7231f23d1ee4af82881abb469649146d130a4718d9291b35fe97cd7fc3a88a488701478bd3c1c5e6f39e05623d0a02baf85b2ddad7c0683a03daf429ff8e4da4a0206d16ec3a3de81625e254fb6b79103b7cfb738f063f3992dc45b6e7995558bc8642fb5a2380c09b24b9968d7fe23a281b24ecb23b06b565f2b50161399e83d0d9becb75546fd87d7051f45690adbb61b85fd49750d386b295c5ee5d8c354bf2db912b7c6e54eb34f2f5ebd34275fd1df1f7a9c471d0de370d5a61675f8511fd8a7cf0a929684c7addf0559ac9a2673586a95c86f81b8cb99323722cd063943d25f3a76f89d58291a8aaf32709144325a3dc6b448a22296e58bcda9424bd842fe127ee91c7d072eae821e0075756c81518d3b03f026babaf43d7670fa21ad1c1aa5a54490af594fc8fda107caab3cc576dfe47de02e5d30abf0b199ef71f954700ad2a847f2cfe0c8a3da2ee6452b75c929e42ee3bba0f9c218c0e3959b64ab81f922e2c40ffef20855e585dd68ffd35ded527cfbd7ae46c7c2cf5497dc220f92da1b7544fb7be2ad936bd244c832ba4500fb4a5327dfbb7613f6eecb7d5696d94328d5e9ad8a817905eb29ae2b0ef2935a9b4d676db94aafbff20f8298079fbf2be931b847303ad480f322481fd53a41e3e5557540f8335877c677efb699313d975a7e4215146f078348ec153c1fcc21bc11eb2b8e08c69d8fb547da228667a3d5ef59a03210af28873bc7469e11f349ccce538dfc62d732f2d40ee4f8104c51282bc23f1c59e2ef4691414382ba6c371b134c5ba426783b4c50903c672077b6ac2a9cdf5d76507fa0a0dd38812bbc1a01a4c8771d61751d4cce39f30eb00a8255ca79909e6accbf55081489f341a8db853a0effcb81e26295daba662a7041b33541080d2097dd06174c6d9d5740ca4a0f185c61b67168a72c670fb4eb3b203fc80731d57e16d415209bc92b2ba63d2b903347b7d72a2c462a21c16203a6f1ab9a424a2dc6405df3db639ec2c72238d5695631ffb4e2ec8c3aa26f0f4fc46d942abde4b511c28a3dec0b963e3645aed80cd002023d73f06760b7d3ae655207865e3221d89b059dd7af2545c75d3086ebc092da7e09e615427371e68ed150cd0b04d4eecad176b086d05c95d1fe7e2e975e590d8d63580913da9ca03a7a5cc9ecb72f45c24c8f834a87c399a1365c058c015e6b218e5e586d09e9bee81f6415420b2eecbac0aae6bc26aed5b3ccd52060c8514b235518396b6232ceced86c2a969f6cb50c7d77bbac49ee5efe17ff428c9cd94f099d812a5d8919816f66a1aac2e93ad63763576af2e950d51f75c82c90bf44774ab1f65c1f7b74172d711a126c5ad7445e6a6099433f0564fa709a8935047e287b42bd8df4bfa6a86f1074092f9dc45d2ed830af1ad7d09502c30cfa3948a4bf230e8cbdb647909199c9ba0853f0ef2f48010653fbf21db13f63b13c54c774e48862c2b275fddab63ec063b62c625f90988c10b6513ad0d0f64400ec57488698cea1f6ca9c1f78f8e49bb4249ade2871cffd946d711dff00c14eb94b40b0a858bc8569c7660e85f9d06c98afb3d42b919714547c784c1403bd6da3dbd1e94c71de026a345faf4fa0e6e4742c44b94b3f45b205a482c3c878b6d146db7b1d8565925f61765053f48b1f3a2fc5083c3034486435225327f023a6af74773653f9b6fcfbe46b8979bcdfe3e347c4d156cf52938e16db9628c3856b764df5f8dbc845c426ea5e5796d580217235536dd10369e79a4439c97ac70a88b0419351a52aa7e1aa629d9bc667680007940f4b4b42ba4b279a16c4146b10dcf63cf54e67da9d1d3282d2b998dcde9d30cb237d9ffc2953fa5512438b67af744ce64767f9de51acd0e443fa02708d3b95969f4cb6b80615f66b30e2f5d2d723390700410aba295c37a605d4b2d34d3b449b83f7574f37ca60cfc5ebfab503fce988b39301e8d8d81a64983330a1141f157c3299f061c4fecc639907aa2f6fd2a919aecc308af978f9bf8acc942d14a6e275bec96524dc9b87d270408075f53f61e1919d92dc6aecab07e0787ee17910d86f1105045d8a3bec4ac207be0b2fe45c72ed0503ddc40e5310b3b1fea1864194949705d79aac693d87d756a818c8690c950dcc8f0b6cff564d387468f34021d89c49711b53458c56c8aad496651c99993c535f6f0df36b20c81968bcda2ade388535ba616600a3928dd1bc3bb51507ab215d6dd3a95c5376e6d5d16d38e9096da25f0a8667827f9c6cc7e279e8b1e91f7b0eb4e8cb56c0d688947088dca05ff5a07faa7dbb34ff6f0aa6be1ddefbb3af1157cb6792d7b278bd15ac0a3581ae81aef7df13c5567bf2639cf593ed72591220db237c971abb15d6b6084f108caa78fea166ebaeb59bc2bb0efa315808281939c514fbb89f849810f0d310ddf1c5e4bb994d594e2f733af122af4772d580f3c01910722e179b979be67ecea590fca92e28fb9d4c925bd04f25d4581d296a8a8c1ebb3aa3bcc489eabc727f61fe768b91923a26cfb2a28042f6549e90d22a438ec4a6a6a2ffbc55a87c2e8390b5c265d1c558bd5577e4b972fdcd08847ec0d4b2806b1eee8ecfdcf6abfcd8903a9a42104504a48703a7b6d2f4cea07a24c7421688b294db3c526fe43b0aaef914fa0a7d3132b10b03eefef3f77ee3aa264f12c6b0002165e40149ee3652fea9f6942d946bd5b3c02f464da94237a0d004a3bab9c2f607405d3c6b407b0f51a0292aa7db0e57efc760899f4304e6df59aa5eb4189a7e38d611a4a7d90aac049d611556e075f0ef4120fb0825050ffb9a1c43aaa5ad2990e807feb64ebdfc9f6117928d53d99b5ecb6a0c7a7031bc3a6b3aa94b108f67f36b13d876ecae4c7b40f92e82efbe6a0cf624c6c836ddef12a8c1b988dafb5505578e35b8505de57ca8ececd3f9abfdf6720400d3f86b0fb09168a169ae56465eb4ecd683d95f544bc5b296b4e144973a77fb4541be808226d4dfa7b41a8db0cf80b7c5a6f4377d9b73cb64de005bf47555a47fb7c1132d5ff983fe3de8252efe9137eec8374da5257ea562c90dcf13a81aaa2f8b7dc619150702107f8a6bd4a4b5a6f3155d88918ebb1d2d96510aa62ec6faeba75e007fc1e4f9d3c3023ca16cdae9708c07365dda43fbc1850b77a65ec8e2eab992069bd8b9002b6524a3d386fd73e34207f314d002453359fa28109e681f81943476410820da5888eeefb2f46df2b07d74804e2b6d952e6617e3f3dcc66eb3cac2e2001d433c5673b1e6d303876925d8f1256d651e80a944f346632a934f5874ad6e1384cf09f231ae5bdb9af603b5d2a4fc630e2884fd0e1942e529388ca2d2ae7448f4fa292c67733dafd5589dbe7c7d412fa54a2c6620ca5aa4be0800bb022560653779f6293185bb41d55c58c80b4537ae87b0b39cb6adb1fe91cb828f77b663ad5ea930b45d8e87a8d586395d86f4e7b6f41f2da6c24e41723752bb1f088cc7c054bfcb9dd2d23b95acad2b4ecfa25b99683ac9de2952975f826577648a0f6d173924e699dd1d3d6c297f7c21da9d8124616b2fefc6686d162023e890e13d0acd646a9a6c44ec6979b2e305a0c6e2cd94222535602b926520b7d28ef084ff0f0fbadcc9548b4c68db7d2ce194a9e28adf4b0b569fb1e628a44d094d09ffa4612ec1e3eddd08448fae4443da1c2acdbf878da1afff1450f22e65ae4b731f0557d0220b35fd715d0ca25c980256c6c6c9a7c0ab17986c98428532581a4b8ba495727db9f4d3607b311bb6309eadf584cf1f0d3596175b3c54dae280f648baf4ed73b26b780eb96b87d107ddd693c4c6176ca22c1578346a6610a370c276b952a8deab9fbc68cf2e7af6040409d8852997c003eadbd2dad5ffef11f4d63673c2a79493cba792dc42b83d072d8631630f7b8d9a8329800ef7c11160d10138e1a86a77d153b08e1e48a46893f9dcf31de5acc6b2e5bec720a5358a5da34a81f59baa492941084a260ee0a20cd170af087902a11f64b07045c03da20720739ec27d55622441875f4e9d85c7df10b15aea78b6bd95b9b4230478b2696e5b097aadbe9eff322cf9cd4f4e1ce706bb8cf9461f74cc171119076f7bd8475d0e9973e88d1882cbb12d103aab711f524657bb786c2b7cb1f06727425c5455a8187ab96b0263412dd012adac8ce9e3c238ccca71e10246cdf57abecefaf73905c6c6cb681c6c39deb82110ef16a8ec32c28542c78f1cb8c09b0200e15a2cd0fdee1fe21ad70597a4b905632e9b7c877ac5d68e9065164367afae2688ca3a2384e80638acbc2863c107a221b90ae19d430fce92ce062502b56b955b706d796885b6717920f3e9df28456569a127bc08f0b9d17bfeca9f056f11f3a6b2f24e9f00d82d3173605d851cfbceec1c9a2ed8f94a429a04a16a9f588c37abefa3991ea3cc2091c874d38047b8a0cabaaae42d85a02d50ac606b9c37f4e8ef5f7031afdda205daf710f21fe6269218fcfa5092b75cd58a68d29cd59cf0a2b318db2735bba3274170d00d7bfd7b0295fa4ae422df5959b1d5311869ec12e049ff49a4de020c3308bc32752207d18a01a3a09dcf9d25b09eaa6e9006599bad4bd8b0b3619d3fdf6250f9f343213dd4a4a7942a1c2435e1c368fabc93996199a0c769b6d531ac546d92d4e5ddb3f2fa518fa3e4a1aa8b58a08f24b4204410a914712ef73e08c035c0799cb622d82b8add431c9d51cb4811289d13111cc16bfb403fef3389c71bf35b85c7791b6afe1526ea2b34ba9a29a42174ec7934c9827cbaba92d482f8114a8ffca44a8f1b87e856434aae28534691f9bddfa9a32adb6f2ca4bb4c2757be6b952951b71e3fe448181dd8d2b7f3e3c5f40d3763e2aeef93b479e4887b096ca506198f5a863884b6a70555adc5ece3246bff8fdeb9eda4da5476f9db6c8b34d814c19448429035afbf2b4a916b771b56b9b2f6b1e6421f95950e0eef04ffcdc6d03f74797cea810e9aa7905d89a8b0c6b452e2236b40c094de4a821c592df820b6db5a0c13c50a90dc1946172001b8d4ecf40034db013bff23bb47d0172e19e88de666048610c4bb2899b321dba798a69241a522c8617a9bb00597c3952ca22d48c1e70fedaba1e404b6622cc12468d6e257760820f5a3f2e8d54926ca246f9fd700ef2aaf39d96585637baa871af218f155774595c20ea3b21b797b336f20b63d2cdea7a768b6c327116f7c297741dd156b7aec9a75cf4c4f0921370a2fdd99689e59f20918cecdf48ab493f652d4f48aa4160681e8ba77dd9f1abc1657d795206c6e6d67080c8a4361eb1d8dda58be540167f974dc3fd9bde27afa2cddac260e233d4420533d2366f9e31a2ad6e2f4345c278dc8a059929323b4d9664fa07135108a33ecd6484b0b8495093665ea0ce30e77e9d22052528a84d2f5ba90c34a23a0814d8fc69b8ad7d94961ce89594d914e1ed5b553e62c59ec344bff4d97e1d89410c0b9d440aedac5db77f0a0ba4ec4d7151db558c8a9f435d3fff9d784ad5f6b6b6d9ad4fb9f9e0aae75f0ad62b84a43403a1dcf6273086edb77ae360fbf36dd6822be89163609091a0678fa59b348f6c56e6d78c1b98f254d69010c722445d71289499ad545ee61bc335b3edec3b27fbfab591d1d9254c103c814f5de1c8c64730e175ec57028df8ee9ae8503b0766fffed25a2f1b559493ac690726593138a02debd35982c1b7afc6db56b2d632f2946134bf35fc7a78e5d894ea13ec43dc78f66edc7eebdbf274cb80b241e878658fb26d598c73e613ce61c6a2077d17766ec6fd6d4ceac7de94363ceffaa35308475587d5bd2a3f27f247790ec81e9e14d8baea227f2a27023dc93bbcf6dfddc7175d44205f3715db52299411448eadf49d8d864e70590670245286093014c15f55662d0898c31acbf17c197020b954794c5d76a084aeab8b031b39bbe2e25cc6fecee78e9c81f19c0c72e397debc906500c6d0d1c60435b3d75958a3dd520cb93353aff18f49a1bf89eb6d486155a875f7d1b12604b4c53a0ddb62011e87623ff744ad9395b74c2a33510346f82a1e81cdbfac9d60fb1c9cb7db662d7c02bb30eb2be4aa94ffdeb8bc0ad01a1b4f0b48e508882eab31fdd0229f6891f21b71503a866896697b12c2129c7b5564a1d371bf227c320b896af77205d5632b1a54e8e4128c920c2ede855e11324cca6c29b0e5b936b7d75b506dfa5feb75debe97e9c321df6e78d579d67195b04a1601f32e5f901355bf4e6deca1c11a8b0bf7afe23527bd67a14bc2075eadeed94e896b89e42c24a363373f66d53245a1815cd03e1c954bda54eec7c2b882f0e684acfcccc41952ecaba7de01deb24478f9291d809717c8dfa0c03bb8d16407e6161f858a3b66236466fe5ecede2f350d0b537633e4ebd89e38d8d39937bdbc66293b12659d9e1782b22d28d98a5cdd1dd6e48d6c14b8a2bc97b63b9014f2c60b73d7178951439d7ff9f30368da98d98df17af35f553f24facc137b6ab0661ece107482d1e8e4f5b7c56ffe31d7546fcac9a8271d0238ca5adcca2ae32144831bf80864306042b1589707cd3c0e583138f3c3785824a864f25b91c1eefd33d4266fb6422ef3c9ae96b2c3ae01a69d43d22c6cbcc97e029278b316aa9cdf1b6547ac2cbeb4f51d896f579fec4b87b4d52752eec64c636e4e28a38d8b0dad0959ba4f00e3c79d43db8e39aa89a3e6e524e241d2fb4852e4a0cbd64e423a0e460a26136f33dab82204d9fbde8748e566ae99253d9322aadc58696831d9984ae80e49e7721d9549cbd63740e65b333027f6d6bd217805bd7662cd07a41bdac32cf0c147ce9f1bfa9713b2741863a0bea9c12c5c933fb8e6917ac9328606a1c1ee7039e97487262b67494a563ac1342cc7b0114b535a772a754e35025a2f90b798fe3d84a184c5a8e932651292bcb7718688aad0eac914f522af5e33a8396700550bb8969fc36b2c872f1998d27db190526062a833b7a04c452c05f14cd136ae4df8131e129708ca8d6f9ce4f12aaa35357170e7c91dd4ac1b6a54ce148971069c90d1ae27ac2a46b68b63636cef0d0b944927d5448825dbbffdab90635d54b3b9d3da167beb7eb08462990496ad1d048aea990619b321d4ba6f8e72e00132a77338132cbd0cb89e96e740f654d26ee765f5096b4bb59d056d05ef18a4b393398737fef305c76bcf846a66887a51219ef404dd0c3f0210a0e3bf7cc1b775b38650115e194af85c7c0bcee7e1ccf86eda2a775d956133bc53e2754b3cdfb21c2305a74567402263d0551190029ff742c53442a9e2d4840c8a80a4598111b958ffb24e1bd2a0b6da62ee6ad87959029e687c4834738f4e36416b5e1cb64cdd9d36733cd264f7d7a8c271da8a351fe0c4d746dfb4cc328ac7147191ce7ace51064fb60c38d326632d0e7b7665b65b2f44b1d45c47d094506f2e34b2d79b3abf3521cf1105307edaaa09be92f5beeab094efea6847e91e54e22c933567ee65106167d58b41479d54d48dd230ee32d54aca44716cb47cff296a1cd493ed8afef8c72468344a5648f4065847ae354696977bd06c535f627dafb9ed9b11e24837d69fa31f490c3d78533c39fc2851121f5c74b0a236a89e754f49c17afc93230ec1556ea417303d89e6614ff96c489ab1aac068cd0d59c1cdf3f8e0e2b52a6a137e77c379d175f9c0c56d9a06b84ee8287e0401907fc5320096d8a118416e22f8491387ee3906c4be24e9ec4a917e24efb8b0a626488778fb0577a506084b950eda489f2f74b8dbdc592606445cc6a657946ab646e7e07d96e3e08756bb18a845762d3d3b8b74bbf66f4a382d688cde6d2285cab1c53419abc0686c65c1c7f58c76e4da9e793e3bb041ba9d7613ba39bd488450033d194b7f2d1b7b48a23800121915a198adbf95ded4572528ffd1fca0680a5f2370b6150d7a2d9691aa6ffb816035c2dda77aae193040692fe11e753cb1115bb6584250b35f516035f66a00aae3a88bcf283c03efb27342dbf1e418c0bf94d0f2fbc7fc9511c575253537d09d9ca077f822ffdb5702649f4b6ee942833da921f6a40e249bbd3fa5c33d7349210d99cb512091846e3881ce46dc20533536376bf194749bf455af0cc852c2e46cf43475a91f2a116ee42c31a9575a040c24c3eaef06ae1286b6721f28f8a0a212cc44dd19406a95a6b8b16f48c5838d3759e64bb45d584a318bf196b89f8d04cb816f25b039481e70bebb1abb780c0b2c4d8953625499e5ab9835d2e42b6ba351c5bc2de65223d37ee6e881d6b36ce8403ec750adaa456544cd6534912e3a2bbcf453d8e88e954b026da34035d686c25661eec3e686621775a2e803d17c65d7dfa834ad0236ea0bed9e032a3363790ed8c0fe3b7d9f1febe16632e48d7989f2ff2c33a2a296ea44d039c8cb4217d77b61c7cdf55f540463e85ec94c8a9acc3587ea0cc8fead22a26032a61fe4c5abcdf0bdfb0ed5767e77032484d2b72143a5c7bdaf24dc73969a5575b2962c8715ff9c5eec52130cb7727b986aa402d12d6517490380bbbad53b4ffa18eb7feb206007dfa77253de431f2ea83aa804a27ed4d53cc7e702ce0cfc0bdaaaf05f0042c57ce0b0339ef4d14093b541358a3572e707320e156ddeb9c89078bff265264ef824f768299106b07bd7e172b93199970a1c73aa579e7afe3f96f90b80eea77fa1d442576ecc2a1b4d5dd3de1b46285fec880407b64ce5d244f2619d59faec5c46416555d274640a01e2da67b39220b4fe93ca042376963ad58abf3795224be8c3d0699591682f6284ad33c18be1725eb75b4fbb34feba611a3dc96d87e475fb9548ccd78f8c894cc55599afa5f64a10cdf54f10f83597670c63b95d7a34f48c4eb1bc7cf8637b533309b67a79310d6ca619e0fd4d1ccf229c04c56a6fc380eb24e365bb598821b8f1f8d738c911ec63c7481044d33d7dffd875185678f9ed4227eeef3b78fa21ec7724f7fd2cdb749f90e2d8b1eee5662cda002ad3a4704d3b438ce41a51e9010f64e97694584813e2862afef78489e5ea4f89488e91f4322b483d83c25807dce1c808b458c22737ad68178198e6e592e3fb05461fa1a4c22c94d39b9b2ac1b35dc58d84702aff5aba7d7a33704b08cccfb9f37331a4bc0087618bd42b7b5ff108156f1d8932673c3cb79bc199e631c9426ef208a8494baedc900447b3918d96f0663168bec0fd8e75eafe048c8738fe22651f60179ddd66fb39b131c4d3a0cfeab792e8829aeade013cf205c164f784bd0588e898251393eccf40ccf8cfc1454f7a66b4b2e0b2bf58586bb0d98c730813382269acd44afef234e9b81d2d5694d02ff0e9c005f3ee85bac5c274edce64fdbdefefc745f28635b2656319ec9dc497f2fcd3fc4134d871e08d87efec17b7d8e78969f4b289faba48160780ecc299e653805c2bdca2eb340d97df7ba95f3b99c01df68ee3a06b192d7b28ce91117441824e74cc6eed932510d464977581914aebc8f2f4dbe4a5b5e0f71e151fefc71e2b029fdc09854885ae3657910169ea98fde890203b68c123d5caf89573811c68dd464844895aea2d1784a0e2e7e6e2dd3e669a56aa94083da3a15fa9f9ec878676a5592ddfd216b5a0e33e33193d7bf5165c523dd94516fc8cbc8d380d1c59dc132e145bfd30ea5857820c1e2ec63f3b9eace42d2cc760e3ca4b263f9966758ef2452492719e8f6b2036386c2084e30149b663b04a5a5dcdcd9b95b2db705d187c636abcafb0842411f391e21baecb9742f4960f4a683b85e3ca592f67f921660c825db2ec06079fe205e5b34c4bf75f2be8bd208cc6e98cedd2ea29635857187a5efdd63630837790ebd2c866d974c689421220203126f57535282f03d2a50d07da66bf16f1334b4e2fade585ef095c4b35f982b28f1cc5a4eeffc4fbc323c094fcca79652e1eac705920d3bb2d8950c32367c750bf4c78a33b03f293aa878cb1a9124e82f364d057811377bca4333ac584c8d63234181c40a79532948c4ebd6c5f9a80bbed474056d708eb4020adfce7f382339bb78523de1859c25dd5bea0c62c5ca2e322020a9fdefa5cbbce5c0dcd66974c025c8c1074a0f3d6ae44924ccd6165ea6770f2f303cb661edc0e063d750115a9ad13389954e7e553597a5a110404dbfd64f040518738bf933d43380900d41f3799505b2d0d9db60e673287f9e2f4a942168ddd461ddb4ddee0f3846869d294133efc32feb5f7af521508fc5215d871f855b8bccbe28e23b4145a0da7f71997e861eeb014b5166df279d2868221ef8f486a9c378afb211b9bfbe7dc29f5d99745fd7a854c20008ceec1ecb3940ec7e6a7febbb2093ac699a251d863a5b96d9a0dc5d1833981f0c51e11164d1523748575ec68f6f2fbaa4202e05d7b30b2367e94f784ba45fbda72a76fce2a5e0496147a55411fd3478abfa1512cef8135f417ab3e35ec065efe20b7a58a68099b78c89f6c25b70b39ba0f394a2358ee62c666efb26c5c19e5842f8b7e64487b52aa1f220a2a84c631a98265965b69c4d79f436feeb23000fc9aa7bdff96775650a2d441a029af5719b089e5c9ca9797121f00a43799b8d2a13ee0e8ac3cd6c98e8cfee9335e6a0fe5d2ec5b4d7a85b93624fd1bcafbeac9b9541ad9f6dc6a8b0094dd58a59a790157ab20ad7c3c31bfa0879aab970cde950f2b4b97f2c0b3c263abc5b6313eec98f7d8cc165597429b26af9ca8307699e73337a95e91b968ee53ac803b28a096837a3901438370304f2e8232b53f63f2d3771ccfcbbb270cb18af3c1438da1c81d9be391f683b00d2dc708c21ae7d44ed1e1bf677e10ef05e17470bceb2742bb9dc0c581ad04bb65e9181d3579e7c42a75ad5b3a58dc9eee35e277313433cf460366420b5f9a1c6c253eec077f7cf86d58980d0078639a89c8d2eb8399c9bf8ff742f93f5781889f4d4720ae3c63ac2a8a752d868b7b9d4ba7c895ab6cda02c29eeeb24a33f2447dd4f12a76390c7c0a03b6a7b550208017eb58edd51c532871f67c00f4c5c63a2e99ae7a355a3479069b901569e9f6bdbb8d904cbaa2335867387e40dff2c55a977361d38b79fcb5869fab63b85b6e6342c8f21b5e13ad268901525434a34c45d27c4ad516e2d402943776cc1bd755ed8489ee1290b1c84701fe87049ff2230ef8572ca53ae078828a585244031c1e929313b31169771c61e1f6abe4b316f7782ac4e94ba0f6a4f38ff15c042d41f96e9b83fe5bd499ade7079e03f3180ba11bbd0cd9cce3f3f1faa6256b0e8ba39db77350f036fea19393914d6de4f9f388a71e28c42cf17e0e67b814960068117ed10cbbf0a7208a2d50380228a382c5c79d52ee84c6461528348553c3a7bab5eac5749bc7a5febc3e1450d63d48bd629d461f5365e642fcd8c776fae1c0be24299b49fe2bbd41b701fca58122727c9d064c3e359e05a4e9083880cd5a650c6288c43c3b1a120fe93d1f4eb5e0186d267ba0448e66675455a7348f462d555f0398654d025f391fbbdbd6bd0f6042ffca09c6aae5256ed603e13aeee5f91813be452508ee015a5231e4b0ddb103c99dccfb29534aa11f9752eaf3410a44bee236dd28ef1594149e93ff29ddeadf90bf502b35eb5bcca4f3b1c425f1baf2972d0b12df5e3dfced4bef40a4e2876583bdd5530a8644197c3c5f33f8581dabd8d301e0e0c86a6125ed452252ebd2638d3870685e4e3bbb69ecad05699efc8b57a60442fcbe2737d9b5695c0d135ac17ce119e80bc34150450b185685002c0ccaf79f9c9fbc6e26cfa0d9c87547bf159f32e39ea3749457d83b493c14cecc40ceba390eaf07287cbf931ee54138f1e06fcdb9e7917503ebc51bfc653901ec8ff7a220784c341663f535bc02c7894f9abc64cd0e2d4945bad8611f594561afd801fd99a39d76f67ba33ec39653a519ace4e854d4c0b280cd7a3e6b2bdd077a68bfbbce78ec77e7b50229d62112c11c9134400cc08794b523606cab86280b7942eabb1f960d6dec410c694ef425b0d48d0eecc0388670e1103c3561a6b36cd2bcbe64f35a19baeb60f4cac24a5bf2b9c0f9211e9d4f24c950c4ecafc5f8a7ae43275ee65b735ffb408c4e0189cf1e3089665cf9173c040af6c62ad422cd3876ab52b73e13334e0cd439efbf568c5746695d2a55aed5c69e05436004cc767ba17c05265da2c0c586bb2a982b3d4e63af39cce1b3bc3babb3e773b2ba42b83c2224e4ad68a5b2289aff5f6970edc2290ef6f78d52e21e7674f880994a50332e5d479c3349b8a25d0f0e0a84ec225d7e4710674c6f4fb9bdd318c2839a6de81a7f92771341888f70ddac57b4d604136914c64f7f4658179426ff2174c8768ee4458eaa11566215ab985beecaac3098a51e5d67de117be326f05207f88de7ac817595473c9f94a1c7794504f6b2b1894298b5b8eb872e5d2e09e6986d29e4ba00163cc9422fb92e026de1575893c5304d605d4e1603f79e582a9c305259fc1af10870055d42cd400c8414425697606038d1c478c3e34839cecfa69cb091259678888c78c0ea5806ca24e5b14230109ceeb813d6ca1288ae3ad31b33aec170f386c36e8ff71e2a68f72ca6b78129d75615295b3dded8d75cdf1d2d95904538dbf9fd602d4c35989fc2602271eb2963daf656857f2801c3fe4c486ee82d5f87e53a2725d93559678014ba037a9b57f2040d0c5089dd066f75a4203979f2785ec536e17fedfdb40c33d83f37714e0c51ca7b358d5288acc22f05f47365e2c48b48057111b3ec98e3ba5b5fb991b573a138c93a40ef89d9892d1c1b65cc5521fcde38d8ad6bfce0f0b565b2b7d6146785a52de971d5b9ccb1a9930aa32e7910e332b1307c746d441b629d95c2a284a2a98bea3c5f5652908624ba611b5f4749b2ef769323bfad0376151ca80b524d476db15b002feddb3c31373fb11606ef4d0022a1d9ad6d3651e98c3c068c75f1363d4b71ef37f6c82e84159f66589cec3234d1f79cf05771d766b93a221a2c7ebda2d21dc99ae3f010bf27443cc5972b9cef8efbea86ca4c01ad2fd067202f1adabaaf6f967a4ce4a9884b8399bf984ae1f9c21a3e4deb25a2e3dab15689d537c6eb9da167faf4c04c6c8c3f7e07647268e5e25823247180b3837a8ae17e6d42c450cfba86f82df95bc6302aac7a1fa85cc497ce9249067a39f5f993acfd904267071338d92c660d6013f7b01d93acd83f41dad5bd3dd27da9ae4e2c6f5192202392e6b1c716155da6502acb5f7e76d4a26c16eccf17d96c0f54b8a35270cf2321497face529973fca04b84bf8281ccd6397b9d860b4fa7d7c674173ff3406767ddeaba08e9e2764d5c4b41e59d3b9f5987ae79c2f53664f17059c4724e2e89391affe3e559adec9f8d2bd36e161b499a779b1e58a7f94b81b6941b24cfc2a3f7b2d698691751ddff7efd22651911a1a18c96e03f57a0d74e011b5a455c0b3df23ebefec1e04f078f816ea67d5eae7283a6f01c920b4a2f475c312a2e8870f58e08b55d66af2aff29b655d8307866e33dc241846962769d6cbbcf751908c030fdc15ca49ff82927d17a35234bcd3e4e22b7c61df954faf0d74bd29b159a5e6b4b9bf4a9c85f97bcf87e9f381284caf369591239f6693b2d02b93487d1179411a741e99ff7fbb1f6c4537f9838f9a7c5f1285bea471d77e56f45a9ef68f32efa26981e517acefe125df1ffb632ba409256a48d530a20c05c088c96102c5694dab62afb07cb7c38c4cec78d54642695834b25582d10b997a5af89264aa8a1e51b692aba7ad220efae86a5726a9955d3255981f2d73c042e1e775e271c1e874407bb4e7ae6502c097e27c395b8eae11b39d96986326ded0327a8de6a671d697e98cda9b07e6ef3347416b783e070887f7bc7910eddb366989d7556a55a2d11ca9f9519ccd6cc6fef14afb6026ceb5cc1db0b04f255e494e1478fc0701c16a6449fffab102e37ad982d274248057b57dfd6cc4702e416eda713e53a2e3900be89a3e74e007471f98310750e07cfe12389506935074832bea7662054909e6de26c3c776c23a675a9176378adc8dba383efc43368e4af2abc7af5ae3f90cfac8e667a8eceaae0a3baad68a45ec0f761b4e2fa9c95555b32494ad81ba2a179351893e315d3bb11a21813937bbffc89d3b2eded70af5d2a4451f06af9505dfc8229d93b3271d24a3cd0c527dcf13ee6cae451811c127e0b079a9150dcd14e0a6a8ddc475335617d4fd5362007353c9ed0d80b8413b852a34ecdc81efc01826bbaa41ae85b10c623c69ec13b9e0266cb89886178c11dd4b67edb05e244bdfb859923ee92413dea1ef1e4bee375abc23dd80d2bb27ce1d9ae1d561fca89ac8eabefedddd051480065599632303e860ec18168d7bea7461b1dd57b76673bb792a96da575da40fca67fbfa4dfd68d93f850237772949d2d9b58faada8dd4b8d858d1ebef79a13f6c3ef54a0015baddb6987beec832170797963037afd30844a1424f78e1a54ad83e338d670d018d3becf49d623b8f48ee8109fbf748cb7a677f5c210fe6cc515cca4367ee5f33c2b637f817f1c0a69bcf2f4de957f3e6f28aead204b459f9ea5920169913af561f966e3b50ad3da29d993f80cf33362e902d2c2d47c23c2b64cc4988b0c5ea2bb36b0500f154ea4f0fc584d5e80e5487f2bbdde0a1b0b7e6333208ad91f5be8ccae2d99f7fbf7aee8a99d37a5864db6c383d378200f0760f91252805c329699ab9e686d885a15be9dac81d19b9ab346fdc834d7c763632d7564e792369a35e88f67fbe9eae16d2945916987426c35c650c7b389645644805d15c4082f9e3845322dd4dae21523bf1b4c4301c8dd7043dcad6a896455756dff3f42e3a947fa17efb0073562eb31ec37072186d30019235f9b257d58552e8aee4f11904c1275ff0c6f91fb29bdab5cd6b83ffa5fc86fae7b5fbc7e76cc1a453a3015ed5bf67ea2e7597ff5a59cab0ba572bc831da3a3fdf574f9e9b5a54818739106ef574877513aaa20d26a624daed4661669a6d89520b88cfc9b3e2ae0eed8f6c7590954b845982ce708bae81cf96698e6f526e4c87899f9f8e4292c59bcc70ebc37ffc93ac3f26df84dd8ed8c6716897027ba5789d3a0de18767da43919e7109f1090b3d4530237d652e69e2827feb656c1428574f2a910ae7114a3ce5975dd67891e999c0fc5a732a57eea5c8cd2dbc1bbb76d91e927afc71d905508be9ea571b4dca13e37a6f092e1212c933bb015604a9ce41dc91a5e9cd0eb112791a6e16895a02c4dc947e82d8308b8185975c8acdd06257c0ea0f8e6d9ba7b4cc6f6645624639e331c1beb6b401031f523981a0989c6c6db7e8efaaa0a8264c1a089f0b8ac87c0ce28224014bc5372393c11aa85fafc42d0ce39cfeebcb7256040b6fc91f6c73d47081485a5b2760e52d086552094211f214f49b7825b364b50c705ee81d96f17dfdbb4c15194087147a433897c2ee14de7bba1f3269585c7ba8a151a9fc8484cb72fce021989e0d06922cab99fe9659c2b4d9022b58780de75d3dc1e720aaa7288338ebe1f65b2bbfd0aea1d40cf38b6dd76a2289c75f5f3ba35d508a2c5abbc1c2b9da3026ac798e66250f81553bb8ac47c3ba163fffcbae30f20cbe55587575d662639f9c3343b3755e5c68eddeb67aaa101fb94f84f294698e0d89d53b191a01beed0acd5c52d12b5b214186ab398ec8d3796fa0b3e79403d691aba5e17bfe6c3da3dcf66e2da00aa2a759256d102c5e9dcf64a1183db3d52083de4621145fa188c4e74d868cfcf82b8d35c0f2e0eb0a219164691708f5313040e777975500bad689479c150040c2c1ae4a46049f9941652248400826b55183b75c894cc02e609b948f9850fe01bf5024d2fd0a6efe026f74e4717456fa71c52bf0fbc65c26e258940d1f8b46af856e4e43ec7560fd7cab3897ec93c1e10cf0b0ce7daaab92ea077e5edda059b332254320605903c4600a04b3bbd137f930ae365484e9963609261cdbf4297e7e48ae94e73f66974d5647425cd0839550d33d90a88c2fee16ea8c8bb8af7f068b396c8822c76271672b3b66f5d2b675c0f274f50d6802f5914df628440d883a9e1f4abd7c49886c4e986b15987a6a8dd22a83208eb9eee3034dbddac3f5af6d5f5283ea5bad387892e74d7d7a611f92a27dfa89286fc5cc0c253b235b655cd7cd45e409a7e724a664ec09f69ded4be2aa7def03f3f28a8dceb7038cf18855dfdf7fefabbf46f8e1930011d9de3cd67f43906fff57395cf59ad6689ca07de29efd4bc75a726cb7c60369313596c2aa235da1e77df823acb57329166e6d327e5db198886ad5e5dce51da46abc0d8261045c10cd4aa389211f5c40066d13a89ab0d0a7e6672a9a0d080db01c9503037d34668894fde5b77629dead140c0e4499321fcc789a2375f99a6ad05cb35de82e5029276ab52d2cf405a4cb6fd08644ff317e478dee0fd3a0d6e8c6d2ea081227fcd1ae4d4840b2e89e254a524e280fc9c65b356c5d023a23c5b11952023846963c1ec90c9ec154857fb820e2ba3f8b8322cc00d37324b293d4df82c07e9258ecfcff6dbc309357afb399a6d0ac26dc066bbda29735914cbd5fdc6f4c56f356432d7930ff27ef112cdb3de01ba9f46c567d47d08e92baebc51825eceb1e5d9ef4531e4ba41de2f53b0ec86a0d5970ba52c84a00ed677c53d167fd4e97b951c8d296943ef7bdbef5dabae8190f61615177d4f70d3422447432a72742be623cd548d0b1edf57414b0763dafa07e67f4cf9e6069a7b72045695b3e1bae33aeb4b638e927309c04bae98b8b4bf30db98b9f67a9e2b387330bf3a5527bae9f1d233bc5de9479b2a28c2f2a5dd41542c7a8cc20e11a0c7b2d1767e30d6a4ef8e51f785d3e3b654a96e85ee4bf3bb397271c5d06d50be4e78bd7021d2e09018c980af6984c51189564529d857bf012d0ffb40b0dbfbcef897b7e235511b62f5e01021b5911992f666877bfa2d6df76181190252341f596eb5bb22f571d1f66d5da6265ab5574514d0d425432c26a39b8f6f3b3ff59c0b1873a4b72a89b2e782db1073cf851d37154fd232b471d33e5cfcecb651fab87617a2225d42a891ea1bd98edb5a23ae21fccf7b32326373d46cc5207c10513addbe833dff79578741fa4a34533ee4d75f2c50b9e29faeaa038b999f4d26cfe03ec1422d8ece7db589f485789a6b6b82d8c54a5928108f7e50702f5f92da8248368277259ed4d188c5bd33be6a890939ae8539fb9a279d2909aeaa52b105c6e291372481f81310c0917f03aac99deb58c09e424e48dcc832cefece880a8832bb8dda36e1048a5c671baa4128c00321a0d412e53f7fc404921408d49b5e4b8e1bab1b7df2e7e97e96fb1eaf85241d4c86c6147a32ad7ad1e1cced599bc4d464d1f2a60c8971af645f5dd7112326f444d376103338efa7b0f7d63782ecd5dee669ea49d10bf81b1814de2b432facdb1ea54f1d8d0ecb6f6ef8d310e518907a87e365480393ab7c1d0b27a55a5ceee76210c9338bf75a99401a425cc93acd6c083a56e9c353e60f680b8a96bc4cfd1c180b08ab13ac6528358ab3fea7b4a417a8f8aeeaa823e9c14fa3c5405ecd98c79fffbbff889938626d169c905272b3d0a6b635d36b85ec531e63bd5aff256ecd47964a3698d1e4712c55a4d01d9fe893102e07cf2eb4d5d72cc234807b3f40d83cd8c25f24ccefebe080b29247e62c2107a3a74b04475307de486de2cfd00c1b8e13d083b6c4afad97a74ce24b21e17ed9d1a65ab5e093c2ec58adeabaef55259b91d534ab183abecdc09e75c8b8e9d70416da03a23872b368da7540eb95fa7c9a5c14f9106808af795d05edd8ee626078fe994de2722281aff3f587d0f2454f14eed2594c09dcabb5e420d09fe4f47f24fa030c9a2e274bf5c31b553e63219d403a3ada9cc5ff1a86c34bbffa8f9fc70c7d74275d8f7af72714f0b1ef9c6174f5ca739db218908073f62b53b429bc0a7deb88d9eecc6115a69cb98a8a5ed77adeba23ee4c32dba7ed92714b6ca1c0b5f1d4750ef9b53ba5b73e140779b355f4021dd9f919ab14a8edcbd509fa720bb0e02d9e177e58b12f9ae28b058a204c233a4fb6ea61ea13b3d3af78f9686a272ef22c9e034725fab0e5342805027a8c6ade06abfb29f5336a62fa649ace85a1141e3258f29a7886100d2928d9d4ade2478f1310bde170f61be0567215bc78d8a9838a649a89bc47e14444d17c63fd47a1a17f3ac0b112e2a2f2820938442e12affa1c22ba029b749ca541be830633c0ae6f206c00e24b9712d703fec47ea23c03986c11cd2e8622fc58f53fbd16e5bfefe8cdf4f4a0745881fbe54b1c091485185cbe8bfa6460a95a27eefe3366ec47b40af8a6301d65dbfaefb6378f313ef199267058036c02cd1f707359e85c97aeeae0ff30214b5afab235a9637411369602ee1c85fb6cf4d8d97746c8784c764ee4a85a2a681e8411f452036a04214958387489c8169aa7ec5480cb1ec7c0fa5ed2c5d4be1f395bd538c77ea2ec00172d4d19c34dc08e22eb5dd2da72de15aea905886bb880931d2cb7d8334f3a1a9a6712393a6cb6f9f7359559e2fb748050df36fd71eb09efbed81bb7420ace5acc190989266b64fc09e0aa51a3daee4918f675d29e3b9b01e362dcb15bb59454aceb57e77fc9d59b970f0a111b38d7e4d1f07022cea86e5f32467b947fd5278a13e959de98e2568c4e44d62b7188b951c5994f322082ae2d711c0a4abd4d1cc3e9e47dfad34278b71d194a9305caeddc04cf6048228374b7076c8703cd06d55edd8ff3e947d94e9686dea53ca21b40685d2c9a926a218d8b836184c95edb0435216334ee467721cf0449c7d4a6a2e5eec0303dfd958245d24e16238b92db4a27d16093c05f2850867a81951a440a77df3c103f9419bb74ec45eea27b59b67c72bd7c683f6eb86cea5a1752e46ad5c150b7b66f78e4831d5ae9a1fa0cf5f389de23e73ad8121e70049df78343f46ba43c356b234e2812be85cf7916ffad10a4452665df7ba0606fca404ade00b2dd89b91c97eac1def9096105b62ebef4f0f1b0d77b720ab4a671ecbea621b3f079cc653b6e507a8721521856af63d147ff5a969a65a8c22521cd8efeb53daea05d9f1c173b21f4d5ed2d6f133404b05b7116842911418461cd6441f32c094d9c6bdd62381b59553098872f3dedb47dcff15c0111877b58d76b64e3ab779b1782a4eddd59fffe1e0423a27b51b4d4887647a9a1140bd8c0e4b34456f3a3192f2c44a2cb42e5971478dcddd05f26e094a056797fbe9984476e3a5694da57edbc3d28490f37762d688895ef4252bb42543fe2a4323a5f03737f6f7c4883fa04776b08d68d155174a8d93a8e0128bf7960124aaa1d4747ee7e32469cab07a15d22842ab2ead31881648d89570d3c710140d5aa25dc1a9ccd4bb87438658877aac5d74f6d46bcc2113783ef396b0882e7cb113cfb21644cd70332ca9bb25551e9adde014ba22f3a2078570b237bbbe61df636bb2ec474fca12fddd5a92a020b1d7564a09ca15baeeedf152d87fc0a58c1a8190ef0b855d3adfdb1b423ff32ae23c04d9007597ba450960ff4b861826131e089f101817bad57e1b0c660985a80ce1a838006ba89437d62ff011caec4bf62424e3b799b6e4801745715ce5b2aeffc551179237941731c05ba78afe6b71b8439ad856956f49429c46c624fa6a925a8764389bb4c07cc1fa5cd65d1af412e80efc894ebe6734098d1204b6016217fe64c5b9b1ca13204fdcc988e9dd168266a765cd6993a215a9cbcfcb3349a123e778283ee2516edcd572f5dcdbc337eafde9029fe99b0ca6c3265f1db7df2a88a0f5e3e67be4f6954ce6314c794365d94d5b01ef31b46045c088d4e78b85fcb0775d467092ff475bb5020b7ae54e3cd78817e3e8157dd4edb99e28b5c19f9d9efee8e8006691f50a372b337a8abbd4dd377bcded648bc36994eff6b1059d0e9d9bfc582404c91fdeab929c3199cf3eeaeee177e754350f6f2fe448e921ca3551e22c9d3c9a87dfb6db83112c9a12bc7cd91b0cbbae2f4cb22c7ed7a04b9fb2b86ce54fd423de727ce0fea34fdb1d0165185fb1e2a7ce1c610afa1e1341412cf068abb2371ae7e7ee4b27c5c2110dd8fcf6fbcfc1d3c9bbb12088a0df7b6c30d64f4c53ecd020446b81e6d28e1670ef13499794cb445a62ca11c6b97fe4d1967fc56ce03035597db2dd6cb7a2aa2174d1cf22572f6989488b149aa48f6bf6a72ca60ef459c210fbe5a45b8479c331ef51fb464a3e2c41019f9c70c3ec7cf6c941d3d7bf0b5f88d9c29d7b052b0391de731c68a67c630c394cd429e48316507e6622fcaaa800e8b80482771833be9dd86a87b13b819d7cdd8340dc6138a7692163357ea602a7bdd5b2f9c7990259fad704c7c278ca51a2c7436670e69a77225f4c6e22199fe61f8e08d4154376bb4cd4b9a6ae0b5b8315f0cc877b9a38d13de45cf320301a6fafbc3815da80370a86013bf5600b8ee0d6f1655971115766601fa9d3961833c8365e56f2e98a180bf5579d3e87c36b29086ab18d2cf328445fa808ce5c1d9d88f8472d49c25f19c468353e68b9b83acd56c1d6e538f8a288677b85ecbe2ca7fd6de64292e4ace4b2bd2b0b0590790f0848ad644c6a1fdd37b8d0be16940594d29e71d66d2043a59a04f4cc1cf82e13bcb90984e738ce34c8df2622eab36e44d8827ba8f713b7bdeebb61a8c5351cbfa571ec304b93f498f10aed95014593ac239d24636ad61f6c774546cbdeb25744d1e4d7be5a8601aee6ce17bbe7783bc8a7e4571fd9aa3ade9260d8c587b5c6a7d936ad3f5f1adbc213950d7748a3035f5ced10c4e5f468c7c9d183a568949edc08bdc15adf4bc5c315fcb23ee4ffa28ca3025ede05497a1d8055044afaa5cd6e824d183f2df85eb4ec0b17639418b651df693c9adf074ff352b7a7c7ed1c56cfd78dcacc871a95ee5ee52e734af0e182be5456c06120b18df90e8b39eefc9f1eb2d475f1fe0e340d73421fa64283ee59345a4a4e06194f4ace5e75a9d04ca04f4de2d753d1a03dd39461421945ab1173ce26905a3b8da40e064ee20f9a143c783d7aa90ab4e4ffb05eeabbf4e1cdb76d117665b56f669394cd0fa72e504653017604c346c6f65bfa18f4c67ad2d494c0384e75bd0e735b7a844cce59d9da02b0dc4c16715fc7af5110858a0a94cab48880a43addb7d6036d0632f858361e7318c77ae7476145cce85589c6307fce2223806f49d47534d5f96fd158d8c7dde86f3616f948d1db2adf95bed535f09ef2f974ec1e75749cbcbacf0dbc4147bc46ebd33464b5954b3d50bcb51cb02a27ba61eb73b4df8d3ea31642276b39a1b140d06069c183ac2c9ad22f398f3b93b45f61cbb644a2172cc80e91460690f5793c8ed4b6cda0ab7582234c356c12fb47c5b58cf970ec76fc2dad2967993993df9d1d9945b511ba100db35790c1e00895382384eb9f921a027df42d8357192a09f8b951e895786466e6bb78858464f19e1cd55adbc409e16a8eb8695ac4cc022699510e51b08b40efcff1ca4a472671d7aa1189a23babae762bcec6f6a20da9e30f073eca5a99a3d169e3e55fa835757e46f385cb875677091125514ecd80a81a73bc139965c3378b459f73239db824dca4dbb43b8504b5d711eae2c3228f223db2b3f9237ed5b8f24937265e6911a9167dc5452d8792987a843e2eba4c412009c586f61e815a6e1b4b552ec96487fdf62c799b1c281e971759f2eb49864214fab604fc63986b59524b9510fed2c6a723f4abd645a50be2332801eccb984e97610bd942771689ed6a21491708b2c52985f36e2c401232a469d6cb5e0b2d5ea196ee5154356689dea35c8b5bab1338de96d8dd9ccef45efec246f3a627aafb74c7a571fa2bf66ef1719182b6414bec7048ed96096ce3015e6ace800bcaac6fcc3eabe8726e3fdfe4401be01b4f7f5bf18a3a44a9e11b637df6020a7caef959a782b51041878a945550eb2f23715f5b19b2301b500a691da1bbca6a7c17d6e8263caac900b7fb2fb6a71d044402932c0d676dfea43238b1a2bd890df907b1e63089933f45bef51697efe6f79fc2b7f361878509e4c6013701be3affd196b074e0ecb75158865b44017d5ca52a9e5b95fa489e1e599d433ae015135fa4608e758909091bf6b86aa5429cd672987c916c710aca2b692d13e5a8c327def5215278eb50cebbbcd97f005c4f461096f5fdcbc0fb265bcbb22c76a9b613d6588af493e619fbe5a031f7aa941aee30b1f4fe42ed0b31a5cf722707a96d3b671c2d1a25f97d37f0688683631abaa2ab333533e97fb03dba9b043bf22e973b88977907cbc2cd663d8f7ec497b559219432a9382a9309de12624ea6db0d6c6bbc78c665ffb919ea7312ec9ecfd677a7348b7090379860576269fa800f9f565c74f1f751b1f03f53d308eee88fca435b6df3be522c4ac421aa0a2e51c093b8f0761f47d9e993533d4a7dcb4542146c32c1a9af541f85fa3cb11fb8f3ee5a30a5fd7102f83b636c76792230ec8d2adc6d5dad446c15132e7261c1dea3eecaf48ded16b5fa5e90b3abbdc899b0c3b2abada172d312107a750926de5bfe02ba6d5ea74534775409dd98e56d686723b227c9b498bf7f9fe7c08c6775bb73ac4617238857ecd825055a05c7df19db0f779b67da1a1f1df938c7bac0769a270697befed019335cb5815b6a25cacf1d697218bd8fc830d7012f81422ea2d647778d07ca39db6afb120ab2c85944261c8203b6fe031413b3557b8271b7be1e24a362de36eb34bbfaa07bcfa7989e33ae6277e75b204624e44d31ffb7b9e9663c5c5b6864cec91e2263bfb21654ac2eaa8998e4defbbec478d0e7aecfb14623a6e6b893bac385a3d6c26d42d28c7d5f54d9a31b2e390108e6f12d11139d9d417bd3640a6b9f32744956e0b0e4e823dedb27fba82ddaa48dd9d89069ec4f684044a9f1a9ee433e1bac0a58cbe8789662e6acebbb93dbefd522afa47b81e641e82c98f171d3b884e86d97af6e18b603b9d5ec70303569e31422660ce27c4501af07a6b7677e44c7be7d7f8422d7a49369222369e45a2c2aee2fc952b7047af1d5aa3bdfe73253c18bb0a37b5ebeb18b976c2bc06183ef579459ed4b068ec808b75e919b5a28b39649b8293d72dacfc65134f942f7934f65462ad8550bc9b92340d8aa6dafae2bc91dd7aaa239e5681a3d99f201beaa353f0063db06f4d87f5cd9cdaf23e3237d99bd71aa79915aa4708abcb1d8a8a1ba002fc6a552616a967564900a9214ab0e9be47a48f4d98cfa26bd5c2f479c1786625cd1c09fb923221af826ba22754c341d11f45de8aa893132511ef40dffcbd1b24840daf39a7dce6691fefd5b61ff040b639c2643c68f2a16ddb49115b82bf02013a6e1a0f1f733553df8bdb50f5423c674c43dc9ba30e16c785562a1f4731b8756b1be0027e48a0d3df1a184ef089ca19d3347a34a73f7f0679e5603ba09ba15ecb7e22af573dadc904535b7212007c061166b00abeb33ed5b9035b93e74c39650a1e5c071f688e6a7c971cfc565d5f64a0d5c632c770f4075c61c7758c5afd18e32f1e1a18bfa0c36515db96ae6f050abcbbb05db00bd3ed4458aa775e137567f7c7fddd1d5d97a319b2a3eb8d32384dbb3c4e4c62a799a60f0214fed12d157ad9428edd8ede78e7d3cb1ac28ddd09922b064bb0b105a9e6c8adef7b7f21e43fc4e09bb049251265a5adb82c587b528d61d64033829de047accfdaf4a662a61f176d1552f966ac1ab60ff6c24c11fff11d826d087c2356b7546bd0428957514a59047f65c1fdef349a62450f41350030ece9d0d3d4ddecb46bb7c4151d8c12b6e1070556e2b0974ce18953309984446742d3a22309402467b09815b59bc010e2df8819a837d778f0e53d4c27c118fa7442ccc99cedfe945bb5534fd66b9e53a863f2ffe84a3a6b49961ac1ee20f6b5cdb1779c499c7ff03ddac8c383ee01ca88266202d94232476c1480e2dd860d2d259d05f840e9448fc286632672f731efb320815efc1d7527a2951462b4891aee3c9bbd1878dee39ff88b1065c340cc05cb120a6684fcafbc58a9f82aba200e6be95e56f47c03b786b672eb954a9b78fe68def025192ac2be5372beb641987e22eab4f367d4fdabcfc1b2f242c2d104b927f6ed65f2111f86eb72ce497550364c357ea7b52b7f13a92090c156e684eadb42d5aea54be24ea7db2142ac99159e1c16639c8f639bb3e100ed2001a71f317a3fbdac6bfda7c6487067b65a41f60304dbf54a16b801daa2bac8043c6a68191a4295151dd64ba80e25bc102a792a7723ec69ae8017634f7bf2838f62078c414ad729552ba27744c1110e6b1df89165e7d3f54e304f9ab410b065d5edf4886d3e394efc9642ea6a0de890afcdc318dd204410f498f401264dfc476cb553077af186646a71ac40556934346f71c6c62fc633b427549745382b30b9eb5dde1a0057f7f631ca97ab84be6cbc54c69568e81d05e3513d9514300ed53ce3cc924347978a624de904ca123bfe9665031cb5d929067914643f8846ac7276c58bbfb5b15b276b9439c054ad87b75b11405bb96db317275c7a13b7a50264024a9e72e183ad3528efac63b798839cbfdd144e09d5f5c48008dc8053e3f866d7231dcdbd81107f237f61b488de086b1dc3fcbacff7014ff18635a2383933b971dac63a9120034598a430b574e9cfed8e992e9e5c48cd2e1c411ea2ce83854d8d32606e8f666373574dc874d32ba30d3f2930115051e5cbd590a082de9f1a30510d1166422e12c717389d63e98401c6af9e7f2ba3c42745c4b62687fc9a449b29f556cb865fb7caf3100ffeb3f4f4021a12c24429883d7ada0e0247f11803cc6679af81cc022aeb2e17c86e54dda8a00b64261d83fb9c2144273c1afa5788dc53a1bf4c413441d3dff5b4fb065fcfeb985ded8416cd15016e421a98669c007a7fe85cb4647e089cb056a2bfd9689c45f2cdf7906aae45af2cd90bca4235cae1e17f33fc93d3d02f9d3408da5a5c96fe4dc9569e35d325c0cd020697288818a5d42da6c3fbd809d2ea2c6f005daf0cf96b3f3577a25b06ef64ac9d55231960f142c4bfaaf2fe75320154c3f885a7b5ea65d97f37ad08293c6c0e715632921e9fdcb71e6f73d3753fd626002948c487828e60288a1db323f477e7e8a3ffc861a88b381934737fb1d9a8d061ca3121d6747bfa7005c8833c967669a314d77871ecd4812804524d9bb9a3aef5abd08bbfee9719e36c93652ff956dbcf504adfd11f957e3b6a7a3c565927bb9b51fd1cac34a3098a545673136b18d16df43a44d73f703be46cba6aa814eeb19a00b48863233847f803943de8a17eeabd4d09b606706cf54f8177543b4970e5affe451cb29f2ef83ef428b567dbb2888fe314aab30fe21108d4e3af011d1d611bbdb05030d9fb29d4871928d341804cf482644ef44f75e413a8c6260c0d75981e4bf4f075a50a86f80db6643d204f2e20e2827f1429d005293c665481b3113861b4762517795c4710eaa2fd942ea04d283203e5789a5d5aace96a6ff684b9b2024c6744e3fc6f8a066ac598063373626fe983db9db93ce4556c9d964c3add872ce173ad8883506a184c434c37be521f75aa166a143214b3c6428c50deeb9152dd8718d0c7dc219c3ace0fe27d393a999beb0ece7855abb5f6e3451e86c341204f57358f07cb8595bf6100cee2ad516893697d9d110a196c2e424211315556e89ccc2c764fb15aea204963ae9b82e7066633dd16cdef986b70c4b8b23909f7a7218e4614b367aa83b96133f2e00024854961067e3ce8b85beef15609cc3b4cf8d2aa9543c5e2b7f0f675155fd32c1314535b141e44813f991ae743a31de016ce26afe4c588755cf0ecb91f2955a971a200aba731a5c38c62ef28cd3382849d58afdd2ae0ce3b6e4687056c7883f9fefc82086cd9639edf16a2694240e4942c531d8d95133c0e14f5c80278974024e71425a6e2d989e3c452c7a24dc93efeeffdb995018868a9c12fb250b781ba0ff38b358a735edbeb4fca36d8f72856960d006e82f6efabffcffd8657ae031e54acb23d508bbee9dae702854c588f87c250e93344f3045714ac1abad7d4db7143da12ea982a7125b60ce6700fdd0036b44851d95a1ac9f9ae20197bc99b9c2f10c20a046ca6031aec1fa1037b05fba9e06f4bdee65d561047c6dd790c27ddeb945072c35aeeb943855a2fb0f17132252d3580f0bb135ae4a351ba9658006b074d9b97faaacfb316f3f936343ff2597267d63c2c6e6a9d1fb9a2b268e3096a98fb518d0872a16ab43c549e52550d2fb620dab36aff4b9cc474225cbbad46d1dae56337f9928980b17930ace6028dd5dede69f49b04502e44dc2568629e645c197c419c4a7f2615707899af2e217dbd13f9816a0a78663e0c62ad7d9a0a3eaa248fa277f9824eb6f30c5b2d22a646e261f5953f10d58ba6be495a7cb52933620fba95258794e0a166fd4616e48145dd6c15cab3caad176a975077755efa91399713313eb618b2ff1d4c3188072c18a33036dea4df2e8582173faf0942fee29ac61a03cd71559a6a360821a6d80bc570dc963ef29247c49ba36c91062aeab4d219cbcb0546861a3d80dfebf48c1256ea6bfc154857c8b1959e4acba892570a9066e732b4baa39c94b7bd0728fd13aa453669fa6fd07ec7ac8f217eee3087f842079bd40868de123f37e096d11d97fea73375f0d9e22ebb4c7a390f6bc5b3e57e37b4cf39b535fbc01d3e735008c1143b5687a55eddc8f7cd8a2073f392c6e80e69ce15f6a0ea25189b6fba712a73e591d1a4674eb91f189652e0fb53e6c16c5d8f7fc618a19a8b8dece985008e6703fda47413c4930945e606b16e3b4567bf9edd3b4ad1ff21b3995fceb207f87f62857b86e8a45cdd0829d9ec0a560b8ef671845199afc736dacb1747696cd557c4e702e3ec371f039f820c6017299c265903d9f2ff61302703e03fd8dcd9eab485aca6c1d32c9fbb5214668b897c0539f83fd6e8e688ea29c8d47a0e7d5286ce63b022506531cc470d9c51eca530cf02277aa227fc33d410e908bac8bf7299356e673899c6b4f925e1f2b4e52af19b583305dcdd0b2c1646a41778d5aac45ab41afc78ffdc8a9190e137827b2d3f7db21de90e981cd190351dc1f69166ccd2edee0f4e8cc91f0db6d330fc97a7bc48baa97bd5a456b6483b9ea02b0288431deefa7d0aa63301c7bfabfd45b222768443f5073cfbbea21ee7e2ce67a41e27290079c484520a7276d2824835008ed9c9ed2c8e2ad7d49c50430072ca7d0fec15e0a9913271bf3afd5ff70af5472389ffd441d1f1bf3cec77c214d8184f1e0f2a6a6e7b3f9d607b13de4394f507a80f9fd3b693d3a5a4de6506472f05e36bc64dd7118dd414bb8203eaa148653ed85f3690520935a2dac736106b2560e9a37a739d07f6771a486388bdf57f24937464eb901d7fb6a4c97669a13a7f8e82307d1e8fbb23aed04c51f2c5dee8f82223e72b65d645569e6f659a84a5da4dde5a09ba460ce97a754c7464f4bfbc13135315cdea725cdf600120d251491002c625bb73162ba17db27d2ee25d7d1e2996bdac284f92f1a20685684dbe426128e8b6e613bb9e002f039f9aa71d0bacc1d0a129bf5fb99859014aa933fc95ee74574825979d87d7d4b2acd664c268617a86a13155c203ae34d1d7f0597b0951218352290fe41ca35a73e27d1b969fffd116f00a63d74a34cc8816c1e0e699be7826c13d3587a8259a036d57763fbb5c26380ac0869162d5f2d48057a05790c6500fa4902c1184e30cd647cbd74018780465ad94b006c310f3698a61b8da284d6ddea7691fce9b826a1b4a0d531b3360d12f80c83934a0e389793f85579a46af22972becc05dbab4235e15c3de584df55228bceff8d9902fc10621aa81320cb3d18b660b5a0259ca354cf70dd167e7501fd106086d74f6a5e4a8608f8ab9a567c5f2b060da4759b392807285ce517daa0f6bd19b6446dcea5526924f3d5f6fa3ffeb72d9823e385fee325072b37667d8b93e2b11748fdd0665bf4235939ed48653af51c861c96b98d08c019f470b742c0217520e7d717ef37332408b282217c72a855231da2817c813</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-xray">      <input class="hbe hbe-input-field hbe-input-field-xray" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-xray" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-xray">您好, 这里需要密码.</span>      </label>      <svg class="hbe hbe-graphic hbe-graphic-xray" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">        <path d="M0,56.5c0,0,298.666,0,399.333,0C448.336,56.5,513.994,46,597,46c77.327,0,135,10.5,200.999,10.5c95.996,0,402.001,0,402.001,0"></path>        <path d="M0,2.5c0,0,298.666,0,399.333,0C448.336,2.5,513.994,13,597,13c77.327,0,135-10.5,200.999-10.5c95.996,0,402.001,0,402.001,0"></path>      </svg>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      
        <tags>
            
            <tag> 游记加密 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
